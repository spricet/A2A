{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Agent2Agent (A2A) Protocol","text":"The Agent2Agent (A2A) Protocol is an open standard     designed to enable seamless communication and collaboration between AI agents.     In a world where agents are built using diverse frameworks and by different vendors,     A2A provides a common language, breaking down silos and fostering interoperability.     <p>Build with  ADK (or any framework), equip with MCP (or any tool), and communicate with  A2A, to remote agents, local agents, and humans.</p> <ul> <li> <p> A2A Announcements</p> <p>Ramp up quickly</p> <p> Announcing the A2A Protocol (Apr) our initial blog</p> <p> Agents are not tools (Jun) our TL thought piece</p> <p> Google Cloud donates A2A to Linux Foundation (Jun) covered by Forbes</p> <p>Dive deep with end to end examples</p> <p> Designing with A2A (O'Reilly)</p> <p> Start the Python Tutorial</p> </li> <li> <p> Video Intro in &lt;8 min</p> <p></p> </li> </ul>"},{"location":"#why-a2a-matters","title":"Why A2A Matters","text":"<ul> <li> <p> Interoperability</p> <p>Connect agents built on different platforms (LangGraph, CrewAI, Semantic Kernel, custom solutions) to create powerful, composite AI systems.</p> </li> <li> <p> Complex Workflows</p> <p>Enable agents to delegate sub-tasks, exchange information, and coordinate actions to solve complex problems that a single agent cannot.</p> </li> <li> <p> Secure &amp; Opaque</p> <p>Agents interact without needing to share internal memory, tools, or proprietary logic, ensuring security and preserving intellectual property.</p> </li> </ul>"},{"location":"#a2a-and-mcp-complementary-protocols","title":"A2A and MCP: Complementary Protocols","text":"<p>A2A and the Model Context Protocol (MCP) are complementary standards for building robust agentic applications:</p> <ul> <li>MCP (Model Context Protocol): Connects agents to tools, APIs, and resources with structured inputs/outputs. Think of it as the way agents access their capabilities.</li> <li>A2A (Agent2Agent Protocol): Facilitates dynamic, multimodal communication between different agents as peers. It's how agents collaborate, delegate, and manage shared tasks.</li> </ul> <p>Learn more about A2A and MCP</p>"},{"location":"#get-started-with-a2a","title":"Get Started with A2A","text":"<ul> <li> <p> Read the Introduction</p> <p>Understand the core ideas behind A2A.</p> <p> What is A2A?</p> <p> Key Concepts</p> </li> <li> <p> Dive into the Specification</p> <p>Explore the detailed technical definition of the A2A protocol.</p> <p> Protocol Specification</p> </li> <li> <p> Follow the Tutorials</p> <p>Build your first A2A-compliant agent with our step-by-step Python quickstart.</p> <p> Python Tutorial</p> </li> <li> <p> Explore Code Samples</p> <p>See A2A in action with sample clients, servers, and agent framework integrations.</p> <p> GitHub Samples</p> </li> <li> <p> Download a SDK</p> <p> A2A Python SDK  A2A JS SDK  A2A Java SDK  A2A .NET SDK</p> </li> </ul>"},{"location":"community/","title":"Welcome to the A2A Community","text":"<p>The Agent2Agent (A2A) protocol is generating significant buzz across the tech world, and for good reason! This open interoperability protocol is designed to enable seamless collaboration between AI agents across diverse frameworks and vendors. By standardizing communication, A2A aims to unlock complex workflows, enhance productivity, and foster a new era of \"Agent Interoperability\". Don't just take our word for it \u2013 see what the community is saying!</p>"},{"location":"community/#the-word-on-the-street-social-highlights","title":"The Word on the Street: Social Highlights","text":"<p>The launch of A2A has sparked lively discussions and positive reactions on various social platforms. Here's a glimpse of the excitement:</p> <ul> <li> <p>Rapid Interest and Adoption: The A2A GitHub repository has seen an explosive surge in popularity. This rapid interest underscores the industry's eagerness for a standardized agent communication protocol, with many companies collaborating and contributing.</p> </li> <li> <p>Microsoft's interest via Semantic Kernel: Asha Sharma, Head of AI Platform Product at Microsoft, announced on LinkedIn that \"Semantic Kernel now speaks A2A: a lightweight JSON-RPC protocol that lets agents swap context, not code or credentials, over plain HTTP. Drop it into your Foundry stack for instant, secure, async interoperability with any A2A-compliant agent, regardless of modality\". The post received numerous positive reactions, including \"A2A support in Semantic Kernel is a key unlock \u2014 context-level interoperability without sharing code or creds is how agent ecosystems scale securely across clouds\".</p> </li> <li> <p>Matt Pocock's Diagramming Intent: Matt Pocock, a well-known developer educator, shared on X \"I've just been reading the Agent2Agent technical docs - Google's new protocol for agent to agent communication. You know what that means. Let's diagram them:\". This tweet, liked and reposted hundreds of times, includes some great diagrams explaining the A2A protocol.</p> </li> <li> <p>Craig McLuckie's \"Hot Take\": Craig McLuckie shared his initial thoughts on LinkedIn \"Hot take on Agent2Agent vs MCP\". His post highlighted Google's careful positioning of A2A as focused on interactions between agentic systems, rather than agents interacting with resources (the focus of MCP). This distinction is crucial for improving models' ability to understand expectations from other agents. McLuckie also pointed out the potential for A2A to enable systems to advertise specific capabilities and specialities, which is seen as \"sensible\".</p> </li> </ul>"},{"location":"community/#community-deep-dive-videos","title":"Community deep dive videos","text":"<ul> <li>Zachary Huang explains in his YouTube video, A2A \"complements\" MCP. While MCP acts as a \"USB-C port for AI applications\" connecting agents to tools, A2A acts as a communication standard between the intelligent agents themselves. This layered approach allows for building powerful systems where agents use A2A to coordinate and MCP to access necessary tools.</li> <li>Jack Herrington on his YouTube video walks through some of the provided examples and closes with his opinion that \"Having a specific protocol for agents to talk to other agents is valuable\" and reiterates, \"LLM plus tools are agents. MCP gives agents those tools. So that's why A2A and MCP play really nicely together\".</li> <li>Cole Medin suggested on his YouTube video that \"A2A was released very recently but it's already looking like it's going to follow a similar path\" to MCP in terms of growing interest. He also demonstrates the samples step by step and provides a summary of core concepts.</li> <li>Sam Witteveen covered A2A on his YouTube video immediately after Google Cloud Next, discussing the value of making protocols open and not ending up with conflicting protocols.</li> </ul>"},{"location":"community/#community-contributions-to-a2a","title":"Community Contributions to A2A","text":"<ul> <li>Python Quickstart Tutorial PR#202</li> <li>LlamaIndex submitted a sample implementation PR#179</li> <li>Autogen sample server PR#232</li> <li>AG2 + MCP example PR#230</li> <li>PydanticAI example PR#127</li> <li>Go example PR#52</li> <li>Daytona sandbox running agent PR#170</li> </ul>"},{"location":"community/#what-is-driving-this-excitement","title":"What is Driving This Excitement?","text":"<p>The enthusiasm surrounding A2A stems from its potential to address key challenges in building sophisticated AI applications:</p> <ul> <li> <p>Breaking Down Silos: A2A aims to overcome the limitations of siloed AI systems by providing a universal framework for agents built on different platforms to communicate and collaborate securely.</p> </li> <li> <p>Enabling Complex Collaboration: For tasks that require the expertise of multiple specialized agents, A2A provides a standardized way for them to delegate tasks, exchange information, and coordinate actions. This mirrors how human teams work together, distributing responsibilities for greater efficiency.</p> </li> <li> <p>Dynamic Agent Discovery: A key feature of A2A is the ability for agents to discover the capabilities of other agents through standardized \"Agent Cards\". This dynamic discovery allows for more flexible and adaptable multi-agent systems.</p> </li> <li> <p>Complementary to MCP: As stated on our A2A \u2764\ufe0f MCP topic page and affirmed by many community, A2A \"complements\" MCP. MCP acts as a communication standard between models and resources, providing tools for agents. A2A acts as a communication standard between the intelligent agents themselves. This layered approach allows for building powerful systems where agents use A2A to coordinate and MCP to access necessary tools.</p> </li> <li> <p>Open and Community-Driven: Google has released A2A as open source, inviting contributions from the broader community to refine and expand its functionality. This commitment to open collaboration fosters innovation and broad adoption.</p> </li> </ul>"},{"location":"community/#the-future-is-interoperable","title":"The Future is Interoperable","text":"<p>The social media buzz surrounding Google's A2A protocol clearly indicates a strong interest and belief in its potential to revolutionize the development of multi-agent AI systems. By providing a standardized way for AI agents to communicate and collaborate, A2A is poised to unlock new levels of automation, efficiency, and innovation. As enterprises increasingly adopt AI agents for a wide range of tasks, A2A represents a crucial step towards realizing the full power of interconnected AI ecosystems.</p> <p>Stay tuned for more updates and join the growing community building the future of AI interoperability with A2A!</p>"},{"location":"partners/","title":"Partners","text":"<p>Below is a list of partners (and a link to their A2A announcement or blog post, if available) who are part of the A2A community and are helping build, codify, and adopt A2A as the standard protocol for AI agents to communicate and collaborate effectively with each other and with users.</p> <p>Note</p> <p>If you're interested in becoming a partner of A2A and getting your listing added to or updated on this page, let us know by submitting this form, and we'll contact you soon!</p> <ul> <li>Accelirate Inc</li> <li>Accenture</li> <li>Activeloop</li> <li>Adobe</li> <li>AI21 Labs</li> <li>AI71</li> <li>Aisera</li> <li>Almawave.it</li> <li>AliCloud</li> <li>ArcBlock</li> <li>Arize</li> <li>Articul8</li> <li>ask-ai.com</li> <li>Atlassian</li> <li>Auth0</li> <li>Autodesk</li> <li>AWS</li> <li>Beekeeper</li> <li>BCG</li> <li>Block Inc</li> <li>Bloomberg LP</li> <li>BLUEISH Inc</li> <li>BMC Software Inc</li> <li>Boomi</li> <li>Box</li> <li>Bridge2Things Automation Process GmbH</li> <li>Cafe 24</li> <li>C3 AI</li> <li>Capgemini</li> <li>Chronosphere</li> <li>Cisco</li> <li>Codimite PTE LTD</li> <li>Cognigy</li> <li>Cognizant</li> <li>Cohere</li> <li>Collibra</li> <li>Confluent</li> <li>Contextual</li> <li>Cotality (fka Corelogic)</li> <li>Crubyt</li> <li>Cyderes</li> <li>Datadog</li> <li>DataRobot</li> <li>DataStax</li> <li>Decagon.ai</li> <li>Deloitte</li> <li>Devnagri</li> <li>Deutsche Telekom</li> <li>Dexter Tech Labs</li> <li>Distyl.ai</li> <li>Elastic</li> <li>Ema.co</li> <li>EPAM</li> <li>Eviden (Atos Group)</li> <li>fractal.ai</li> <li>GenAI Nebula9.ai Solutions Pvt Ltd</li> <li>Glean</li> <li>Global Logic</li> <li>Gravitee</li> <li>GrowthLoop</li> <li>Guru</li> <li>Harness</li> <li>HCLTech</li> <li>Headwaters</li> <li>Hellotars</li> <li>Hexaware</li> <li>HUMAN</li> <li>Incorta</li> <li>InfoSys</li> <li>Intuit</li> <li>Iron Mountain</li> <li>JetBrains</li> <li>JFrog</li> <li>King's College London</li> <li>KPMG</li> <li>Kyndryl</li> <li>LabelBox</li> <li>LangChain</li> <li>LG CNS</li> <li>Livex.ai</li> <li>LlamaIndex</li> <li>LTIMindTtree</li> <li>Lumeris</li> <li>Lyzr.ai</li> <li>Magyar Telekom</li> <li>Microsoft</li> <li>McKinsey</li> <li>MongoDB</li> <li>Monite</li> <li>Neo4j</li> <li>New Relic</li> <li>Nisum</li> <li>Noorle Inc</li> <li>Optimizely Inc</li> <li>Oracle / NetSuite</li> <li>Palo Alto Networks</li> <li>PancakeAI</li> <li>Pendo</li> <li>PerfAI.ai</li> <li>Personal AI</li> <li>Poppulo</li> <li>Productive Edge</li> <li>Proofs</li> <li>Publicis Sapient</li> <li>PWC</li> <li>Quantiphi</li> <li>Radix</li> <li>RagaAI Inc</li> <li>Red Hat</li> <li>Reltio Inc</li> <li>S&amp;P</li> <li>Sage</li> <li>Salesforce</li> <li>SAP</li> <li>Sayone Technologies</li> <li>ServiceNow</li> <li>Siemens AG</li> <li>SoftBank Corp</li> <li>Solace</li> <li>Solo.io</li> <li>Stacklok, Inc</li> <li>Supertab</li> <li>Suzega</li> <li>TCS</li> <li>Tech Mahindra</li> <li>Telefonica</li> <li>Test Innovation Technology</li> <li>the artinet project</li> <li>Think41</li> <li>Thoughtworks</li> <li>Tredence</li> <li>Two Tall Totems Ltd. DBA TTT Studios</li> <li>Typeface</li> <li>UKG</li> <li>UiPath</li> <li>Upwork, Inc.</li> <li>Ushur, Inc.</li> <li>Valle AI</li> <li>Valtech</li> <li>Vervelo</li> <li>VoltAgent</li> <li>Weights &amp; Biases</li> <li>Wipro</li> <li>Workday</li> <li>Writer</li> <li>Zenity</li> <li>Zeotap</li> <li>Zocket Technologies , Inc.</li> <li>Zoom</li> <li>zyprova</li> </ul>"},{"location":"roadmap/","title":"A2A protocol roadmap","text":"<p>Last updated: Jul 16, 2025</p>"},{"location":"roadmap/#near-term-initiatives","title":"Near-term initiatives","text":"<ul> <li>Release <code>0.3</code> version of the protocol which we intend to keep supported and without breaking changes for a significant amount of time with backward compatibility of the SDKs starting at version <code>0.3</code>. As part of this release there are a few known breaking changes including:<ul> <li>Update the <code>/.well-known/agent.json</code> path for hosting Agent Cards to <code>/.well-known/agent-card.json</code> based on feedback from IANA.</li> <li>Refactor class fields to be more Pythonic and adopt <code>snake_case</code>. PR 199</li> </ul> </li> <li>Solidify the support for A2A extensions with SDK support (starting with the Python SDK) and publishing sample extensions.</li> <li>Introduce support for signed Agent Cards Discussion 199 to allow verifying the integrity of Agent Card content.</li> <li>Enhance the client side support in SDK (starting with Python) to expose ready-to-use A2A clients, streamlined auth handling and improved handling of tasks.</li> </ul> <p>To review recent protocol changes see Release Notes.</p>"},{"location":"roadmap/#longer-term-3-6-month-period-roadmap","title":"Longer term (3-6 month period) roadmap","text":""},{"location":"roadmap/#governance","title":"Governance","text":"<p>The protocol has been donated to the Linux Foundation. The TSC is working on implementing a governance structure that prioritizes community-led development with standardized processes for contributing to the specification, SDKs and tooling. As part of the effort there will be dedicated working groups created for specific areas of the protocol.</p>"},{"location":"roadmap/#agent-registry","title":"Agent Registry","text":"<p>Agent Registry enables the discovery of agents and is a critical component of a multi-agent system. There is an active and ongoing discussion in the community around the latest Discussion 741.</p>"},{"location":"roadmap/#validation","title":"Validation","text":"<p>As the A2A ecosystem matures, it becomes critical for the A2A community to have tools to validate their agents. The community has launched two efforts to help with validation which the group will continue to enhance in the coming months. Learn more about A2A Inspector and the A2A Protocol Technology Compatibility Kit (TCK).</p>"},{"location":"roadmap/#sdks","title":"SDKs","text":"<p>A2A Project currently hosts SDKs in four languages (Python, JS, Java, .NET) and contributors are adding more including Go (in progress).</p>"},{"location":"roadmap/#community-best-practices","title":"Community best practices","text":"<p>As companies and individuals deploy A2A systems at an increasing pace, we are looking to accelerate the learning of the community by collecting and sharing the best practices and success stories that A2A enabled.</p>"},{"location":"specification/","title":"Agent2Agent (A2A) Protocol Specification","text":"<p>Version: <code>dev</code></p> <p>See Release Notes for changes made between versions.</p>"},{"location":"specification/#1-introduction","title":"1. Introduction","text":"<p>The Agent2Agent (A2A) Protocol is an open standard designed to facilitate communication and interoperability between independent, potentially opaque AI agent systems. In an ecosystem where agents might be built using different frameworks, languages, or by different vendors, A2A provides a common language and interaction model.</p> <p>This document provides the detailed technical specification for the A2A protocol. Its primary goal is to enable agents to:</p> <ul> <li>Discover each other's capabilities.</li> <li>Negotiate interaction modalities (text, files, structured data).</li> <li>Manage collaborative tasks.</li> <li>Securely exchange information to achieve user goals without needing access to each other's internal state, memory, or tools.</li> </ul>"},{"location":"specification/#11-key-goals-of-a2a","title":"1.1. Key Goals of A2A","text":"<ul> <li>Interoperability: Bridge the communication gap between disparate agentic systems.</li> <li>Collaboration: Enable agents to delegate tasks, exchange context, and work together on complex user requests.</li> <li>Discovery: Allow agents to dynamically find and understand the capabilities of other agents.</li> <li>Flexibility: Support various interaction modes including synchronous request/response, streaming for real-time updates, and asynchronous push notifications for long-running tasks.</li> <li>Security: Facilitate secure communication patterns suitable for enterprise environments, relying on standard web security practices.</li> <li>Asynchronicity: Natively support long-running tasks and interactions that may involve human-in-the-loop scenarios.</li> </ul>"},{"location":"specification/#12-guiding-principles","title":"1.2. Guiding Principles","text":"<ul> <li>Simple: Reuse existing, well-understood standards (HTTP, JSON-RPC 2.0, Server-Sent Events).</li> <li>Enterprise Ready: Address authentication, authorization, security, privacy, tracing, and monitoring by aligning with established enterprise practices.</li> <li>Async First: Designed for (potentially very) long-running tasks and human-in-the-loop interactions.</li> <li>Modality Agnostic: Support exchange of diverse content types including text, audio/video (via file references), structured data/forms, and potentially embedded UI components (e.g., iframes referenced in parts).</li> <li>Opaque Execution: Agents collaborate based on declared capabilities and exchanged information, without needing to share their internal thoughts, plans, or tool implementations.</li> </ul> <p>For a broader understanding of A2A's purpose and benefits, see What is A2A?.</p>"},{"location":"specification/#2-core-concepts-summary","title":"2. Core Concepts Summary","text":"<p>A2A revolves around several key concepts. For detailed explanations, please refer to the Key Concepts guide.</p> <ul> <li>A2A Client: An application or agent that initiates requests to an A2A Server on behalf of a user or another system.</li> <li>A2A Server (Remote Agent): An agent or agentic system that exposes an A2A-compliant HTTP endpoint, processing tasks and providing responses.</li> <li>Agent Card: A JSON metadata document published by an A2A Server, describing its identity, capabilities, skills, service endpoint, and authentication requirements.</li> <li>Message: A communication turn between a client and a remote agent, having a <code>role</code> (\"user\" or \"agent\") and containing one or more <code>Parts</code>.</li> <li>Task: The fundamental unit of work managed by A2A, identified by a unique ID. Tasks are stateful and progress through a defined lifecycle.</li> <li>Part: The smallest unit of content within a Message or Artifact (e.g., <code>TextPart</code>, <code>FilePart</code>, <code>DataPart</code>).</li> <li>Artifact: An output (e.g., a document, image, structured data) generated by the agent as a result of a task, composed of <code>Parts</code>.</li> <li>Streaming (SSE): Real-time, incremental updates for tasks (status changes, artifact chunks) delivered via Server-Sent Events.</li> <li>Push Notifications: Asynchronous task updates delivered via server-initiated HTTP POST requests to a client-provided webhook URL, for long-running or disconnected scenarios.</li> <li>Context: An optional, server-generated identifier to logically group related tasks.</li> <li>Extension: A mechanism for agents to provide additional functionality or data beyond the core A2A specification.</li> </ul>"},{"location":"specification/#3-transport-and-format","title":"3. Transport and Format","text":""},{"location":"specification/#31-transport-layer-requirements","title":"3.1. Transport Layer Requirements","text":"<p>A2A supports multiple transport protocols, all operating over HTTP(S). Agents have flexibility in choosing which transport protocols to implement based on their specific requirements and use cases:</p> <ul> <li>A2A communication MUST occur over HTTP(S).</li> <li>The A2A Server exposes its service at one or more URLs defined in its <code>AgentCard</code>.</li> <li>Agents MUST implement at least one of the three core transport protocols defined in this specification.</li> <li>All supported transport protocols are considered equal in status and capability.</li> </ul>"},{"location":"specification/#32-supported-transport-protocols","title":"3.2. Supported Transport Protocols","text":"<p>A2A defines three core transport protocols. A2A-compliant agents SHOULD implement at least one of these transport protocols. They MAY be compliant implementing a transport extension as defined in 3.2.4 All three protocols are considered equal in status, and agents may choose to implement any combination of them based on their requirements.</p>"},{"location":"specification/#321-json-rpc-20-transport","title":"3.2.1. JSON-RPC 2.0 Transport","text":"<p>Agents MAY support JSON-RPC 2.0 transport. If implemented, it MUST conform to these requirements:</p> <ul> <li>The primary data format is JSON-RPC 2.0 for all requests and responses (excluding SSE stream wrapper).</li> <li>Client requests and server responses MUST adhere to the JSON-RPC 2.0 specification.</li> <li>The <code>Content-Type</code> header for HTTP requests and responses containing JSON-RPC payloads MUST be <code>application/json</code>.</li> <li>Method names follow the pattern <code>{category}/{action}</code> (e.g., <code>\"message/send\"</code>, <code>\"tasks/get\"</code>).</li> </ul>"},{"location":"specification/#322-grpc-transport","title":"3.2.2. gRPC Transport","text":"<p>Agents MAY support gRPC transport. If implemented, it MUST conform to these requirements:</p> <ul> <li>Protocol Definition: MUST use the normative Protocol Buffers definition in <code>specification/grpc/a2a.proto</code>.</li> <li>Message Serialization: MUST use Protocol Buffers version 3 for message serialization.</li> <li>Service Definition: MUST implement the <code>A2AService</code> gRPC service as defined in the proto file.</li> <li>Method Coverage: MUST provide all methods with functionally equivalent behavior to other supported transports.</li> <li>Field Mapping: MUST use the <code>json_name</code> annotations for HTTP/JSON transcoding compatibility.</li> <li>Error Handling: MUST map A2A error codes to appropriate gRPC status codes as defined in the proto annotations.</li> <li>Transport Security: MUST support TLS encryption (gRPC over HTTP/2 with TLS).</li> </ul>"},{"location":"specification/#323-httpjsonrest-transport","title":"3.2.3. HTTP+JSON/REST Transport","text":"<p>Agents MAY support REST-style HTTP+JSON transport. If implemented, it MUST conform to these requirements:</p> <ul> <li>HTTP Methods: MUST use appropriate HTTP verbs (GET for queries, POST for actions, PUT for updates, DELETE for removal).</li> <li>URL Patterns: MUST follow the URL patterns documented in each method section (e.g., <code>/v1/message:send</code>, <code>/v1/tasks/{id}</code>).</li> <li>Content-Type: MUST use <code>application/json</code> for request and response bodies.</li> <li>HTTP Status Codes: MUST use appropriate HTTP status codes (200, 400, 401, 403, 404, 500, etc.) that correspond to A2A error types.</li> <li>Request/Response Format: MUST use JSON objects that are structurally equivalent to the core A2A data structures.</li> <li>Method Coverage: MUST provide all methods with functionally equivalent behavior to other supported transports.</li> <li>Error Format: MUST return error responses in a consistent JSON format that maps to A2A error types.</li> </ul>"},{"location":"specification/#324-transport-extensions","title":"3.2.4. Transport Extensions","text":"<p>Additional transport protocols MAY be defined as extensions to the core A2A specification. Such extensions:</p> <ul> <li>MUST maintain functional equivalence with the core transports</li> <li>MUST use clear namespace identifiers to avoid conflicts</li> <li>MUST be clearly documented and specified</li> <li>SHOULD provide migration paths from core transports</li> </ul>"},{"location":"specification/#33-streaming-transport-server-sent-events","title":"3.3. Streaming Transport (Server-Sent Events)","text":"<p>Streaming capabilities are transport-specific:</p>"},{"location":"specification/#331-json-rpc-20-streaming","title":"3.3.1. JSON-RPC 2.0 Streaming","text":"<p>When streaming is used for methods like <code>message/stream</code> or <code>tasks/resubscribe</code>:</p> <ul> <li>The server responds with an HTTP <code>200 OK</code> status and a <code>Content-Type</code> header of <code>text/event-stream</code>.</li> <li>The body of this HTTP response contains a stream of Server-Sent Events (SSE) as defined by the W3C.</li> <li>Each SSE <code>data</code> field contains a complete JSON-RPC 2.0 Response object (specifically, a <code>SendStreamingMessageResponse</code>).</li> </ul>"},{"location":"specification/#332-grpc-streaming","title":"3.3.2. gRPC Streaming","text":"<p>gRPC transport uses server streaming RPCs for streaming operations as defined in the Protocol Buffers specification.</p>"},{"location":"specification/#333-httpjsonrest-streaming","title":"3.3.3. HTTP+JSON/REST Streaming","text":"<p>If REST transport is supported it MUST implement streaming using Server-Sent Events similar to JSON-RPC.</p>"},{"location":"specification/#34-transport-compliance-and-interoperability","title":"3.4. Transport Compliance and Interoperability","text":""},{"location":"specification/#341-functional-equivalence-requirements","title":"3.4.1. Functional Equivalence Requirements","text":"<p>When an agent supports multiple transports, all supported transports MUST:</p> <ul> <li>Identical Functionality: Provide the same set of operations and capabilities.</li> <li>Consistent Behavior: Return semantically equivalent results for the same requests.</li> <li>Same Error Handling: Map errors consistently across transports using the error codes defined in Section 8.</li> <li>Equivalent Authentication: Support the same authentication schemes declared in the <code>AgentCard</code>.</li> </ul>"},{"location":"specification/#342-transport-selection-and-negotiation","title":"3.4.2. Transport Selection and Negotiation","text":"<ul> <li>Agent Declaration: Agents MUST declare all supported transports in their <code>AgentCard</code> using the <code>preferredTransport</code> and <code>additionalInterfaces</code> fields.</li> <li>Client Choice: Clients MAY choose any transport declared by the agent.</li> <li>No Transport Negotiation: A2A does not define a dynamic transport negotiation protocol. Clients select a transport based on the static <code>AgentCard</code> information.</li> <li>Fallback Behavior: Clients SHOULD implement fallback logic to try alternative transports if their preferred transport fails. The specific fallback strategy is implementation-dependent.</li> </ul>"},{"location":"specification/#343-transport-specific-extensions","title":"3.4.3. Transport-Specific Extensions","text":"<p>Transports MAY provide transport-specific optimizations or extensions that do not compromise functional equivalence:</p> <ul> <li>gRPC: May leverage gRPC-specific features like bidirectional streaming, metadata, or custom status codes.</li> <li>REST: May provide additional HTTP caching headers or support HTTP conditional requests.</li> <li>JSON-RPC: May include additional fields in the JSON-RPC request/response objects that do not conflict with the core specification.</li> </ul> <p>Such extensions MUST be backward-compatible and MUST NOT break interoperability with clients that do not support the extensions.</p>"},{"location":"specification/#35-method-mapping-and-naming-conventions","title":"3.5. Method Mapping and Naming Conventions","text":"<p>To ensure consistency and predictability across different transports, A2A defines normative method mapping rules.</p>"},{"location":"specification/#351-json-rpc-method-naming","title":"3.5.1. JSON-RPC Method Naming","text":"<p>JSON-RPC methods MUST follow the pattern: <code>{category}/{action}</code> where:</p> <ul> <li><code>category</code> represents the resource type (e.g., \"message\", \"tasks\", \"agent\")</li> <li><code>action</code> represents the operation (e.g., \"send\", \"get\", \"cancel\")</li> <li>Nested actions use forward slashes (e.g., \"tasks/pushNotificationConfig/set\")</li> </ul>"},{"location":"specification/#352-grpc-method-naming","title":"3.5.2. gRPC Method Naming","text":"<p>gRPC methods MUST follow Protocol Buffers service conventions using PascalCase:</p> <ul> <li>Convert JSON-RPC category/action to PascalCase compound words</li> <li>Use standard gRPC method prefixes (Get, Set, List, Create, Delete, Cancel)</li> </ul>"},{"location":"specification/#353-httpjsonrest-method-naming","title":"3.5.3. HTTP+JSON/REST Method Naming","text":"<p>REST endpoints MUST follow RESTful URL patterns with appropriate HTTP verbs:</p> <ul> <li>Use resource-based URLs: <code>/v1/{resource}[/{id}][:{action}]</code></li> <li>Use standard HTTP methods aligned with REST semantics</li> <li>Use colon notation for non-CRUD actions</li> </ul>"},{"location":"specification/#354-method-mapping-compliance","title":"3.5.4. Method Mapping Compliance","text":"<p>When implementing multiple transports, agents MUST:</p> <ul> <li>Use standard mappings: Follow the method mappings defined in sections 3.5.2 and 3.5.3.</li> <li>Maintain functional equivalence: Each transport-specific method MUST provide identical functionality across all supported transports.</li> <li>Consistent parameters: Use equivalent parameter structures across transports (accounting for transport-specific serialization differences).</li> <li>Equivalent responses: Return semantically equivalent responses across all transports for the same operation.</li> </ul>"},{"location":"specification/#355-extension-method-naming","title":"3.5.5. Extension Method Naming","text":"<p>For custom or extension methods not defined in the core A2A specification:</p> <ul> <li>JSON-RPC: Follow the <code>{category}/{action}</code> pattern with a clear namespace (e.g., <code>myorg.extension/action</code>)</li> <li>gRPC: Use appropriate service and method names following Protocol Buffers conventions</li> <li>REST: Use clear resource-based URLs with appropriate HTTP methods</li> </ul> <p>Extension methods MUST be clearly documented and MUST NOT conflict with core A2A method names or semantics.</p>"},{"location":"specification/#356-method-mapping-reference-table","title":"3.5.6. Method Mapping Reference Table","text":"<p>For quick reference, the following table summarizes the method mappings across all transports:</p> JSON-RPC Method gRPC Method REST Endpoint Description <code>message/send</code> <code>SendMessage</code> <code>POST /v1/message:send</code> Send message to agent <code>message/stream</code> <code>SendStreamingMessage</code> <code>POST /v1/message:stream</code> Send message with streaming <code>tasks/get</code> <code>GetTask</code> <code>GET /v1/tasks/{id}</code> Get task status <code>tasks/list</code> <code>ListTask</code> <code>GET /v1/tasks</code> List tasks (gRPC/REST only) <code>tasks/cancel</code> <code>CancelTask</code> <code>POST /v1/tasks/{id}:cancel</code> Cancel task <code>tasks/resubscribe</code> <code>TaskSubscription</code> <code>POST /v1/tasks/{id}:subscribe</code> Resume task streaming <code>tasks/pushNotificationConfig/set</code> <code>CreateTaskPushNotification</code> <code>POST /v1/tasks/{id}/pushNotificationConfigs</code> Set push notification config <code>tasks/pushNotificationConfig/get</code> <code>GetTaskPushNotification</code> <code>GET /v1/tasks/{id}/pushNotificationConfigs/{configId}</code> Get push notification config <code>tasks/pushNotificationConfig/list</code> <code>ListTaskPushNotification</code> <code>GET /v1/tasks/{id}/pushNotificationConfigs</code> List push notification configs <code>tasks/pushNotificationConfig/delete</code> <code>DeleteTaskPushNotification</code> <code>DELETE /v1/tasks/{id}/pushNotificationConfigs/{configId}</code> Delete push notification config <code>agent/getAuthenticatedExtendedCard</code> <code>GetAgentCard</code> <code>GET /v1/card</code> Get authenticated agent card"},{"location":"specification/#4-authentication-and-authorization","title":"4. Authentication and Authorization","text":"<p>A2A treats agents as standard enterprise applications, relying on established web security practices. Identity information is not transmitted within A2A JSON-RPC payloads; it is handled at the HTTP transport layer.</p> <p>For a comprehensive guide on enterprise security aspects, see Enterprise-Ready Features.</p>"},{"location":"specification/#41-transport-security","title":"4.1. Transport Security","text":"<p>As stated in section 3.1, production deployments MUST use HTTPS. Implementations SHOULD use modern TLS configurations (TLS 1.3+ recommended) with strong cipher suites.</p>"},{"location":"specification/#42-server-identity-verification","title":"4.2. Server Identity Verification","text":"<p>A2A Clients SHOULD verify the A2A Server's identity by validating its TLS certificate against trusted certificate authorities (CAs) during the TLS handshake.</p>"},{"location":"specification/#43-clientuser-identity-authentication-process","title":"4.3. Client/User Identity &amp; Authentication Process","text":"<ol> <li>Discovery of Requirements: The client discovers the server's required authentication schemes via the <code>authentication</code> field in the <code>AgentCard</code>. Scheme names often align with OpenAPI Authentication methods (e.g., \"Bearer\" for OAuth 2.0 tokens, \"Basic\" for Basic Auth, \"ApiKey\" for API keys).</li> <li>Credential Acquisition (Out-of-Band): The client obtains the necessary credentials (e.g., API keys, OAuth tokens, JWTs) through an out-of-band process specific to the required authentication scheme and the identity provider. This process is outside the scope of the A2A protocol itself.</li> <li>Credential Transmission: The client includes these credentials in the appropriate HTTP headers (e.g., <code>Authorization: Bearer &lt;token&gt;</code>, <code>X-API-Key: &lt;value&gt;</code>) of every A2A request sent to the server.</li> </ol>"},{"location":"specification/#44-server-responsibilities-for-authentication","title":"4.4. Server Responsibilities for Authentication","text":"<p>The A2A Server:</p> <ul> <li>MUST authenticate every incoming request based on the provided HTTP credentials and its declared authentication requirements from its Agent Card.</li> <li>SHOULD use standard HTTP status codes like <code>401 Unauthorized</code> or <code>403 Forbidden</code> for authentication challenges or rejections.</li> <li>SHOULD include relevant HTTP headers (e.g., <code>WWW-Authenticate</code>) with <code>401 Unauthorized</code> responses to indicate the required authentication scheme(s), guiding the client.</li> </ul>"},{"location":"specification/#45-in-task-authentication-secondary-credentials","title":"4.5. In-Task Authentication (Secondary Credentials)","text":"<p>If an agent, during the execution of a task, requires additional credentials for a different system or resource (e.g., to access a specific tool on behalf of the user that requires its own auth):</p> <ol> <li>It SHOULD transition the A2A task to the <code>auth-required</code> state (see <code>TaskState</code>).</li> <li>The accompanying <code>TaskStatus.message</code> (often a <code>DataPart</code>) SHOULD provide details about the required secondary authentication, potentially using an <code>PushNotificationAuthenticationInfo</code>-like structure to describe the need.</li> <li>The A2A Client then obtains these new credentials out-of-band and provides them in a subsequent <code>message/send</code> or <code>message/stream</code> request. How these credentials are used (e.g., passed as data within the A2A message if the agent is proxying, or used by the client to interact directly with the secondary system) depends on the specific scenario.</li> </ol>"},{"location":"specification/#46-authorization","title":"4.6. Authorization","text":"<p>Once a client is authenticated, the A2A Server is responsible for authorizing the request based on the authenticated client/user identity and its own policies. Authorization logic is implementation-specific and MAY be enforced based on:</p> <ul> <li>The specific skills requested (e.g., as identified by <code>AgentSkill.id</code> from the Agent Card).</li> <li>The actions attempted within the task.</li> <li>Data access policies relevant to the resources the agent manages.</li> <li>OAuth scopes associated with the presented token, if applicable.</li> </ul> <p>Servers should implement the principle of least privilege.</p>"},{"location":"specification/#5-agent-discovery-the-agent-card","title":"5. Agent Discovery: The Agent Card","text":""},{"location":"specification/#51-purpose","title":"5.1. Purpose","text":"<p>A2A Servers MUST make an Agent Card available. The Agent Card is a JSON document that describes the server's identity, capabilities, skills, service endpoint URL, and how clients should authenticate and interact with it. Clients use this information for discovering suitable agents and for configuring their interactions.</p> <p>For more on discovery strategies, see the Agent Discovery guide.</p>"},{"location":"specification/#52-discovery-mechanisms","title":"5.2. Discovery Mechanisms","text":"<p>Clients can find Agent Cards through various methods, including but not limited to:</p> <ul> <li>Well-Known URI: Accessing a predefined path on the agent's domain (see Section 5.3).</li> <li>Registries/Catalogs: Querying curated catalogs or registries of agents (which might be enterprise-specific, public, or domain-specific).</li> <li>Direct Configuration: Clients may be pre-configured with the Agent Card URL or the card content itself.</li> </ul>"},{"location":"specification/#53-recommended-location","title":"5.3. Recommended Location","text":"<p>If using the well-known URI strategy, the recommended location for an agent's Agent Card is: <code>https://{server_domain}/.well-known/agent-card.json</code> This follows the principles of RFC 8615 for well-known URIs.</p>"},{"location":"specification/#54-security-of-agent-cards","title":"5.4. Security of Agent Cards","text":"<p>Agent Cards themselves might contain information that is considered sensitive.</p> <ul> <li>If an Agent Card contains sensitive information, the endpoint serving the card MUST be protected by appropriate access controls (e.g., mTLS, network restrictions, authentication required to fetch the card).</li> <li>It is generally NOT RECOMMENDED to include plaintext secrets (like static API keys) directly in an Agent Card. Prefer authentication schemes where clients obtain dynamic credentials out-of-band.</li> </ul>"},{"location":"specification/#55-agentcard-object-structure","title":"5.5. <code>AgentCard</code> Object Structure","text":"<pre><code>/**\n * The AgentCard is a self-describing manifest for an agent. It provides essential\n * metadata including the agent's identity, capabilities, skills, supported\n * communication methods, and security requirements.\n */\nexport interface AgentCard {\n  /**\n   * The version of the A2A protocol this agent supports.\n   * @default \"0.3.0\"\n   */\n  protocolVersion: string;\n  /**\n   * A human-readable name for the agent.\n   *\n   * @TJS-examples [\"Recipe Agent\"]\n   */\n  name: string;\n  /**\n   * A human-readable description of the agent, assisting users and other agents\n   * in understanding its purpose.\n   *\n   * @TJS-examples [\"Agent that helps users with recipes and cooking.\"]\n   */\n  description: string;\n  /**\n   * The preferred endpoint URL for interacting with the agent.\n   * This URL MUST support the transport specified by 'preferredTransport'.\n   *\n   * @TJS-examples [\"https://api.example.com/a2a/v1\"]\n   */\n  url: string;\n  /**\n   * The transport protocol for the preferred endpoint (the main 'url' field).\n   * If not specified, defaults to 'JSONRPC'.\n   *\n   * IMPORTANT: The transport specified here MUST be available at the main 'url'.\n   * This creates a binding between the main URL and its supported transport protocol.\n   * Clients should prefer this transport and URL combination when both are supported.\n   *\n   * @default \"JSONRPC\"\n   * @TJS-examples [\"JSONRPC\", \"GRPC\", \"HTTP+JSON\"]\n   */\n  preferredTransport?: TransportProtocol | string;\n  /**\n   * A list of additional supported interfaces (transport and URL combinations).\n   * This allows agents to expose multiple transports, potentially at different URLs.\n   *\n   * Best practices:\n   * - SHOULD include all supported transports for completeness\n   * - SHOULD include an entry matching the main 'url' and 'preferredTransport'\n   * - MAY reuse URLs if multiple transports are available at the same endpoint\n   * - MUST accurately declare the transport available at each URL\n   *\n   * Clients can select any interface from this list based on their transport capabilities\n   * and preferences. This enables transport negotiation and fallback scenarios.\n   */\n  additionalInterfaces?: AgentInterface[];\n  /** An optional URL to an icon for the agent. */\n  iconUrl?: string;\n  /** Information about the agent's service provider. */\n  provider?: AgentProvider;\n  /**\n   * The agent's own version number. The format is defined by the provider.\n   *\n   * @TJS-examples [\"1.0.0\"]\n   */\n  version: string;\n  /** An optional URL to the agent's documentation. */\n  documentationUrl?: string;\n  /** A declaration of optional capabilities supported by the agent. */\n  capabilities: AgentCapabilities;\n  /**\n   * A declaration of the security schemes available to authorize requests. The key is the\n   * scheme name. Follows the OpenAPI 3.0 Security Scheme Object.\n   */\n  securitySchemes?: { [scheme: string]: SecurityScheme };\n  /**\n   * A list of security requirement objects that apply to all agent interactions. Each object\n   * lists security schemes that can be used. Follows the OpenAPI 3.0 Security Requirement Object.\n   * This list can be seen as an OR of ANDs. Each object in the list describes one possible\n   * set of security requirements that must be present on a request. This allows specifying,\n   * for example, \"callers must either use OAuth OR an API Key AND mTLS.\"\n   *\n   * @TJS-examples [[{\"oauth\": [\"read\"]}, {\"api-key\": [], \"mtls\": []}]]\n   */\n  security?: { [scheme: string]: string[] }[];\n  /**\n   * Default set of supported input MIME types for all skills, which can be\n   * overridden on a per-skill basis.\n   */\n  defaultInputModes: string[];\n  /**\n   * Default set of supported output MIME types for all skills, which can be\n   * overridden on a per-skill basis.\n   */\n  defaultOutputModes: string[];\n  /** The set of skills, or distinct capabilities, that the agent can perform. */\n  skills: AgentSkill[];\n  /**\n   * If true, the agent can provide an extended agent card with additional details\n   * to authenticated users. Defaults to false.\n   */\n  supportsAuthenticatedExtendedCard?: boolean;\n  /** JSON Web Signatures computed for this AgentCard. */\n  signatures?: AgentCardSignature[];\n}\n</code></pre>"},{"location":"specification/#551-agentprovider-object","title":"5.5.1. <code>AgentProvider</code> Object","text":"<p>Information about the organization or entity providing the agent.</p> <pre><code>/**\n * Represents the service provider of an agent.\n *\n * @TJS-examples [{ \"organization\": \"Google\", \"url\": \"https://ai.google.dev\" }]\n */\nexport interface AgentProvider {\n  /** The name of the agent provider's organization. */\n  organization: string;\n  /** A URL for the agent provider's website or relevant documentation. */\n  url: string;\n}\n</code></pre>"},{"location":"specification/#552-agentcapabilities-object","title":"5.5.2. <code>AgentCapabilities</code> Object","text":"<p>Specifies optional A2A protocol features supported by the agent.</p> <pre><code>/**\n * Defines optional capabilities supported by an agent.\n */\nexport interface AgentCapabilities {\n  /** Indicates if the agent supports Server-Sent Events (SSE) for streaming responses. */\n  streaming?: boolean;\n  /** Indicates if the agent supports sending push notifications for asynchronous task updates. */\n  pushNotifications?: boolean;\n  /** Indicates if the agent provides a history of state transitions for a task. */\n  stateTransitionHistory?: boolean;\n  /** A list of protocol extensions supported by the agent. */\n  extensions?: AgentExtension[];\n}\n</code></pre>"},{"location":"specification/#5521-agentextension-object","title":"5.5.2.1. <code>AgentExtension</code> Object","text":"<p>Specifies an extension to the A2A protocol supported by the agent.</p> <pre><code>/**\n * A declaration of a protocol extension supported by an Agent.\n *\n * @TJS-examples [{\"uri\": \"https://developers.google.com/identity/protocols/oauth2\", \"description\": \"Google OAuth 2.0 authentication\", \"required\": false}]\n */\nexport interface AgentExtension {\n  /** The unique URI identifying the extension. */\n  uri: string;\n  /** A human-readable description of how this agent uses the extension. */\n  description?: string;\n  /**\n   * If true, the client must understand and comply with the extension's requirements\n   * to interact with the agent.\n   */\n  required?: boolean;\n  /** Optional, extension-specific configuration parameters. */\n  params?: { [key: string]: any };\n}\n</code></pre>"},{"location":"specification/#553-securityscheme-object","title":"5.5.3. <code>SecurityScheme</code> Object","text":"<p>Describes the authentication requirements for accessing the agent's <code>url</code> endpoint. Refer Sample Agent Card for an example.</p> <pre><code>/**\n * Defines a security scheme that can be used to secure an agent's endpoints.\n * This is a discriminated union type based on the OpenAPI 3.0 Security Scheme Object.\n *\n * @see {@link https://swagger.io/specification/#security-scheme-object}\n */\nexport type SecurityScheme =\n  | APIKeySecurityScheme\n  | HTTPAuthSecurityScheme\n  | OAuth2SecurityScheme\n  | OpenIdConnectSecurityScheme\n  | MutualTLSSecurityScheme;\n</code></pre>"},{"location":"specification/#554-agentskill-object","title":"5.5.4. <code>AgentSkill</code> Object","text":"<p>Describes a specific capability, function, or area of expertise the agent can perform or address.</p> <pre><code>/**\n * Represents a distinct capability or function that an agent can perform.\n */\nexport interface AgentSkill {\n  /** A unique identifier for the agent's skill. */\n  id: string;\n  /** A human-readable name for the skill. */\n  name: string;\n  /**\n   * A detailed description of the skill, intended to help clients or users\n   * understand its purpose and functionality.\n   */\n  description: string;\n  /**\n   * A set of keywords describing the skill's capabilities.\n   *\n   * @TJS-examples [[\"cooking\", \"customer support\", \"billing\"]]\n   */\n  tags: string[];\n  /**\n   * Example prompts or scenarios that this skill can handle. Provides a hint to\n   * the client on how to use the skill.\n   *\n   * @TJS-examples [[\"I need a recipe for bread\"]]\n   */\n  examples?: string[];\n  /**\n   * The set of supported input MIME types for this skill, overriding the agent's defaults.\n   */\n  inputModes?: string[];\n  /**\n   * The set of supported output MIME types for this skill, overriding the agent's defaults.\n   */\n  outputModes?: string[];\n  /**\n   * Security schemes necessary for the agent to leverage this skill.\n   * As in the overall AgentCard.security, this list represents a logical OR of security\n   * requirement objects. Each object is a set of security schemes that must be used together\n   * (a logical AND).\n   *\n   * @TJS-examples [[{\"google\": [\"oidc\"]}]]\n   */\n  security?: { [scheme: string]: string[] }[];\n}\n</code></pre>"},{"location":"specification/#555-agentinterface-object","title":"5.5.5. <code>AgentInterface</code> Object","text":"<p>Provides a declaration of a combination of the target URL and the supported transport to interact with the agent. This enables agents to expose the same functionality through multiple transport protocols.</p> <pre><code>/**\n * Supported A2A transport protocols.\n */\nexport enum TransportProtocol {\n  JSONRPC = \"JSONRPC\", // JSON-RPC 2.0 over HTTP (mandatory)\n  GRPC = \"GRPC\", // gRPC over HTTP/2 (optional)\n  HTTP_JSON = \"HTTP+JSON\", // REST-style HTTP with JSON (optional)\n}\n</code></pre> <pre><code>/**\n * Declares a combination of a target URL and a transport protocol for interacting with the agent.\n * This allows agents to expose the same functionality over multiple transport mechanisms.\n */\nexport interface AgentInterface {\n  /**\n   * The URL where this interface is available. Must be a valid absolute HTTPS URL in production.\n   * @TJS-examples [\"https://api.example.com/a2a/v1\", \"https://grpc.example.com/a2a\", \"https://rest.example.com/v1\"]\n   */\n  url: string;\n  /**\n   * The transport protocol supported at this URL.\n   *\n   * @TJS-examples [\"JSONRPC\", \"GRPC\", \"HTTP+JSON\"]\n   */\n  transport: TransportProtocol | string;\n}\n</code></pre> <p>The <code>transport</code> field SHOULD use one of the core A2A transport protocol values:</p> <ul> <li><code>\"JSONRPC\"</code>: JSON-RPC 2.0 over HTTP</li> <li><code>\"GRPC\"</code>: gRPC over HTTP/2</li> <li><code>\"HTTP+JSON\"</code>: REST-style HTTP with JSON</li> </ul> <p>Additional transport values MAY be used for future extensions, but such extensions MUST not conflict with core A2A protocol functionality.</p>"},{"location":"specification/#556-agentcardsignature-object","title":"5.5.6. <code>AgentCardSignature</code> Object","text":"<p>Represents a JSON Web Signature (JWS) used to verify the integrity of the AgentCard.</p> <pre><code>/**\n * AgentCardSignature represents a JWS signature of an AgentCard.\n * This follows the JSON format of an RFC 7515 JSON Web Signature (JWS).\n */\nexport interface AgentCardSignature {\n  /**\n   * The protected JWS header for the signature. This is a Base64url-encoded\n   * JSON object, as per RFC 7515.\n   */\n  protected: string;\n  /** The computed signature, Base64url-encoded. */\n  signature: string;\n  /** The unprotected JWS header values. */\n  header?: { [key: string]: any };\n}\n</code></pre>"},{"location":"specification/#56-transport-declaration-and-url-relationships","title":"5.6. Transport Declaration and URL Relationships","text":"<p>The AgentCard MUST properly declare the relationship between URLs and transport protocols:</p>"},{"location":"specification/#561-main-url-and-preferred-transport","title":"5.6.1. Main URL and Preferred Transport","text":"<ul> <li>Main URL requirement: The <code>url</code> field MUST specify the primary endpoint for the agent.</li> <li>Transport correspondence: The transport protocol available at the main <code>url</code> MUST match the <code>preferredTransport</code> field.</li> <li>Required declaration: The <code>preferredTransport</code> field is REQUIRED and MUST be present in every <code>AgentCard</code>.</li> <li>Transport availability: The main <code>url</code> MUST support the transport protocol declared in <code>preferredTransport</code>.</li> </ul>"},{"location":"specification/#562-additional-interfaces","title":"5.6.2. Additional Interfaces","text":"<ul> <li>URL uniqueness: Each <code>AgentInterface</code> in <code>additionalInterfaces</code> SHOULD specify a distinct URL for clarity, but MAY reuse URLs if multiple transport protocols are available at the same endpoint.</li> <li>Transport declaration: Each <code>AgentInterface</code> MUST accurately declare the transport protocol available at its specified URL.</li> <li>Completeness: The <code>additionalInterfaces</code> array SHOULD include all supported transports, including the main URL's transport for completeness.</li> </ul>"},{"location":"specification/#563-client-transport-selection-rules","title":"5.6.3. Client Transport Selection Rules","text":"<p>Clients MUST follow these rules when selecting a transport:</p> <ol> <li>Parse transport declarations: Extract available transports from both the main <code>url</code>/<code>preferredTransport</code> combination and all <code>additionalInterfaces</code>.</li> <li>Prefer declared preference: If the client supports the <code>preferredTransport</code>, it SHOULD use the main <code>url</code>.</li> <li>Fallback selection: If the preferred transport is not supported by the client, it MAY select any supported transport from <code>additionalInterfaces</code>.</li> <li>Graceful degradation: Clients SHOULD implement fallback logic to try alternative transports if their first choice fails.</li> <li>URL-transport matching: Clients MUST use the correct URL for the selected transport protocol as declared in the AgentCard.</li> </ol>"},{"location":"specification/#564-validation-requirements","title":"5.6.4. Validation Requirements","text":"<p>Agent Cards MUST satisfy these validation requirements:</p> <ul> <li>Transport consistency: The <code>preferredTransport</code> value MUST be present and MUST be available at the main <code>url</code>.</li> <li>Interface completeness: If <code>additionalInterfaces</code> is provided, it SHOULD include an entry corresponding to the main <code>url</code> and <code>preferredTransport</code>.</li> <li>No conflicts: The same URL MUST NOT declare conflicting transport protocols across different interface declarations.</li> <li>Minimum transport requirement: The agent MUST declare at least one supported transport protocol through either the main <code>url</code>/<code>preferredTransport</code> combination or <code>additionalInterfaces</code>.</li> </ul>"},{"location":"specification/#57-sample-agent-card","title":"5.7. Sample Agent Card","text":"<pre><code>{\n  \"protocolVersion\": \"0.2.9\",\n  \"name\": \"GeoSpatial Route Planner Agent\",\n  \"description\": \"Provides advanced route planning, traffic analysis, and custom map generation services. This agent can calculate optimal routes, estimate travel times considering real-time traffic, and create personalized maps with points of interest.\",\n  \"url\": \"https://georoute-agent.example.com/a2a/v1\",\n  \"preferredTransport\": \"JSONRPC\",\n  \"additionalInterfaces\" : [\n    {\"url\": \"https://georoute-agent.example.com/a2a/v1\", \"transport\": \"JSONRPC\"},\n    {\"url\": \"https://georoute-agent.example.com/a2a/grpc\", \"transport\": \"GRPC\"},\n    {\"url\": \"https://georoute-agent.example.com/a2a/json\", \"transport\": \"HTTP+JSON\"}\n  ],\n  \"provider\": {\n    \"organization\": \"Example Geo Services Inc.\",\n    \"url\": \"https://www.examplegeoservices.com\"\n  },\n  \"iconUrl\": \"https://georoute-agent.example.com/icon.png\",\n  \"version\": \"1.2.0\",\n  \"documentationUrl\": \"https://docs.examplegeoservices.com/georoute-agent/api\",\n  \"capabilities\": {\n    \"streaming\": true,\n    \"pushNotifications\": true,\n    \"stateTransitionHistory\": false\n  },\n  \"securitySchemes\": {\n    \"google\": {\n      \"type\": \"openIdConnect\",\n      \"openIdConnectUrl\": \"https://accounts.google.com/.well-known/openid-configuration\"\n    }\n  },\n  \"security\": [{ \"google\": [\"openid\", \"profile\", \"email\"] }],\n  \"defaultInputModes\": [\"application/json\", \"text/plain\"],\n  \"defaultOutputModes\": [\"application/json\", \"image/png\"],\n  \"skills\": [\n    {\n      \"id\": \"route-optimizer-traffic\",\n      \"name\": \"Traffic-Aware Route Optimizer\",\n      \"description\": \"Calculates the optimal driving route between two or more locations, taking into account real-time traffic conditions, road closures, and user preferences (e.g., avoid tolls, prefer highways).\",\n      \"tags\": [\"maps\", \"routing\", \"navigation\", \"directions\", \"traffic\"],\n      \"examples\": [\n        \"Plan a route from '1600 Amphitheatre Parkway, Mountain View, CA' to 'San Francisco International Airport' avoiding tolls.\",\n        \"{\\\"origin\\\": {\\\"lat\\\": 37.422, \\\"lng\\\": -122.084}, \\\"destination\\\": {\\\"lat\\\": 37.7749, \\\"lng\\\": -122.4194}, \\\"preferences\\\": [\\\"avoid_ferries\\\"]}\"\n      ],\n      \"inputModes\": [\"application/json\", \"text/plain\"],\n      \"outputModes\": [\n        \"application/json\",\n        \"application/vnd.geo+json\",\n        \"text/html\"\n      ]\n    },\n    {\n      \"id\": \"custom-map-generator\",\n      \"name\": \"Personalized Map Generator\",\n      \"description\": \"Creates custom map images or interactive map views based on user-defined points of interest, routes, and style preferences. Can overlay data layers.\",\n      \"tags\": [\"maps\", \"customization\", \"visualization\", \"cartography\"],\n      \"examples\": [\n        \"Generate a map of my upcoming road trip with all planned stops highlighted.\",\n        \"Show me a map visualizing all coffee shops within a 1-mile radius of my current location.\"\n      ],\n      \"inputModes\": [\"application/json\"],\n      \"outputModes\": [\n        \"image/png\",\n        \"image/jpeg\",\n        \"application/json\",\n        \"text/html\"\n      ]\n    }\n  ],\n  \"supportsAuthenticatedExtendedCard\": true,\n  \"signatures\": [\n    {\n      \"protected\": \"eyJhbGciOiJFUzI1NiIsInR5cCI6IkpPU0UiLCJraWQiOiJrZXktMSIsImprdSI6Imh0dHBzOi8vZXhhbXBsZS5jb20vYWdlbnQvandrcy5qc29uIn0\",\n      \"signature\": \"QFdkNLNszlGj3z3u0YQGt_T9LixY3qtdQpZmsTdDHDe3fXV9y9-B3m2-XgCpzuhiLt8E0tV6HXoZKHv4GtHgKQ\"\n    }\n  ]\n}\n</code></pre>"},{"location":"specification/#6-protocol-data-objects","title":"6. Protocol Data Objects","text":"<p>These objects define the structure of data exchanged within the JSON-RPC methods of the A2A protocol.</p>"},{"location":"specification/#61-task-object","title":"6.1. <code>Task</code> Object","text":"<p>Represents the stateful unit of work being processed by the A2A Server for an A2A Client. A task encapsulates the entire interaction related to a specific goal or request. A task which has reached a terminal state (completed, canceled, rejected, or failed) can't be restarted. Tasks in completed state SHOULD use artifacts for returning the generated output to the clients. For more information, refer to the Life of a Task guide.</p> <pre><code>/**\n * Represents a single, stateful operation or conversation between a client and an agent.\n */\nexport interface Task {\n  /** A unique identifier for the task, generated by the server for a new task. */\n  id: string;\n  /** A server-generated identifier for maintaining context across multiple related tasks or interactions. */\n  contextId: string;\n  /** The current status of the task, including its state and a descriptive message. */\n  status: TaskStatus;\n  /** An array of messages exchanged during the task, representing the conversation history. */\n  history?: Message[];\n  /** A collection of artifacts generated by the agent during the execution of the task. */\n  artifacts?: Artifact[];\n  /** Optional metadata for extensions. The key is an extension-specific identifier. */\n  metadata?: {\n    [key: string]: any;\n  };\n  /** The type of this object, used as a discriminator. Always 'task' for a Task. */\n  readonly kind: \"task\";\n}\n</code></pre>"},{"location":"specification/#62-taskstatus-object","title":"6.2. <code>TaskStatus</code> Object","text":"<p>Represents the current state and associated context (e.g., a message from the agent) of a <code>Task</code>.</p> <pre><code>/**\n * Represents the status of a task at a specific point in time.\n */\nexport interface TaskStatus {\n  /** The current state of the task's lifecycle. */\n  state: TaskState;\n  /** An optional, human-readable message providing more details about the current status. */\n  message?: Message;\n  /**\n   * An ISO 8601 datetime string indicating when this status was recorded.\n   *\n   * @TJS-examples [\"2023-10-27T10:00:00Z\"]\n   */\n  timestamp?: string;\n}\n</code></pre>"},{"location":"specification/#63-taskstate-enum","title":"6.3. <code>TaskState</code> Enum","text":"<p>Defines the possible lifecycle states of a <code>Task</code>.</p> <pre><code>/**\n * Defines the lifecycle states of a Task.\n */\nexport enum TaskState {\n  /** The task has been submitted and is awaiting execution. */\n  Submitted = \"submitted\",\n  /** The agent is actively working on the task. */\n  Working = \"working\",\n  /** The task is paused and waiting for input from the user. */\n  InputRequired = \"input-required\",\n  /** The task has been successfully completed. */\n  Completed = \"completed\",\n  /** The task has been canceled by the user. */\n  Canceled = \"canceled\",\n  /** The task failed due to an error during execution. */\n  Failed = \"failed\",\n  /** The task was rejected by the agent and was not started. */\n  Rejected = \"rejected\",\n  /** The task requires authentication to proceed. */\n  AuthRequired = \"auth-required\",\n  /** The task is in an unknown or indeterminate state. */\n  Unknown = \"unknown\",\n}\n</code></pre>"},{"location":"specification/#64-message-object","title":"6.4. <code>Message</code> Object","text":"<p>Represents a single communication turn or a piece of contextual information between a client and an agent. Messages are used for instructions, prompts, replies, and status updates.</p> <pre><code>/**\n * Represents a single message in the conversation between a user and an agent.\n */\nexport interface Message {\n  /** Identifies the sender of the message. `user` for the client, `agent` for the service. */\n  readonly role: \"user\" | \"agent\";\n  /**\n   * An array of content parts that form the message body. A message can be\n   * composed of multiple parts of different types (e.g., text and files).\n   */\n  parts: Part[];\n  /** Optional metadata for extensions. The key is an extension-specific identifier. */\n  metadata?: {\n    [key: string]: any;\n  };\n  /** The URIs of extensions that are relevant to this message. */\n  extensions?: string[];\n  /** A list of other task IDs that this message references for additional context. */\n  referenceTaskIds?: string[];\n  /** A unique identifier for the message, typically a UUID, generated by the sender. */\n  messageId: string;\n  /** The identifier of the task this message is part of. Can be omitted for the first message of a new task. */\n  taskId?: string;\n  /** The context identifier for this message, used to group related interactions. */\n  contextId?: string;\n  /** The type of this object, used as a discriminator. Always 'message' for a Message. */\n  readonly kind: \"message\";\n}\n</code></pre>"},{"location":"specification/#65-part-union-type","title":"6.5. <code>Part</code> Union Type","text":"<p>Represents a distinct piece of content within a <code>Message</code> or <code>Artifact</code>. A <code>Part</code> is a union type representing exportable content as either <code>TextPart</code>, <code>FilePart</code>, or <code>DataPart</code>. All <code>Part</code> types also include an optional <code>metadata</code> field (<code>Record&lt;string, any&gt;</code>) for part-specific metadata.</p> <pre><code>/**\n * A discriminated union representing a part of a message or artifact, which can\n * be text, a file, or structured data.\n */\nexport type Part = TextPart | FilePart | DataPart;\n</code></pre> <pre><code>/**\n * Defines base properties common to all message or artifact parts.\n */\nexport interface PartBase {\n  /** Optional metadata associated with this part. */\n  metadata?: {\n    [key: string]: any;\n  };\n}\n</code></pre> <p>It MUST be one of the following:</p>"},{"location":"specification/#651-textpart-object","title":"6.5.1. <code>TextPart</code> Object","text":"<p>For conveying plain textual content.</p> <pre><code>/**\n * Represents a text segment within a message or artifact.\n */\nexport interface TextPart extends PartBase {\n  /** The type of this part, used as a discriminator. Always 'text'. */\n  readonly kind: \"text\";\n  /** The string content of the text part. */\n  text: string;\n}\n</code></pre>"},{"location":"specification/#652-filepart-object","title":"6.5.2. <code>FilePart</code> Object","text":"<p>For conveying file-based content.</p> <pre><code>/**\n * Represents a file segment within a message or artifact. The file content can be\n * provided either directly as bytes or as a URI.\n */\nexport interface FilePart extends PartBase {\n  /** The type of this part, used as a discriminator. Always 'file'. */\n  readonly kind: \"file\";\n  /** The file content, represented as either a URI or as base64-encoded bytes. */\n  file: FileWithBytes | FileWithUri;\n}\n</code></pre>"},{"location":"specification/#653-datapart-object","title":"6.5.3. <code>DataPart</code> Object","text":"<p>For conveying structured JSON data. Useful for forms, parameters, or any machine-readable information.</p> <pre><code>/**\n * Represents a structured data segment (e.g., JSON) within a message or artifact.\n */\nexport interface DataPart extends PartBase {\n  /** The type of this part, used as a discriminator. Always 'data'. */\n  readonly kind: \"data\";\n  /** The structured data content. */\n  data: {\n    [key: string]: any;\n  };\n}\n</code></pre>"},{"location":"specification/#66-filebase-object","title":"6.6 <code>FileBase</code> Object","text":"<p>Base entity for File Contents.</p> <pre><code>/**\n * Defines base properties for a file.\n */\nexport interface FileBase {\n  /** An optional name for the file (e.g., \"document.pdf\"). */\n  name?: string;\n  /** The MIME type of the file (e.g., \"application/pdf\"). */\n  mimeType?: string;\n}\n</code></pre>"},{"location":"specification/#661-filewithbytes-object","title":"6.6.1 <code>FileWithBytes</code> Object","text":"<p>Represents the data for a file, used within a <code>FilePart</code>.</p> <pre><code>/**\n * Represents a file with its content provided directly as a base64-encoded string.\n */\nexport interface FileWithBytes extends FileBase {\n  /** The base64-encoded content of the file. */\n  bytes: string;\n  /** The `uri` property must be absent when `bytes` is present. */\n  uri?: never;\n}\n</code></pre>"},{"location":"specification/#662-filewithuri-object","title":"6.6.2 <code>FileWithUri</code> Object","text":"<p>Represents the URI for a file, used within a <code>FilePart</code>.</p> <pre><code>/**\n * Represents a file with its content located at a specific URI.\n */\nexport interface FileWithUri extends FileBase {\n  /** A URL pointing to the file's content. */\n  uri: string;\n  /** The `bytes` property must be absent when `uri` is present. */\n  bytes?: never;\n}\n</code></pre>"},{"location":"specification/#67-artifact-object","title":"6.7. <code>Artifact</code> Object","text":"<p>Represents a tangible output generated by the agent during a task. Artifacts are the results or products of the agent's work.</p> <pre><code>/**\n * Represents a file, data structure, or other resource generated by an agent during a task.\n */\nexport interface Artifact {\n  /** A unique identifier for the artifact within the scope of the task. */\n  artifactId: string;\n  /** An optional, human-readable name for the artifact. */\n  name?: string;\n  /** An optional, human-readable description of the artifact. */\n  description?: string;\n  /** An array of content parts that make up the artifact. */\n  parts: Part[];\n  /** Optional metadata for extensions. The key is an extension-specific identifier. */\n  metadata?: {\n    [key: string]: any;\n  };\n  /** The URIs of extensions that are relevant to this artifact. */\n  extensions?: string[];\n}\n</code></pre>"},{"location":"specification/#68-pushnotificationconfig-object","title":"6.8. <code>PushNotificationConfig</code> Object","text":"<p>Configuration provided by the client to the server for sending asynchronous push notifications about task updates.</p> <pre><code>/**\n * Defines the configuration for setting up push notifications for task updates.\n */\nexport interface PushNotificationConfig {\n  /**\n   * A unique ID for the push notification configuration, set by the client\n   * to support multiple notification callbacks.\n   */\n  id?: string;\n  /** The callback URL where the agent should send push notifications. */\n  url: string;\n  /** A unique token for this task or session to validate incoming push notifications. */\n  token?: string;\n  /** Optional authentication details for the agent to use when calling the notification URL. */\n  authentication?: PushNotificationAuthenticationInfo;\n}\n</code></pre>"},{"location":"specification/#69-pushnotificationauthenticationinfo-object","title":"6.9. <code>PushNotificationAuthenticationInfo</code> Object","text":"<p>A generic structure for specifying authentication requirements, typically used within <code>PushNotificationConfig</code> to describe how the A2A Server should authenticate to the client's webhook.</p> <pre><code>/**\n * Defines authentication details for a push notification endpoint.\n */\nexport interface PushNotificationAuthenticationInfo {\n  /** A list of supported authentication schemes (e.g., 'Basic', 'Bearer'). */\n  schemes: string[];\n  /** Optional credentials required by the push notification endpoint. */\n  credentials?: string;\n}\n</code></pre>"},{"location":"specification/#610-taskpushnotificationconfig-object","title":"6.10. <code>TaskPushNotificationConfig</code> Object","text":"<p>Used as the <code>params</code> object for the <code>tasks/pushNotificationConfig/set</code> method and as the <code>result</code> object for the <code>tasks/pushNotificationConfig/get</code> method.</p> <pre><code>/**\n * A container associating a push notification configuration with a specific task.\n */\nexport interface TaskPushNotificationConfig {\n  /** The ID of the task. */\n  taskId: string;\n  /** The push notification configuration for this task. */\n  pushNotificationConfig: PushNotificationConfig;\n}\n</code></pre>"},{"location":"specification/#611-json-rpc-structures","title":"6.11. JSON-RPC Structures","text":"<p>A2A adheres to the standard JSON-RPC 2.0 structures for requests and responses.</p>"},{"location":"specification/#6111-jsonrpcrequest-object","title":"6.11.1. <code>JSONRPCRequest</code> Object","text":"<p>All A2A method calls are encapsulated in a JSON-RPC Request object.</p> <ul> <li><code>jsonrpc</code>: A String specifying the version of the JSON-RPC protocol. MUST be exactly <code>\"2.0\"</code>.</li> <li><code>method</code>: A String containing the name of the method to be invoked (e.g., <code>\"message/send\"</code>, <code>\"tasks/get\"</code>).</li> <li><code>params</code>: A Structured value that holds the parameter values to be used during the invocation of the method. This member MAY be omitted if the method expects no parameters. A2A methods typically use an <code>object</code> for <code>params</code>.</li> <li><code>id</code>: An identifier established by the Client that MUST contain a String, Number, or <code>NULL</code> value if included. If it is not included it is assumed to be a notification. The value SHOULD NOT be <code>NULL</code> for requests expecting a response, and Numbers SHOULD NOT contain fractional parts. The Server MUST reply with the same value in the Response object if included. This member is used to correlate the context between the two objects. A2A methods typically expect a response or stream, so <code>id</code> will usually be present and non-null.</li> </ul>"},{"location":"specification/#6112-jsonrpcresponse-object","title":"6.11.2. <code>JSONRPCResponse</code> Object","text":"<p>Responses from the A2A Server are encapsulated in a JSON-RPC Response object.</p> <ul> <li><code>jsonrpc</code>: A String specifying the version of the JSON-RPC protocol. MUST be exactly <code>\"2.0\"</code>.</li> <li><code>id</code>: This member is REQUIRED. It MUST be the same as the value of the <code>id</code> member in the Request Object. If there was an error in detecting the <code>id</code> in the Request object (e.g. Parse error/Invalid Request), it MUST be <code>null</code>.</li> <li>EITHER <code>result</code>: This member is REQUIRED on success. This member MUST NOT exist if there was an error invoking the method. The value of this member is determined by the method invoked on the Server.</li> <li>OR <code>error</code>: This member is REQUIRED on failure. This member MUST NOT exist if there was no error triggered during invocation. The value of this member MUST be an <code>JSONRPCError</code> object.</li> <li>The members <code>result</code> and <code>error</code> are mutually exclusive: one MUST be present, and the other MUST NOT.</li> </ul>"},{"location":"specification/#612-jsonrpcerror-object","title":"6.12. <code>JSONRPCError</code> Object","text":"<p>When a JSON-RPC call encounters an error, the Response Object will contain an <code>error</code> member with a value of this structure.</p> <pre><code>/**\n * Represents a JSON-RPC 2.0 Error object, included in an error response.\n */\nexport interface JSONRPCError {\n  /**\n   * A number that indicates the error type that occurred.\n   */\n  code: number;\n  /**\n   * A string providing a short description of the error.\n   */\n  message: string;\n  /**\n   * A primitive or structured value containing additional information about the error.\n   * This may be omitted.\n   */\n  data?: any;\n}\n</code></pre>"},{"location":"specification/#7-protocol-rpc-methods","title":"7. Protocol RPC Methods","text":"<p>All A2A RPC methods are invoked by the A2A Client by sending an HTTP POST request to the A2A Server's <code>url</code> (as specified in its <code>AgentCard</code>). The body of the HTTP POST request MUST be a <code>JSONRPCRequest</code> object, and the <code>Content-Type</code> header MUST be <code>application/json</code>.</p> <p>The A2A Server's HTTP response body MUST be a <code>JSONRPCResponse</code> object (or, for streaming methods, an SSE stream where each event's data is a <code>JSONRPCResponse</code>). The <code>Content-Type</code> for JSON-RPC responses is <code>application/json</code>. For SSE streams, it is <code>text/event-stream</code>.</p>"},{"location":"specification/#71-messagesend","title":"7.1. <code>message/send</code>","text":"<p>Sends a message to an agent to initiate a new interaction or to continue an existing one. This method is suitable for synchronous request/response interactions or when client-side polling (using <code>tasks/get</code>) is acceptable for monitoring longer-running tasks. A task which has reached a terminal state (completed, canceled, rejected, or failed) can't be restarted. Sending a message to such a task will result in an error. For more information, refer to the Life of a Task guide.</p> JSON-RPCgRPCREST <ul> <li>URL: <code>message/send</code></li> <li>HTTP Method: <code>POST</code></li> <li>Payload: <code>MessageSendParams</code></li> <li>Response: <code>Task</code> | <code>Message</code> (A message object or the current or final state of the task after processing the message).</li> </ul> <ul> <li>URL: <code>SendMessage</code></li> <li>HTTP Method: <code>POST</code></li> <li>Payload: <pre><code>message SendMessageRequest {\n  Message msg = 1;\n  SendMessageConfiguration configuration = 2;\n}\n</code></pre></li> <li>Response: <pre><code>message SendMessageResponse {\n  oneof payload {\n    Task task = 1;\n    Message msg = 2;\n  }\n}\n</code></pre></li> </ul> <ul> <li>URL: <code>/v1/message:send</code></li> <li>HTTP Method: <code>POST</code></li> <li>Payload: <pre><code>{\n  message: Message,\n  configuration?: MessageSendConfiguration,\n  metadata?: { [key: string]: any }\n}\n</code></pre></li> <li>Response: <pre><code>// Returns one of a message or a task\n{\n  message?: Message,\n  task?: Task\n}\n</code></pre></li> </ul> <p>The <code>error</code> response for all transports in case of failure is a <code>JSONRPCError</code> or equivalent.</p>"},{"location":"specification/#711-messagesendparams-object","title":"7.1.1. <code>MessageSendParams</code> Object","text":"<pre><code>/**\n * Defines the parameters for a request to send a message to an agent. This can be used\n * to create a new task, continue an existing one, or restart a task.\n */\nexport interface MessageSendParams {\n  /** The message object being sent to the agent. */\n  message: Message;\n  /** Optional configuration for the send request. */\n  configuration?: MessageSendConfiguration;\n  /** Optional metadata for extensions. */\n  metadata?: {\n    [key: string]: any;\n  };\n}\n\n/**\n * Defines configuration options for a `message/send` or `message/stream` request.\n */\nexport interface MessageSendConfiguration {\n  /** A list of output MIME types the client is prepared to accept in the response. */\n  acceptedOutputModes?: string[];\n  /** The number of most recent messages from the task's history to retrieve in the response. */\n  historyLength?: number;\n  /** Configuration for the agent to send push notifications for updates after the initial response. */\n  pushNotificationConfig?: PushNotificationConfig;\n  /** If true, the client will wait for the task to complete. The server may reject this if the task is long-running. */\n  blocking?: boolean;\n}\n</code></pre>"},{"location":"specification/#72-messagestream","title":"7.2. <code>message/stream</code>","text":"<p>Sends a message to an agent to initiate/continue a task AND subscribes the client to real-time updates for that task via Server-Sent Events (SSE). This method requires the server to have <code>AgentCard.capabilities.streaming: true</code>. Just like <code>message/send</code>, a task which has reached a terminal state (completed, canceled, rejected, or failed) can't be restarted. Sending a message to such a task will result in an error. For more information, refer to the Life of a Task guide.</p> JSON-RPCgRPCREST <ul> <li>URL: <code>message/stream</code></li> <li>HTTP Method: <code>POST</code></li> <li>Payload: <code>MessageSendParams</code> (same as <code>message/send</code>)</li> <li>Response: A stream of Server-Sent Events. Each SSE <code>data</code> field contains a <code>SendStreamingMessageResponse</code></li> </ul> <ul> <li>URL: <code>SendStreamingMessage</code></li> <li>HTTP Method: <code>POST</code></li> <li>Payload: <pre><code>message SendMessageRequest {\n  Message msg = 1;\n  SendMessageConfiguration configuration = 2;\n}\n</code></pre></li> <li>Response: <pre><code>message StreamResponse {\n  oneof payload {\n    Task task;\n    Message msg;\n    TaskStatusUpdateEvent status_update;\n    TaskArtifactUpdateEvent artifact_update;\n  }\n}\n</code></pre></li> </ul> <ul> <li>URL: <code>/v1/message:stream</code></li> <li>HTTP Method: <code>POST</code></li> <li>Payload: <pre><code>{\n  message: Message,\n  configuration?: MessageSendConfiguration,\n  metadata?: { [key: string]: any }\n}\n</code></pre></li> <li>Response: <pre><code>{\n  message?: Message\n  task?: Task\n  statusUpdate?: TaskStatusUpdateEvent\n  artifactUpdate?: TaskArtifactUpdateEvent\n}\n</code></pre></li> </ul>"},{"location":"specification/#721-sendstreamingmessageresponse-object","title":"7.2.1. <code>SendStreamingMessageResponse</code> Object","text":"<p>This is the structure of the JSON object found in the <code>data</code> field of each Server-Sent Event sent by the server for a <code>message/stream</code> request or <code>tasks/resubscribe</code> request.</p> <pre><code>/**\n * Represents a JSON-RPC response for the `message/stream` method.\n */\nexport type SendStreamingMessageResponse =\n  | SendStreamingMessageSuccessResponse\n  | JSONRPCErrorResponse;\n\n/**\n * Represents a successful JSON-RPC response for the `message/stream` method.\n * The server may send multiple response objects for a single request.\n */\nexport interface SendStreamingMessageSuccessResponse\n  extends JSONRPCSuccessResponse {\n  /** The result, which can be a Message, Task, or a streaming update event. */\n  result: Message | Task | TaskStatusUpdateEvent | TaskArtifactUpdateEvent;\n}\n</code></pre>"},{"location":"specification/#722-taskstatusupdateevent-object","title":"7.2.2. <code>TaskStatusUpdateEvent</code> Object","text":"<p>Carries information about a change in the task's status during streaming. This is one of the possible <code>result</code> types in a <code>SendStreamingMessageSuccessResponse</code>.</p> <pre><code>/**\n * An event sent by the agent to notify the client of a change in a task's status.\n * This is typically used in streaming or subscription models.\n */\nexport interface TaskStatusUpdateEvent {\n  /** The ID of the task that was updated. */\n  taskId: string;\n  /** The context ID associated with the task. */\n  contextId: string;\n  /** The type of this event, used as a discriminator. Always 'status-update'. */\n  readonly kind: \"status-update\";\n  /** The new status of the task. */\n  status: TaskStatus;\n  /** If true, this is the final event in the stream for this interaction. */\n  final: boolean;\n  /** Optional metadata for extensions. */\n  metadata?: {\n    [key: string]: any;\n  };\n}\n</code></pre>"},{"location":"specification/#723-taskartifactupdateevent-object","title":"7.2.3. <code>TaskArtifactUpdateEvent</code> Object","text":"<p>Carries a new or updated artifact (or a chunk of an artifact) generated by the task during streaming. This is one of the possible <code>result</code> types in a <code>SendTaskStreamingResponse</code>.</p> <pre><code>/**\n * An event sent by the agent to notify the client that an artifact has been\n * generated or updated. This is typically used in streaming models.\n */\nexport interface TaskArtifactUpdateEvent {\n  /** The ID of the task this artifact belongs to. */\n  taskId: string;\n  /** The context ID associated with the task. */\n  contextId: string;\n  /** The type of this event, used as a discriminator. Always 'artifact-update'. */\n  readonly kind: \"artifact-update\";\n  /** The artifact that was generated or updated. */\n  artifact: Artifact;\n  /** If true, the content of this artifact should be appended to a previously sent artifact with the same ID. */\n  append?: boolean;\n  /** If true, this is the final chunk of the artifact. */\n  lastChunk?: boolean;\n  /** Optional metadata for extensions. */\n  metadata?: {\n    [key: string]: any;\n  };\n}\n</code></pre>"},{"location":"specification/#73-tasksget","title":"7.3. <code>tasks/get</code>","text":"<p>Retrieves the current state (including status, artifacts, and optionally history) of a previously initiated task. This is typically used for polling the status of a task initiated with <code>message/send</code>, or for fetching the final state of a task after being notified via a push notification or after an SSE stream has ended.</p> JSON-RPCgRPCREST <ul> <li>URL: <code>tasks/get</code></li> <li>HTTP Method: <code>POST</code></li> <li>Payload: <code>TaskQueryParams</code></li> <li>Response: <code>Task</code></li> </ul> <ul> <li>URL: <code>GetTask</code></li> <li>HTTP Method: <code>POST</code></li> <li>Payload: <pre><code>message GetTaskRequest {\n  // name=tasks/{id}\n  string name;\n  int32 history_length;\n}\n</code></pre></li> <li>Response: <code>Task</code></li> </ul> <ul> <li>URL: <code>v1/tasks/{id}?historyLength={historyLength}</code></li> <li>HTTP Method: <code>GET</code></li> <li>Payload: None</li> <li>Response: <code>Task</code></li> </ul>"},{"location":"specification/#731-taskqueryparams-object","title":"7.3.1. <code>TaskQueryParams</code> Object","text":"<pre><code>/**\n * Defines parameters for querying a task, with an option to limit history length.\n */\nexport interface TaskQueryParams extends TaskIdParams {\n  /** The number of most recent messages from the task's history to retrieve. */\n  historyLength?: number;\n}\n</code></pre>"},{"location":"specification/#taskslist","title":"<code>tasks/list</code>","text":"JSON-RPCgRPCREST <ul> <li>N/A</li> </ul> <ul> <li>URL: <code>ListTask</code></li> <li>HTTP Method: <code>GET</code></li> <li>Payload: <pre><code>{}\n</code></pre></li> <li>Response: <code>repeated Task</code></li> </ul> <ul> <li>URL: <code>/v1/tasks</code></li> <li>HTTP Method: <code>GET</code></li> <li>Payload: <pre><code>{}\n</code></pre></li> <li>Response: <code>[Task]</code></li> </ul>"},{"location":"specification/#74-taskscancel","title":"7.4. <code>tasks/cancel</code>","text":"<p>Requests the cancellation of an ongoing task. The server will attempt to cancel the task, but success is not guaranteed (e.g., the task might have already completed or failed, or cancellation might not be supported at its current stage).</p> JSON-RPCgRPCREST <ul> <li>URL: <code>tasks/cancel</code></li> <li>HTTP Method: <code>POST</code></li> <li>Payload: <code>TaskIdParams</code></li> <li>Response: <code>Task</code></li> </ul> <ul> <li>URL: <code>CancelTask</code></li> <li>HTTP Method: <code>POST</code></li> <li>Payload: <pre><code>message CancelTaskRequest{\n  // name=tasks/{id}\n  string name;\n}\n</code></pre></li> <li>Response: <code>Task</code></li> </ul> <ul> <li>URL: <code>/v1/tasks/{id}:cancel</code></li> <li>HTTP Method: <code>POST</code></li> <li>Payload: <pre><code>{\n  name: string\n}\n</code></pre></li> <li>Response: <code>Task</code></li> </ul>"},{"location":"specification/#741-taskidparams-object-for-taskscancel-and-taskspushnotificationconfigget","title":"7.4.1. <code>TaskIdParams</code> Object (for <code>tasks/cancel</code> and <code>tasks/pushNotificationConfig/get</code>)","text":"<p>A simple object containing just the task ID and optional metadata.</p> <pre><code>/**\n * Defines parameters containing a task ID, used for simple task operations.\n */\nexport interface TaskIdParams {\n  /** The unique identifier of the task. */\n  id: string;\n  /** Optional metadata associated with the request. */\n  metadata?: {\n    [key: string]: any;\n  };\n}\n</code></pre>"},{"location":"specification/#75-taskspushnotificationconfigset","title":"7.5. <code>tasks/pushNotificationConfig/set</code>","text":"<p>Sets or updates the push notification configuration for a specified task. This allows the client to tell the server where and how to send asynchronous updates for the task. Requires the server to have <code>AgentCard.capabilities.pushNotifications: true</code>.</p> JSON-RPCgRPCREST <ul> <li>URL: <code>tasks/pushNotificationConfig/set</code></li> <li>HTTP Method: <code>POST</code></li> <li>Payload: <code>TaskPushNotificationConfig</code></li> <li>Response: <code>TaskPushNotificationConfig</code></li> </ul> <ul> <li>URL: <code>CreateTaskPushNotification</code></li> <li>HTTP Method: <code>POST</code></li> <li>Payload: <pre><code>message SetTaskPushNotificationRequest {\n  TaskPushNotificationConfig config = 1;\n}\n</code></pre></li> <li>Response: <code>TaskPushNotificationConfig</code></li> </ul> <ul> <li>URL: <code>/v1/tasks/{id}/pushNotificationConfigs</code></li> <li>HTTP Method: <code>POST</code></li> <li>Payload: <pre><code>{\n  config: TaskPushNotificationConfig\n}\n</code></pre></li> <li>Response: <code>TaskPushNotificationConfig</code></li> </ul>"},{"location":"specification/#76-taskspushnotificationconfigget","title":"7.6. <code>tasks/pushNotificationConfig/get</code>","text":"<p>Retrieves the current push notification configuration for a specified task. Requires the server to have <code>AgentCard.capabilities.pushNotifications: true</code>.</p> JSON-RPCgRPCREST <ul> <li>URL: <code>tasks/pushNotificationConfig/get</code></li> <li>HTTP Method: <code>POST</code></li> <li>Payload: <code>GetTaskPushNotificationConfigParams</code></li> <li>Response: <code>TaskPushNotificationConfig</code></li> </ul> <ul> <li>URL: <code>GetTaskPushNotification</code></li> <li>HTTP Method: <code>POST</code></li> <li>Payload: <pre><code>message TaskSubscriptionRequest {\n  // name=tasks/{id}/pushNotification/{id}\n  string name;\n}\n</code></pre></li> <li>Response: <code>TaskPushNotificationConfig</code></li> </ul> <ul> <li>URL: <code>/v1/tasks/{taskId}/pushNotificationConfigs/{configId}</code></li> <li>HTTP Method: <code>GET</code></li> <li>Payload: None</li> <li>Response: <code>TaskPushNotificationConfig</code></li> </ul> <p>Response <code>error</code> type (on failure): <code>JSONRPCError</code> (e.g., <code>PushNotificationNotSupportedError</code>, <code>TaskNotFoundError</code>).</p>"},{"location":"specification/#761-gettaskpushnotificationconfigparams-object-taskspushnotificationconfigget","title":"7.6.1. <code>GetTaskPushNotificationConfigParams</code> Object (<code>tasks/pushNotificationConfig/get</code>)","text":"<p>A object for fetching the push notification configuration for a task.</p> <pre><code>/**\n * Defines parameters for fetching a specific push notification configuration for a task.\n */\nexport interface GetTaskPushNotificationConfigParams extends TaskIdParams {\n  /** The ID of the push notification configuration to retrieve. */\n  pushNotificationConfigId?: string;\n}\n</code></pre>"},{"location":"specification/#77-taskspushnotificationconfiglist","title":"7.7. <code>tasks/pushNotificationConfig/list</code>","text":"<p>Retrieves the associated push notification configurations for a specified task. Requires the server to have <code>AgentCard.capabilities.pushNotifications: true</code>.</p> JSON-RPCgRPCREST <ul> <li>URL: <code>tasks/pushNotificationConfig/list</code></li> <li>HTTP Method: <code>POST</code></li> <li>Payload: <code>ListTaskPushNotificationConfigParams</code></li> <li>Response: <code>TaskPushNotificationConfig[]</code></li> </ul> <ul> <li>URL: <code>ListTaskPushNotification</code></li> <li>HTTP Method: <code>POST</code></li> <li>Payload: <pre><code>message ListTaskPushNotificationRequest {\n  // parent=tasks/{id}\n  string parent = 1;\n}\n</code></pre></li> <li>Response: <code>repeated TaskPushNotificationConfig</code></li> </ul> <ul> <li>URL: <code>/v1/tasks/{id}/pushNotificationConfigs</code></li> <li>HTTP Method: <code>GET</code></li> <li>Payload:: None</li> <li>Response: <code>[TaskPushNotificationConfig]</code></li> </ul>"},{"location":"specification/#771-listtaskpushnotificationconfigparams-object-taskspushnotificationconfiglist","title":"7.7.1. <code>ListTaskPushNotificationConfigParams</code> Object (<code>tasks/pushNotificationConfig/list</code>)","text":"<p>A object for fetching the push notification configurations for a task.</p> <pre><code>/**\n * Defines parameters for listing all push notification configurations associated with a task.\n */\nexport interface ListTaskPushNotificationConfigParams extends TaskIdParams {}\n</code></pre>"},{"location":"specification/#78-taskspushnotificationconfigdelete","title":"7.8. <code>tasks/pushNotificationConfig/delete</code>","text":"<p>Deletes an associated push notification configuration for a task. Requires the server to have <code>AgentCard.capabilities.pushNotifications: true</code>.</p> <ul> <li>Request <code>params</code> type: <code>DeleteTaskPushNotificationConfigParams</code></li> <li>Response <code>result</code> type (on success): [<code>null</code>]</li> <li>Response <code>error</code> type (on failure): <code>JSONRPCError</code> (e.g., <code>PushNotificationNotSupportedError</code>, <code>TaskNotFoundError</code>).</li> </ul>"},{"location":"specification/#781-deletetaskpushnotificationconfigparams-object-taskspushnotificationconfigdelete","title":"7.8.1. <code>DeleteTaskPushNotificationConfigParams</code> Object (<code>tasks/pushNotificationConfig/delete</code>)","text":"<p>A object for deleting an associated push notification configuration for a task.</p> <pre><code>/**\n * Defines parameters for deleting a specific push notification configuration for a task.\n */\nexport interface DeleteTaskPushNotificationConfigParams extends TaskIdParams {\n  /** The ID of the push notification configuration to delete. */\n  pushNotificationConfigId: string;\n}\n</code></pre>"},{"location":"specification/#79-tasksresubscribe","title":"7.9. <code>tasks/resubscribe</code>","text":"<p>Allows a client to reconnect to an SSE stream for an ongoing task after a previous connection (from <code>message/stream</code> or an earlier <code>tasks/resubscribe</code>) was interrupted. Requires the server to have <code>AgentCard.capabilities.streaming: true</code>.</p> <p>The purpose is to resume receiving subsequent updates. The server's behavior regarding events missed during the disconnection period (e.g., whether it attempts to backfill some missed events or only sends new ones from the point of resubscription) is implementation-dependent and not strictly defined by this specification.</p> JSON-RPCgRPCREST <ul> <li>URL: <code>tasks/resubscribe</code></li> <li>HTTP Method: <code>POST</code></li> <li>Payload: <code>TaskIdParams</code></li> <li>Response: A stream of Server-Sent Events. Each SSE <code>data</code> field contains a <code>SendStreamingMessageResponse</code></li> </ul> <ul> <li>URL: <code>TaskSubscription</code></li> <li>HTTP Method: <code>POST</code></li> <li>Payload: <pre><code>message TaskSubscriptionRequest{\n  // name=tasks/{id}\n  string name;\n}\n</code></pre></li> <li>Response: <pre><code>message StreamResponse {\n  oneof payload {\n    Task task;\n    Message msg;\n    TaskStatusUpdateEvent status_update;\n    TaskArtifactUpdateEvent artifact_update;\n  }\n}\n</code></pre></li> </ul> <ul> <li>URL: <code>/v1/tasks/{id}:subscribe</code></li> <li>HTTP Method: <code>POST</code></li> <li>Payload: <pre><code>{\n  name: string\n}\n</code></pre></li> <li>Response: <pre><code>{\n  message?: Message\n  task?: Task\n  statusUpdate?: TaskStatusUpdateEvent\n  artifactUpdate?: TaskArtifactUpdateEvent\n}\n</code></pre></li> </ul>"},{"location":"specification/#710-agentgetauthenticatedextendedcard","title":"7.10. <code>agent/getAuthenticatedExtendedCard</code>","text":"<p>Retrieves a potentially more detailed version of the Agent Card after the client has authenticated. This endpoint is available only if <code>AgentCard.supportsAuthenticatedExtendedCard</code> is <code>true</code>.</p> <ul> <li>Authentication: The client MUST authenticate the request using one of the schemes declared in the public <code>AgentCard.securitySchemes</code> and <code>AgentCard.security</code> fields.</li> <li>Response <code>result</code> type (on success): <code>AgentCard</code> (A complete Agent Card object, which may contain additional details or skills not present in the public card).</li> <li>Response <code>error</code> type (on failure): Standard HTTP error codes.<ul> <li><code>401 Unauthorized</code>: Authentication failed (missing or invalid credentials). The server SHOULD include a <code>WWW-Authenticate</code> header.</li> </ul> </li> </ul> JSON-RPCgRPCREST <ul> <li>URL: <code>agent/getAuthenticatedExtendedCard</code></li> <li>HTTP Method: <code>POST</code></li> <li>Payload: None</li> <li>Response: <code>AgentCard</code></li> </ul> <ul> <li>URL: <code>GetAgentCard</code></li> <li>HTTP Method: <code>POST</code></li> <li>Payload: None</li> <li>Response: <code>AgentCard</code></li> </ul> <ul> <li>URL: <code>/v1/card</code></li> <li>HTTP Method: <code>GET</code></li> <li>Payload: None</li> <li>Response: <code>AgentCard</code></li> </ul> <p>Clients retrieving this authenticated card SHOULD replace their cached public Agent Card with the content received from this endpoint for the duration of their authenticated session or until the card's version changes.</p> <pre><code>/**\n * Represents a successful JSON-RPC response for the `agent/getAuthenticatedExtendedCard` method.\n */\nexport interface GetAuthenticatedExtendedCardSuccessResponse\n  extends JSONRPCSuccessResponse {\n  /** The result is an Agent Card object. */\n  result: AgentCard;\n}\n</code></pre>"},{"location":"specification/#8-error-handling","title":"8. Error Handling","text":"<p>A2A uses standard JSON-RPC 2.0 error codes and structure for reporting errors. Errors are returned in the <code>error</code> member of the <code>JSONRPCErrorResponse</code> object. See <code>JSONRPCError</code> Object definition.</p>"},{"location":"specification/#81-standard-json-rpc-errors","title":"8.1. Standard JSON-RPC Errors","text":"<p>These are standard codes defined by the JSON-RPC 2.0 specification.</p> Code JSON-RPC Spec Meaning Typical A2A <code>message</code> Description <code>-32700</code> Parse error Invalid JSON payload Server received JSON that was not well-formed. <code>-32600</code> Invalid Request Invalid JSON-RPC Request The JSON payload was valid JSON, but not a valid JSON-RPC Request object. <code>-32601</code> Method not found Method not found The requested A2A RPC <code>method</code> (e.g., <code>\"tasks/foo\"</code>) does not exist or is not supported. <code>-32602</code> Invalid params Invalid method parameters The <code>params</code> provided for the method are invalid (e.g., wrong type, missing required field). <code>-32603</code> Internal error Internal server error An unexpected error occurred on the server during processing. <code>-32000</code> to <code>-32099</code> Server error (Server-defined) Reserved for implementation-defined server-errors. A2A-specific errors use this range."},{"location":"specification/#82-a2a-specific-errors","title":"8.2. A2A-Specific Errors","text":"<p>These are custom error codes defined within the JSON-RPC server error range (<code>-32000</code> to <code>-32099</code>) to provide more specific feedback about A2A-related issues. Servers SHOULD use these codes where applicable.</p> Code Error Name (Conceptual) Typical <code>message</code> string Description <code>-32001</code> <code>TaskNotFoundError</code> Task not found The specified task <code>id</code> does not correspond to an existing or active task. It might be invalid, expired, or already completed and purged. <code>-32002</code> <code>TaskNotCancelableError</code> Task cannot be canceled An attempt was made to cancel a task that is not in a cancelable state (e.g., it has already reached a terminal state like <code>completed</code>, <code>failed</code>, or <code>canceled</code>). <code>-32003</code> <code>PushNotificationNotSupportedError</code> Push Notification is not supported Client attempted to use push notification features (e.g., <code>tasks/pushNotificationConfig/set</code>) but the server agent does not support them (i.e., <code>AgentCard.capabilities.pushNotifications</code> is <code>false</code>). <code>-32004</code> <code>UnsupportedOperationError</code> This operation is not supported The requested operation or a specific aspect of it (perhaps implied by parameters) is not supported by this server agent implementation. Broader than just method not found. <code>-32005</code> <code>ContentTypeNotSupportedError</code> Incompatible content types A Media Type provided in the request's <code>message.parts</code> (or implied for an artifact) is not supported by the agent or the specific skill being invoked. <code>-32006</code> <code>InvalidAgentResponseError</code> Invalid agent response type Agent generated an invalid response for the requested method <code>-32007</code> <code>AuthenticatedExtendedCardNotConfiguredError</code> Authenticated Extended Card not configured The agent does not have an Authenticated Extended Card configured. <p>Servers MAY define additional error codes within the <code>-32000</code> to <code>-32099</code> range for more specific scenarios not covered above, but they SHOULD document these clearly. The <code>data</code> field of the <code>JSONRPCError</code> object can be used to provide more structured details for any error.</p>"},{"location":"specification/#9-common-workflows-examples","title":"9. Common Workflows &amp; Examples","text":"<p>This section provides illustrative JSON examples of common A2A interactions. Timestamps, context IDs, and request/response IDs are for demonstration purposes. For brevity, some optional fields might be omitted if not central to the example.</p>"},{"location":"specification/#91-fetching-authenticated-extended-agent-card","title":"9.1. Fetching Authenticated Extended Agent Card","text":"<p>Scenario: A client discovers a public Agent Card indicating support for an authenticated extended card and wants to retrieve the full details.</p> <ol> <li>Client fetches the public Agent Card:</li> </ol> <pre><code>GET https://example.com/.well-known/agent-card.json\n</code></pre> <p>Server responds with the public Agent Card (like the example in Section 5.6), including <code>supportsAuthenticatedExtendedCard: true</code> (at the root level) and <code>securitySchemes</code>.</p> <ol> <li> <p>Client identifies required authentication from the public card.</p> </li> <li> <p>Client obtains necessary credentials out-of-band (e.g., performs OAuth 2.0 flow with Google, resulting in an access token).</p> </li> <li> <p>Client fetches the authenticated extended Agent Card using <code>agent/getAuthenticatedExtendedCard</code> request:</p> </li> </ol> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"agent/getAuthenticatedExtendedCard\"\n}\n</code></pre> <ol> <li> <p>Server authenticates and authorizes the request.</p> </li> <li> <p>Server responds with the full Agent Card as the JSON-RPC result:</p> </li> </ol>"},{"location":"specification/#92-basic-execution-synchronous-polling-style","title":"9.2. Basic Execution (Synchronous / Polling Style)","text":"<p>Scenario: Client asks a simple question, and the agent responds quickly with a task</p> <ol> <li>Client sends a message using <code>message/send</code>:</li> </ol> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"message/send\",\n  \"params\": {\n    \"message\": {\n      \"role\": \"user\",\n      \"parts\": [\n        {\n          \"kind\": \"text\",\n          \"text\": \"tell me a joke\"\n        }\n      ],\n      \"messageId\": \"9229e770-767c-417b-a0b0-f0741243c589\"\n    },\n    \"metadata\": {}\n  }\n}\n</code></pre> <ol> <li>Server processes the request, creates a task and responds (task completes quickly)</li> </ol> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"result\": {\n    \"id\": \"363422be-b0f9-4692-a24d-278670e7c7f1\",\n    \"contextId\": \"c295ea44-7543-4f78-b524-7a38915ad6e4\",\n    \"status\": {\n      \"state\": \"completed\"\n    },\n    \"artifacts\": [\n      {\n        \"artifactId\": \"9b6934dd-37e3-4eb1-8766-962efaab63a1\",\n        \"name\": \"joke\",\n        \"parts\": [\n          {\n            \"kind\": \"text\",\n            \"text\": \"Why did the chicken cross the road? To get to the other side!\"\n          }\n        ]\n      }\n    ],\n    \"history\": [\n      {\n        \"role\": \"user\",\n        \"parts\": [\n          {\n            \"kind\": \"text\",\n            \"text\": \"tell me a joke\"\n          }\n        ],\n        \"messageId\": \"9229e770-767c-417b-a0b0-f0741243c589\",\n        \"taskId\": \"363422be-b0f9-4692-a24d-278670e7c7f1\",\n        \"contextId\": \"c295ea44-7543-4f78-b524-7a38915ad6e4\"\n      }\n    ],\n    \"kind\": \"task\",\n    \"metadata\": {}\n  }\n}\n</code></pre> <p>If the task were longer-running, the server might initially respond with <code>status.state: \"working\"</code>. The client would then periodically call <code>tasks/get</code> with params: <code>{\"id\": \"363422be-b0f9-4692-a24d-278670e7c7f1\"}</code> until the task reaches a terminal state.</p> <p>Scenario: Client asks a simple question, and the agent responds quickly without a task</p> <ol> <li>Client sends a message using <code>message/send</code>:</li> </ol> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"message/send\",\n  \"params\": {\n    \"message\": {\n      \"role\": \"user\",\n      \"parts\": [\n        {\n          \"kind\": \"text\",\n          \"text\": \"tell me a joke\"\n        }\n      ],\n      \"messageId\": \"9229e770-767c-417b-a0b0-f0741243c589\"\n    },\n    \"metadata\": {}\n  }\n}\n</code></pre> <ol> <li>Server processes the request, responds quickly without a task</li> </ol> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"result\": {\n    \"messageId\": \"363422be-b0f9-4692-a24d-278670e7c7f1\",\n    \"contextId\": \"c295ea44-7543-4f78-b524-7a38915ad6e4\",\n    \"parts\": [\n      {\n        \"kind\": \"text\",\n        \"text\": \"Why did the chicken cross the road? To get to the other side!\"\n      }\n    ],\n    \"kind\": \"message\",\n    \"metadata\": {}\n  }\n}\n</code></pre>"},{"location":"specification/#93-streaming-task-execution-sse","title":"9.3. Streaming Task Execution (SSE)","text":"<p>Scenario: Client asks the agent to write a long paper describing an attached picture.</p> <ol> <li>Client sends a message and subscribes using <code>message/stream</code>:</li> </ol> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"message/stream\",\n  \"params\": {\n    \"message\": {\n      \"role\": \"user\",\n      \"parts\": [\n        {\n          \"kind\": \"text\",\n          \"text\": \"write a long paper describing the attached pictures\"\n        },\n        {\n          \"kind\": \"file\",\n          \"file\": {\n            \"mimeType\": \"image/png\",\n            \"data\": \"&lt;base64-encoded-content&gt;\"\n          }\n        }\n      ],\n      \"messageId\": \"bbb7dee1-cf5c-4683-8a6f-4114529da5eb\"\n    },\n    \"metadata\": {}\n  }\n}\n</code></pre> <ol> <li>Server responds with HTTP 200 OK, <code>Content-Type: text/event-stream</code>, and starts sending SSE events:</li> </ol> <p>Event 1: Task status update - working</p> <pre><code>data: {\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"result\": {\n    \"id\": \"225d6247-06ba-4cda-a08b-33ae35c8dcfa\",\n    \"contextId\": \"05217e44-7e9f-473e-ab4f-2c2dde50a2b1\",\n    \"status\": {\n      \"state\": \"submitted\",\n      \"timestamp\":\"2025-04-02T16:59:25.331844\"\n    },\n    \"history\": [\n      {\n        \"role\": \"user\",\n        \"parts\": [\n          {\n            \"kind\": \"text\",\n            \"text\": \"write a long paper describing the attached pictures\"\n          },\n          {\n            \"kind\": \"file\",\n            \"file\": {\n              \"mimeType\": \"image/png\",\n              \"data\": \"&lt;base64-encoded-content&gt;\"\n            }\n          }\n        ],\n        \"messageId\": \"bbb7dee1-cf5c-4683-8a6f-4114529da5eb\",\n        \"taskId\": \"225d6247-06ba-4cda-a08b-33ae35c8dcfa\",\n        \"contextId\": \"05217e44-7e9f-473e-ab4f-2c2dde50a2b1\"\n      }\n    ],\n    \"kind\": \"task\",\n    \"metadata\": {}\n  }\n}\n\ndata: {\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"result\": {\n    \"taskId\": \"225d6247-06ba-4cda-a08b-33ae35c8dcfa\",\n    \"contextId\": \"05217e44-7e9f-473e-ab4f-2c2dde50a2b1\",\n    \"artifact\": {\n      \"artifactId\": \"9b6934dd-37e3-4eb1-8766-962efaab63a1\",\n      \"parts\": [\n        {\"kind\":\"text\", \"text\": \"&lt;section 1...&gt;\"}\n      ]\n    },\n    \"append\": false,\n    \"lastChunk\": false,\n    \"kind\":\"artifact-update\"\n  }\n}\n\ndata: {\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"result\": {\n    \"taskId\": \"225d6247-06ba-4cda-a08b-33ae35c8dcfa\",\n    \"contextId\": \"05217e44-7e9f-473e-ab4f-2c2dde50a2b1\",\n    \"artifact\": {\n      \"artifactId\": \"9b6934dd-37e3-4eb1-8766-962efaab63a1\",\n      \"parts\": [\n        {\"kind\":\"text\", \"text\": \"&lt;section 2...&gt;\"}\n      ],\n    },\n    \"append\": true,\n    \"lastChunk\": false,\n    \"kind\":\"artifact-update\"\n  }\n}\n\n\ndata: {\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"result\": {\n    \"taskId\": \"225d6247-06ba-4cda-a08b-33ae35c8dcfa\",\n    \"contextId\": \"05217e44-7e9f-473e-ab4f-2c2dde50a2b1\",\n    \"artifact\": {\n      \"artifactId\": \"9b6934dd-37e3-4eb1-8766-962efaab63a1\",\n      \"parts\": [\n        {\"kind\":\"text\", \"text\": \"&lt;section 3...&gt;\"}\n      ]\n    },\n    \"append\": true,\n    \"lastChunk\": true,\n    \"kind\":\"artifact-update\"\n  }\n}\n\ndata: {\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"result\": {\n    \"taskId\": \"225d6247-06ba-4cda-a08b-33ae35c8dcfa\",\n    \"contextId\": \"05217e44-7e9f-473e-ab4f-2c2dde50a2b1\",\n    \"status\": {\n      \"state\": \"completed\",\n      \"timestamp\":\"2025-04-02T16:59:35.331844\"\n    },\n    \"final\": true,\n    \"kind\":\"status-update\"\n  }\n}\n</code></pre> <p>(Server closes the SSE connection after the <code>final:true</code> event).</p>"},{"location":"specification/#94-multi-turn-interaction-input-required","title":"9.4. Multi-Turn Interaction (Input Required)","text":"<p>Scenario: Client wants to book a flight, and the agent needs more information.</p> <ol> <li>Client sends a message using <code>message/send</code>:</li> </ol> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"req-003\",\n  \"method\": \"message/send\",\n  \"params\": {\n    \"message\": {\n      \"role\": \"user\",\n      \"parts\": [{ \"kind\": \"text\", \"text\": \"I'd like to book a flight.\" }]\n    },\n    \"messageId\": \"c53ba666-3f97-433c-a87b-6084276babe2\"\n  }\n}\n</code></pre> <ol> <li>Server responds, task state is <code>input-required</code>:</li> </ol> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"req-003\",\n  \"result\": {\n    \"id\": \"3f36680c-7f37-4a5f-945e-d78981fafd36\",\n    \"contextId\": \"c295ea44-7543-4f78-b524-7a38915ad6e4\",\n    \"status\": {\n      \"state\": \"input-required\",\n      \"message\": {\n        \"role\": \"agent\",\n        \"parts\": [\n          {\n            \"kind\": \"text\",\n            \"text\": \"Sure, I can help with that! Where would you like to fly to, and from where? Also, what are your preferred travel dates?\"\n          }\n        ],\n        \"messageId\": \"c2e1b2dd-f200-4b04-bc22-1b0c65a1aad2\",\n        \"taskId\": \"3f36680c-7f37-4a5f-945e-d78981fafd36\",\n        \"contextId\": \"c295ea44-7543-4f78-b524-7a38915ad6e4\"\n      },\n      \"timestamp\": \"2024-03-15T10:10:00Z\"\n    },\n    \"history\": [\n      {\n        \"role\": \"user\",\n        \"parts\": [\n          {\n            \"kind\": \"text\",\n            \"text\": \"I'd like to book a flight.\"\n          }\n        ],\n        \"messageId\": \"c53ba666-3f97-433c-a87b-6084276babe2\",\n        \"taskId\": \"3f36680c-7f37-4a5f-945e-d78981fafd36\",\n        \"contextId\": \"c295ea44-7543-4f78-b524-7a38915ad6e4\"\n      }\n    ],\n    \"kind\": \"task\"\n  }\n}\n</code></pre> <ol> <li>Client <code>message/send</code> (providing the requested input, using the same task ID):</li> </ol> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"req-004\",\n  \"method\": \"message/send\",\n  \"params\": {\n    \"message\": {\n      \"role\": \"user\",\n      \"parts\": [\n        {\n          \"kind\": \"text\",\n          \"text\": \"I want to fly from New York (JFK) to London (LHR) around October 10th, returning October 17th.\"\n        }\n      ],\n      \"contextId\": \"c295ea44-7543-4f78-b524-7a38915ad6e4\",\n      \"taskId\": \"3f36680c-7f37-4a5f-945e-d78981fafd36\",\n      \"messageId\": \"0db1d6c4-3976-40ed-b9b8-0043ea7a03d3\"\n    },\n    \"configuration\": {\n      \"blocking\": true\n    }\n  }\n}\n</code></pre> <ol> <li>Server processes the new input and responds (e.g., task completed or more input needed):</li> </ol> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"req-004\",\n  \"result\": {\n    \"id\": \"3f36680c-7f37-4a5f-945e-d78981fafd36\",\n    \"contextId\": \"c295ea44-7543-4f78-b524-7a38915ad6e4\",\n    \"status\": {\n      \"state\": \"completed\",\n      \"message\": {\n        \"role\": \"agent\",\n        \"parts\": [\n          {\n            \"kind\": \"text\",\n            \"text\": \"Okay, I've found a flight for you. Confirmation XYZ123. Details are in the artifact.\"\n          }\n        ]\n      }\n    },\n    \"artifacts\": [\n      {\n        \"artifactId\": \"9b6934dd-37e3-4eb1-8766-962efaab63a1\",\n        \"name\": \"FlightItinerary.json\",\n        \"parts\": [\n          {\n            \"kind\": \"data\",\n            \"data\": {\n              \"confirmationId\": \"XYZ123\",\n              \"from\": \"JFK\",\n              \"to\": \"LHR\",\n              \"departure\": \"2024-10-10T18:00:00Z\",\n              \"arrival\": \"2024-10-11T06:00:00Z\",\n              \"returnDeparture\": \"...\"\n            }\n          }\n        ]\n      }\n    ],\n    \"history\": [\n      {\n        \"role\": \"user\",\n        \"parts\": [\n          {\n            \"kind\": \"text\",\n            \"text\": \"I'd like to book a flight.\"\n          }\n        ],\n        \"messageId\": \"c53ba666-3f97-433c-a87b-6084276babe2\",\n        \"taskId\": \"3f36680c-7f37-4a5f-945e-d78981fafd36\",\n        \"contextId\": \"c295ea44-7543-4f78-b524-7a38915ad6e4\"\n      },\n      {\n        \"role\": \"agent\",\n        \"parts\": [\n          {\n            \"kind\": \"text\",\n            \"text\": \"Sure, I can help with that! Where would you like to fly to, and from where? Also, what are your preferred travel dates?\"\n          }\n        ],\n        \"messageId\": \"c2e1b2dd-f200-4b04-bc22-1b0c65a1aad2\",\n        \"taskId\": \"3f36680c-7f37-4a5f-945e-d78981fafd36\",\n        \"contextId\": \"c295ea44-7543-4f78-b524-7a38915ad6e4\"\n      },\n      {\n        \"role\": \"user\",\n        \"parts\": [\n          {\n            \"kind\": \"text\",\n            \"text\": \"I want to fly from New York (JFK) to London (LHR) around October 10th, returning October 17th.\"\n          }\n        ],\n        \"contextId\": \"c295ea44-7543-4f78-b524-7a38915ad6e4\",\n        \"taskId\": \"3f36680c-7f37-4a5f-945e-d78981fafd36\",\n        \"messageId\": \"0db1d6c4-3976-40ed-b9b8-0043ea7a03d3\"\n      }\n    ],\n    \"kind\": \"task\",\n    \"metadata\": {}\n  }\n}\n</code></pre>"},{"location":"specification/#95-push-notification-setup-and-usage","title":"9.5. Push Notification Setup and Usage","text":"<p>Scenario: Client requests a long-running report generation and wants to be notified via webhook when it's done.</p> <ol> <li>Client <code>message/send</code> with <code>pushNotification</code> config:</li> </ol> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"req-005\",\n  \"method\": \"message/send\",\n  \"params\": {\n    \"message\": {\n      \"role\": \"user\",\n      \"parts\": [\n        {\n          \"kind\": \"text\",\n          \"text\": \"Generate the Q1 sales report. This usually takes a while. Notify me when it's ready.\"\n        }\n      ],\n      \"messageId\": \"6dbc13b5-bd57-4c2b-b503-24e381b6c8d6\"\n    },\n    \"configuration\": {\n      \"pushNotificationConfig\": {\n        \"url\": \"https://client.example.com/webhook/a2a-notifications\",\n        \"token\": \"secure-client-token-for-task-aaa\",\n        \"authentication\": {\n          \"schemes\": [\"Bearer\"]\n          // Assuming server knows how to get a Bearer token for this webhook audience,\n          // or this implies the webhook is public/uses the 'token' for auth.\n          // 'credentials' could provide more specifics if needed by the server.\n        }\n      }\n    }\n  }\n}\n</code></pre> <ol> <li>Server acknowledges the task (e.g., status <code>submitted</code> or <code>working</code>):</li> </ol> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"req-005\",\n  \"result\": {\n    \"id\": \"43667960-d455-4453-b0cf-1bae4955270d\",\n    \"contextId\": \"c295ea44-7543-4f78-b524-7a38915ad6e4\",\n    \"status\": { \"state\": \"submitted\", \"timestamp\": \"2024-03-15T11:00:00Z\" }\n    // ... other fields ...\n  }\n}\n</code></pre> <ol> <li> <p>(Later) A2A Server completes the task and POSTs a notification to <code>https://client.example.com/webhook/a2a-notifications</code>:</p> </li> <li> <p>HTTP Headers might include:</p> <ul> <li><code>Authorization: Bearer &lt;server_jwt_for_webhook_audience&gt;</code> (if server authenticates to webhook)</li> <li><code>Content-Type: application/json</code></li> <li><code>X-A2A-Notification-Token: secure-client-token-for-task-aaa</code></li> </ul> </li> <li>HTTP Body (Task object is sent as JSON payload):</li> </ol> <pre><code>{\n  \"id\": \"43667960-d455-4453-b0cf-1bae4955270d\",\n  \"contextId\": \"c295ea44-7543-4f78-b524-7a38915ad6e4\",\n  \"status\": { \"state\": \"completed\", \"timestamp\": \"2024-03-15T18:30:00Z\" },\n  \"kind\": \"task\"\n  // ... other fields ...\n}\n</code></pre> <ol> <li> <p>Client's Webhook Service:</p> </li> <li> <p>Receives the POST.</p> </li> <li>Validates the <code>Authorization</code> header (if applicable).</li> <li>Validates the <code>X-A2A-Notification-Token</code>.</li> <li>Internally processes the notification (e.g., updates application state, notifies end user).</li> </ol>"},{"location":"specification/#96-file-exchange-upload-and-download","title":"9.6. File Exchange (Upload and Download)","text":"<p>Scenario: Client sends an image for analysis, and the agent returns a modified image.</p> <ol> <li>Client <code>message/send</code> with a <code>FilePart</code> (uploading image bytes):</li> </ol> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"req-007\",\n  \"method\": \"message/send\",\n  \"params\": {\n    \"message\": {\n      \"role\": \"user\",\n      \"parts\": [\n        {\n          \"kind\": \"text\",\n          \"text\": \"Analyze this image and highlight any faces.\"\n        },\n        {\n          \"kind\": \"file\",\n          \"file\": {\n            \"name\": \"input_image.png\",\n            \"mimeType\": \"image/png\",\n            \"bytes\": \"iVBORw0KGgoAAAANSUhEUgAAAAUA...\" // Base64 encoded image data\n          }\n        }\n      ],\n      \"messageId\": \"6dbc13b5-bd57-4c2b-b503-24e381b6c8d6\"\n    }\n  }\n}\n</code></pre> <ol> <li>Server processes the image and responds with a <code>FilePart</code> in an artifact (e.g., providing a URI to the modified image):</li> </ol> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"req-007\",\n  \"result\": {\n    \"id\": \"43667960-d455-4453-b0cf-1bae4955270d\",\n    \"contextId\": \"c295ea44-7543-4f78-b524-7a38915ad6e4\",\n    \"status\": { \"state\": \"completed\", \"timestamp\": \"2024-03-15T12:05:00Z\" },\n    \"artifacts\": [\n      {\n        \"artifactId\": \"9b6934dd-37e3-4eb1-8766-962efaab63a1\",\n        \"name\": \"processed_image_with_faces.png\",\n        \"parts\": [\n          {\n            \"kind\": \"file\",\n            \"file\": {\n              \"name\": \"output.png\",\n              \"mimeType\": \"image/png\",\n              // Server might provide a URI to a temporary storage location\n              \"uri\": \"https://storage.example.com/processed/task-bbb/output.png?token=xyz\"\n              // Or, alternatively, it could return bytes directly:\n              // \"bytes\": \"ASEDGhw0KGgoAAAANSUhEUgAA...\"\n            }\n          }\n        ]\n      }\n    ],\n    \"kind\": \"task\"\n  }\n}\n</code></pre>"},{"location":"specification/#97-structured-data-exchange-requesting-and-providing-json","title":"9.7. Structured Data Exchange (Requesting and Providing JSON)","text":"<p>Scenario: Client asks for a list of open support tickets in a specific JSON format.</p> <ol> <li>Client <code>message/send</code>, <code>Part.metadata</code> hints at desired output schema/Media Type: (Note: A2A doesn't formally standardize schema negotiation in v0.2.0, but <code>metadata</code> can be used for such hints by convention between client/server).</li> </ol> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 9,\n  \"method\": \"message/send\",\n  \"params\": {\n    \"message\": {\n      \"role\": \"user\",\n      \"parts\": [\n        {\n          \"kind\": \"text\",\n          \"text\": \"Show me a list of my open IT tickets\",\n          \"metadata\": {\n            \"mimeType\": \"application/json\",\n            \"schema\": {\n              \"type\": \"array\",\n              \"items\": {\n                \"type\": \"object\",\n                \"properties\": {\n                  \"ticketNumber\": { \"type\": \"string\" },\n                  \"description\": { \"type\": \"string\" }\n                }\n              }\n            }\n          }\n        }\n      ],\n      \"messageId\": \"85b26db5-ffbb-4278-a5da-a7b09dea1b47\"\n    },\n    \"metadata\": {}\n  }\n}\n</code></pre> <ol> <li>Server responds with structured JSON data:</li> </ol> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 9,\n  \"result\": {\n    \"id\": \"d8c6243f-5f7a-4f6f-821d-957ce51e856c\",\n    \"contextId\": \"c295ea44-7543-4f78-b524-7a38915ad6e4\",\n    \"status\": {\n      \"state\": \"completed\",\n      \"timestamp\": \"2025-04-17T17:47:09.680794\"\n    },\n    \"artifacts\": [\n      {\n        \"artifactId\": \"c5e0382f-b57f-4da7-87d8-b85171fad17c\",\n        \"parts\": [\n          {\n            \"kind\": \"text\",\n            \"text\": \"[{\\\"ticketNumber\\\":\\\"REQ12312\\\",\\\"description\\\":\\\"request for VPN access\\\"},{\\\"ticketNumber\\\":\\\"REQ23422\\\",\\\"description\\\":\\\"Add to DL - team-gcp-onboarding\\\"}]\"\n          }\n        ]\n      }\n    ],\n    \"kind\": \"task\"\n  }\n}\n</code></pre> <p>These examples illustrate the flexibility of A2A in handling various interaction patterns and data types. Implementers should refer to the detailed object definitions for all fields and constraints.</p>"},{"location":"specification/#10-appendices","title":"10. Appendices","text":""},{"location":"specification/#101-relationship-to-mcp-model-context-protocol","title":"10.1. Relationship to MCP (Model Context Protocol)","text":"<p>A2A and MCP are complementary protocols designed for different aspects of agentic systems:</p> <ul> <li>Model Context Protocol (MCP): Focuses on standardizing how AI models and agents connect to and interact with tools, APIs, data sources, and other external resources. It defines structured ways to describe tool capabilities (like function calling in LLMs), pass inputs, and receive structured outputs. Think of MCP as the \"how-to\" for an agent to use a specific capability or access a resource.</li> <li>Agent2Agent Protocol (A2A): Focuses on standardizing how independent, often opaque, AI agents communicate and collaborate with each other as peers. A2A provides an application-level protocol for agents to discover each other, negotiate interaction modalities, manage shared tasks, and exchange conversational context or complex results. It's about how agents partner or delegate work.</li> </ul> <p>How they work together: An A2A Client agent might request an A2A Server agent to perform a complex task. The Server agent, in turn, might use MCP to interact with several underlying tools, APIs, or data sources to gather information or perform actions necessary to fulfill the A2A task.</p> <p>For a more detailed comparison, see the A2A and MCP guide.</p>"},{"location":"specification/#102-security-considerations-summary","title":"10.2. Security Considerations Summary","text":"<p>Security is a paramount concern in A2A. Key considerations include:</p> <ul> <li>Transport Security: Always use HTTPS with strong TLS configurations in production environments.</li> <li>Authentication:<ul> <li>Handled via standard HTTP mechanisms (e.g., <code>Authorization</code> header with Bearer tokens, API keys).</li> <li>Requirements are declared in the <code>AgentCard</code>.</li> <li>Credentials MUST be obtained out-of-band by the client.</li> <li>A2A Servers MUST authenticate every request.</li> </ul> </li> <li>Authorization:<ul> <li>A server-side responsibility based on the authenticated identity.</li> <li>Implement the principle of least privilege.</li> <li>Can be granular, based on skills, actions, or data.</li> </ul> </li> <li>Push Notification Security:<ul> <li>Webhook URL validation (by the A2A Server sending notifications) is crucial to prevent SSRF.</li> <li>Authentication of the A2A Server to the client's webhook is essential.</li> <li>Authentication of the notification by the client's webhook receiver (verifying it came from the legitimate A2A Server and is relevant) is critical.</li> <li>See the Streaming &amp; Asynchronous Operations guide for detailed push notification security.</li> </ul> </li> <li>Input Validation: Servers MUST rigorously validate all RPC parameters and the content/structure of data in <code>Message</code> and <code>Artifact</code> parts to prevent injection attacks or processing errors.</li> <li>Resource Management: Implement rate limiting, concurrency controls, and resource limits to protect agents from abuse or overload.</li> <li>Data Privacy: Adhere to all applicable privacy regulations for data exchanged in <code>Message</code> and <code>Artifact</code> parts. Minimize sensitive data transfer.</li> </ul> <p>For a comprehensive discussion, refer to the Enterprise-Ready Features guide.</p>"},{"location":"specification/#11-a2a-compliance-requirements","title":"11. A2A Compliance Requirements","text":"<p>This section defines the normative requirements for A2A-compliant implementations.</p>"},{"location":"specification/#111-agent-compliance","title":"11.1. Agent Compliance","text":"<p>For an agent to be considered A2A-compliant, it MUST:</p>"},{"location":"specification/#1111-transport-support-requirements","title":"11.1.1. Transport Support Requirements","text":"<ul> <li>Support at least one transport: Agents MUST implement at least one transport protocols as defined in Section 3.2.</li> <li>Expose Agent Card: MUST provide a valid <code>AgentCard</code> document as defined in Section 5.</li> <li>Declare transport capabilities: MUST accurately declare all supported transports in the <code>AgentCard</code> using <code>preferredTransport</code> and <code>additionalInterfaces</code> fields following the requirements in Section 5.6.</li> </ul>"},{"location":"specification/#1112-core-method-implementation","title":"11.1.2. Core Method Implementation","text":"<p>MUST implement all of the following core methods via at least one supported transport:</p> <ul> <li><code>message/send</code> - Send messages and initiate tasks</li> <li><code>tasks/get</code> - Retrieve task status and results</li> <li><code>tasks/cancel</code> - Request task cancellation</li> </ul>"},{"location":"specification/#1113-optional-method-implementation","title":"11.1.3. Optional Method Implementation","text":"<p>MAY implement the following optional methods:</p> <ul> <li><code>message/stream</code> - Streaming message interaction (requires <code>capabilities.streaming: true</code>)</li> <li><code>tasks/resubscribe</code> - Resume streaming for existing tasks (requires <code>capabilities.streaming: true</code>)</li> <li><code>tasks/pushNotificationConfig/set</code> - Configure push notifications (requires <code>capabilities.pushNotifications: true</code>)</li> <li><code>tasks/pushNotificationConfig/get</code> - Retrieve push notification config (requires <code>capabilities.pushNotifications: true</code>)</li> <li><code>tasks/pushNotificationConfig/list</code> - List push notification configs (requires <code>capabilities.pushNotifications: true</code>)</li> <li><code>tasks/pushNotificationConfig/delete</code> - Delete push notification config (requires <code>capabilities.pushNotifications: true</code>)</li> <li><code>agent/authenticatedExtendedCard</code> - Retrieve authenticated agent card (requires <code>supportsAuthenticatedExtendedCard: true</code>)</li> </ul>"},{"location":"specification/#1114-multi-transport-compliance","title":"11.1.4. Multi-Transport Compliance","text":"<p>If an agent supports additional transports (gRPC, HTTP+JSON), it MUST:</p> <ul> <li>Functional equivalence: Provide identical functionality across all supported transports.</li> <li>Consistent behavior: Return semantically equivalent results for the same operations.</li> <li>Transport-specific requirements: Conform to all requirements defined in Section 3.2 for each supported transport.</li> <li>Method mapping compliance: Use the standard method mappings defined in Section 3.5 for all supported transports.</li> </ul>"},{"location":"specification/#1115-data-format-compliance","title":"11.1.5. Data Format Compliance","text":"<ul> <li>JSON-RPC structure: MUST use valid JSON-RPC 2.0 request/response objects as defined in Section 6.11.</li> <li>A2A data objects: MUST use the data structures defined in Section 6 for all protocol entities.</li> <li>Error handling: MUST use the error codes defined in Section 8.</li> </ul>"},{"location":"specification/#112-client-compliance","title":"11.2. Client Compliance","text":"<p>For a client to be considered A2A-compliant, it MUST:</p>"},{"location":"specification/#1121-transport-support","title":"11.2.1. Transport Support","text":"<ul> <li>Multi-transport capability: MUST be able to communicate with agents using at least one transport protocols.</li> <li>Agent Card processing: MUST be able to parse and interpret <code>AgentCard</code> documents.</li> <li>Transport selection: MUST be able to select an appropriate transport from the agent's declared capabilities following the rules defined in Section 5.6.3.</li> </ul>"},{"location":"specification/#1122-protocol-implementation","title":"11.2.2. Protocol Implementation","text":"<ul> <li>Core method usage: MUST properly construct requests for at least <code>message/send</code> and <code>tasks/get</code> methods.</li> <li>Error handling: MUST properly handle all A2A error codes defined in Section 8.2.</li> <li>Authentication: MUST support at least one authentication method when interacting with agents that require authentication.</li> </ul>"},{"location":"specification/#1123-optional-client-features","title":"11.2.3. Optional Client Features","text":"<p>Clients MAY implement:</p> <ul> <li>Multi-transport support: Support for gRPC and/or HTTP+JSON transports.</li> <li>Streaming support: Handle streaming methods and Server-Sent Events.</li> <li>Push notification handling: Serve as webhook endpoints for push notifications.</li> <li>Extended Agent Cards: Retrieve and use authenticated extended agent cards.</li> </ul>"},{"location":"specification/#113-compliance-testing","title":"11.3. Compliance Testing","text":"<p>Implementations SHOULD validate compliance through:</p> <ul> <li>Transport interoperability: Test communication with agents using different transport implementations.</li> <li>Method mapping verification: Verify that all supported transports use the correct method names and URL patterns as defined in Section 3.5.</li> <li>Error handling: Verify proper handling of all defined error conditions.</li> <li>Data format validation: Ensure JSON schemas match the TypeScript type definitions in <code>types/src/types.ts</code>.</li> <li>Multi-transport consistency: For multi-transport agents, verify functional equivalence across all supported transports.</li> </ul>"},{"location":"sdk/python/","title":"Python SDK Reference","text":"<p>This page contains SDK documentation for the <code>a2a-sdk</code> Python package.</p> <pre><code>pip install a2a-sdk\n</code></pre>"},{"location":"sdk/python/#client","title":"Client","text":"<p>Client-side components for interacting with an A2A agent.</p>"},{"location":"sdk/python/#a2a.client.logger","title":"<code>logger = logging.getLogger(__name__)</code>  <code>module-attribute</code>","text":""},{"location":"sdk/python/#a2a.client.A2ACardResolver","title":"<code>A2ACardResolver</code>","text":"<p>Agent Card resolver.</p>"},{"location":"sdk/python/#a2a.client.A2ACardResolver.agent_card_path","title":"<code>agent_card_path = agent_card_path.lstrip('/')</code>  <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.client.A2ACardResolver.base_url","title":"<code>base_url = base_url.rstrip('/')</code>  <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.client.A2ACardResolver.httpx_client","title":"<code>httpx_client = httpx_client</code>  <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.client.A2ACardResolver.get_agent_card","title":"<code>get_agent_card(relative_card_path=None, http_kwargs=None)</code>  <code>async</code>","text":"<p>Fetches an agent card from a specified path relative to the base_url.</p> <p>If relative_card_path is None, it defaults to the resolver's configured agent_card_path (for the public agent card).</p> <p>Parameters:</p> Name Type Description Default <code>relative_card_path</code> <code>str | None</code> <p>Optional path to the agent card endpoint, relative to the base URL. If None, uses the default public agent card path.</p> <code>None</code> <code>http_kwargs</code> <code>dict[str, Any] | None</code> <p>Optional dictionary of keyword arguments to pass to the underlying httpx.get request.</p> <code>None</code> <p>Returns:</p> Type Description <code>AgentCard</code> <p>An <code>AgentCard</code> object representing the agent's capabilities.</p> <p>Raises:</p> Type Description <code>A2AClientHTTPError</code> <p>If an HTTP error occurs during the request.</p> <code>A2AClientJSONError</code> <p>If the response body cannot be decoded as JSON or validated against the AgentCard schema.</p>"},{"location":"sdk/python/#a2a.client.A2AClient","title":"<code>A2AClient</code>","text":"<p>A2A Client for interacting with an A2A agent.</p>"},{"location":"sdk/python/#a2a.client.A2AClient.agent_card","title":"<code>agent_card = agent_card</code>  <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.client.A2AClient.httpx_client","title":"<code>httpx_client = httpx_client</code>  <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.client.A2AClient.interceptors","title":"<code>interceptors = interceptors or []</code>  <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.client.A2AClient.url","title":"<code>url = agent_card.url</code>  <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.client.A2AClient.cancel_task","title":"<code>cancel_task(request, *, http_kwargs=None, context=None)</code>  <code>async</code>","text":"<p>Requests the agent to cancel a specific task.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>CancelTaskRequest</code> <p>The <code>CancelTaskRequest</code> object specifying the task ID.</p> required <code>http_kwargs</code> <code>dict[str, Any] | None</code> <p>Optional dictionary of keyword arguments to pass to the underlying httpx.post request.</p> <code>None</code> <code>context</code> <code>ClientCallContext | None</code> <p>The client call context.</p> <code>None</code> <p>Returns:</p> Type Description <code>CancelTaskResponse</code> <p>A <code>CancelTaskResponse</code> object containing the updated Task with canceled status or an error.</p> <p>Raises:</p> Type Description <code>A2AClientHTTPError</code> <p>If an HTTP error occurs during the request.</p> <code>A2AClientJSONError</code> <p>If the response body cannot be decoded as JSON or validated.</p>"},{"location":"sdk/python/#a2a.client.A2AClient.get_client_from_agent_card_url","title":"<code>get_client_from_agent_card_url(httpx_client, base_url, agent_card_path=AGENT_CARD_WELL_KNOWN_PATH, http_kwargs=None)</code>  <code>async</code> <code>staticmethod</code>","text":"<p>Fetches the public AgentCard and initializes an A2A client.</p> <p>This method will always fetch the public agent card. If an authenticated or extended agent card is required, the A2ACardResolver should be used directly to fetch the specific card, and then the A2AClient should be instantiated with it.</p> <p>Parameters:</p> Name Type Description Default <code>httpx_client</code> <code>AsyncClient</code> <p>An async HTTP client instance (e.g., httpx.AsyncClient).</p> required <code>base_url</code> <code>str</code> <p>The base URL of the agent's host.</p> required <code>agent_card_path</code> <code>str</code> <p>The path to the agent card endpoint, relative to the base URL.</p> <code>AGENT_CARD_WELL_KNOWN_PATH</code> <code>http_kwargs</code> <code>dict[str, Any] | None</code> <p>Optional dictionary of keyword arguments to pass to the underlying httpx.get request when fetching the agent card.</p> <code>None</code> <p>Returns:</p> Type Description <code>A2AClient</code> <p>An initialized <code>A2AClient</code> instance.</p> <p>Raises:</p> Type Description <code>A2AClientHTTPError</code> <p>If an HTTP error occurs fetching the agent card.</p> <code>A2AClientJSONError</code> <p>If the agent card response is invalid.</p>"},{"location":"sdk/python/#a2a.client.A2AClient.get_task","title":"<code>get_task(request, *, http_kwargs=None, context=None)</code>  <code>async</code>","text":"<p>Retrieves the current state and history of a specific task.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>GetTaskRequest</code> <p>The <code>GetTaskRequest</code> object specifying the task ID and history length.</p> required <code>http_kwargs</code> <code>dict[str, Any] | None</code> <p>Optional dictionary of keyword arguments to pass to the underlying httpx.post request.</p> <code>None</code> <code>context</code> <code>ClientCallContext | None</code> <p>The client call context.</p> <code>None</code> <p>Returns:</p> Type Description <code>GetTaskResponse</code> <p>A <code>GetTaskResponse</code> object containing the Task or an error.</p> <p>Raises:</p> Type Description <code>A2AClientHTTPError</code> <p>If an HTTP error occurs during the request.</p> <code>A2AClientJSONError</code> <p>If the response body cannot be decoded as JSON or validated.</p>"},{"location":"sdk/python/#a2a.client.A2AClient.get_task_callback","title":"<code>get_task_callback(request, *, http_kwargs=None, context=None)</code>  <code>async</code>","text":"<p>Retrieves the push notification configuration for a specific task.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>GetTaskPushNotificationConfigRequest</code> <p>The <code>GetTaskPushNotificationConfigRequest</code> object specifying the task ID.</p> required <code>http_kwargs</code> <code>dict[str, Any] | None</code> <p>Optional dictionary of keyword arguments to pass to the underlying httpx.post request.</p> <code>None</code> <code>context</code> <code>ClientCallContext | None</code> <p>The client call context.</p> <code>None</code> <p>Returns:</p> Type Description <code>GetTaskPushNotificationConfigResponse</code> <p>A <code>GetTaskPushNotificationConfigResponse</code> object containing the configuration or an error.</p> <p>Raises:</p> Type Description <code>A2AClientHTTPError</code> <p>If an HTTP error occurs during the request.</p> <code>A2AClientJSONError</code> <p>If the response body cannot be decoded as JSON or validated.</p>"},{"location":"sdk/python/#a2a.client.A2AClient.send_message","title":"<code>send_message(request, *, http_kwargs=None, context=None)</code>  <code>async</code>","text":"<p>Sends a non-streaming message request to the agent.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>SendMessageRequest</code> <p>The <code>SendMessageRequest</code> object containing the message and configuration.</p> required <code>http_kwargs</code> <code>dict[str, Any] | None</code> <p>Optional dictionary of keyword arguments to pass to the underlying httpx.post request.</p> <code>None</code> <code>context</code> <code>ClientCallContext | None</code> <p>The client call context.</p> <code>None</code> <p>Returns:</p> Type Description <code>SendMessageResponse</code> <p>A <code>SendMessageResponse</code> object containing the agent's response (Task or Message) or an error.</p> <p>Raises:</p> Type Description <code>A2AClientHTTPError</code> <p>If an HTTP error occurs during the request.</p> <code>A2AClientJSONError</code> <p>If the response body cannot be decoded as JSON or validated.</p>"},{"location":"sdk/python/#a2a.client.A2AClient.send_message_streaming","title":"<code>send_message_streaming(request, *, http_kwargs=None, context=None)</code>  <code>async</code>","text":"<p>Sends a streaming message request to the agent and yields responses as they arrive.</p> <p>This method uses Server-Sent Events (SSE) to receive a stream of updates from the agent.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>SendStreamingMessageRequest</code> <p>The <code>SendStreamingMessageRequest</code> object containing the message and configuration.</p> required <code>http_kwargs</code> <code>dict[str, Any] | None</code> <p>Optional dictionary of keyword arguments to pass to the underlying httpx.post request. A default <code>timeout=None</code> is set but can be overridden.</p> <code>None</code> <code>context</code> <code>ClientCallContext | None</code> <p>The client call context.</p> <code>None</code> <p>Yields:</p> Type Description <code>AsyncGenerator[SendStreamingMessageResponse]</code> <p><code>SendStreamingMessageResponse</code> objects as they are received in the SSE stream.</p> <code>AsyncGenerator[SendStreamingMessageResponse]</code> <p>These can be Task, Message, TaskStatusUpdateEvent, or TaskArtifactUpdateEvent.</p> <p>Raises:</p> Type Description <code>A2AClientHTTPError</code> <p>If an HTTP or SSE protocol error occurs during the request.</p> <code>A2AClientJSONError</code> <p>If an SSE event data cannot be decoded as JSON or validated.</p>"},{"location":"sdk/python/#a2a.client.A2AClient.set_task_callback","title":"<code>set_task_callback(request, *, http_kwargs=None, context=None)</code>  <code>async</code>","text":"<p>Sets or updates the push notification configuration for a specific task.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>SetTaskPushNotificationConfigRequest</code> <p>The <code>SetTaskPushNotificationConfigRequest</code> object specifying the task ID and configuration.</p> required <code>http_kwargs</code> <code>dict[str, Any] | None</code> <p>Optional dictionary of keyword arguments to pass to the underlying httpx.post request.</p> <code>None</code> <code>context</code> <code>ClientCallContext | None</code> <p>The client call context.</p> <code>None</code> <p>Returns:</p> Type Description <code>SetTaskPushNotificationConfigResponse</code> <p>A <code>SetTaskPushNotificationConfigResponse</code> object containing the confirmation or an error.</p> <p>Raises:</p> Type Description <code>A2AClientHTTPError</code> <p>If an HTTP error occurs during the request.</p> <code>A2AClientJSONError</code> <p>If the response body cannot be decoded as JSON or validated.</p>"},{"location":"sdk/python/#a2a.client.A2AClientError","title":"<code>A2AClientError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for A2A Client errors.</p>"},{"location":"sdk/python/#a2a.client.A2AClientHTTPError","title":"<code>A2AClientHTTPError</code>","text":"<p>               Bases: <code>A2AClientError</code></p> <p>Client exception for HTTP errors received from the server.</p>"},{"location":"sdk/python/#a2a.client.A2AClientHTTPError.message","title":"<code>message = message</code>  <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.client.A2AClientHTTPError.status_code","title":"<code>status_code = status_code</code>  <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.client.A2AClientJSONError","title":"<code>A2AClientJSONError</code>","text":"<p>               Bases: <code>A2AClientError</code></p> <p>Client exception for JSON errors during response parsing or validation.</p>"},{"location":"sdk/python/#a2a.client.A2AClientJSONError.message","title":"<code>message = message</code>  <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.client.A2AClientTimeoutError","title":"<code>A2AClientTimeoutError</code>","text":"<p>               Bases: <code>A2AClientError</code></p> <p>Client exception for timeout errors during a request.</p>"},{"location":"sdk/python/#a2a.client.A2AClientTimeoutError.message","title":"<code>message = message</code>  <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.client.A2AGrpcClient","title":"<code>A2AGrpcClient</code>","text":"<p>Placeholder for A2AGrpcClient when dependencies are not installed.</p>"},{"location":"sdk/python/#a2a.client.AuthInterceptor","title":"<code>AuthInterceptor</code>","text":"<p>               Bases: <code>ClientCallInterceptor</code></p> <p>An interceptor that automatically adds authentication details to requests.</p> <p>Based on the agent's security schemes.</p>"},{"location":"sdk/python/#a2a.client.AuthInterceptor.intercept","title":"<code>intercept(method_name, request_payload, http_kwargs, agent_card, context)</code>  <code>async</code>","text":"<p>Applies authentication headers to the request if credentials are available.</p>"},{"location":"sdk/python/#a2a.client.ClientCallContext","title":"<code>ClientCallContext</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A context passed with each client call, allowing for call-specific.</p> <p>configuration and data passing. Such as authentication details or request deadlines.</p>"},{"location":"sdk/python/#a2a.client.ClientCallContext.state","title":"<code>state = Field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.client.ClientCallInterceptor","title":"<code>ClientCallInterceptor</code>","text":"<p>               Bases: <code>ABC</code></p> <p>An abstract base class for client-side call interceptors.</p> <p>Interceptors can inspect and modify requests before they are sent, which is ideal for concerns like authentication, logging, or tracing.</p>"},{"location":"sdk/python/#a2a.client.ClientCallInterceptor.intercept","title":"<code>intercept(method_name, request_payload, http_kwargs, agent_card, context)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Intercepts a client call before the request is sent.</p> <p>Parameters:</p> Name Type Description Default <code>method_name</code> <code>str</code> <p>The name of the RPC method (e.g., 'message/send').</p> required <code>request_payload</code> <code>dict[str, Any]</code> <p>The JSON RPC request payload dictionary.</p> required <code>http_kwargs</code> <code>dict[str, Any]</code> <p>The keyword arguments for the httpx request.</p> required <code>agent_card</code> <code>AgentCard | None</code> <p>The AgentCard associated with the client.</p> required <code>context</code> <code>ClientCallContext | None</code> <p>The ClientCallContext for this specific call.</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A tuple containing the (potentially modified) request_payload</p> <code>dict[str, Any]</code> <p>and http_kwargs.</p>"},{"location":"sdk/python/#a2a.client.CredentialService","title":"<code>CredentialService</code>","text":"<p>               Bases: <code>ABC</code></p> <p>An abstract service for retrieving credentials.</p>"},{"location":"sdk/python/#a2a.client.CredentialService.get_credentials","title":"<code>get_credentials(security_scheme_name, context)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Retrieves a credential (e.g., token) for a security scheme.</p>"},{"location":"sdk/python/#a2a.client.InMemoryContextCredentialStore","title":"<code>InMemoryContextCredentialStore</code>","text":"<p>               Bases: <code>CredentialService</code></p> <p>A simple in-memory store for session-keyed credentials.</p> <p>This class uses the 'sessionId' from the ClientCallContext state to store and retrieve credentials...</p>"},{"location":"sdk/python/#a2a.client.InMemoryContextCredentialStore.get_credentials","title":"<code>get_credentials(security_scheme_name, context)</code>  <code>async</code>","text":"<p>Retrieves credentials from the in-memory store.</p> <p>Parameters:</p> Name Type Description Default <code>security_scheme_name</code> <code>str</code> <p>The name of the security scheme.</p> required <code>context</code> <code>ClientCallContext | None</code> <p>The client call context.</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>The credential string, or None if not found.</p>"},{"location":"sdk/python/#a2a.client.InMemoryContextCredentialStore.set_credentials","title":"<code>set_credentials(session_id, security_scheme_name, credential)</code>  <code>async</code>","text":"<p>Method to populate the store.</p>"},{"location":"sdk/python/#a2a.client.create_text_message_object","title":"<code>create_text_message_object(role=Role.user, content='')</code>","text":"<p>Create a Message object containing a single TextPart.</p> <p>Parameters:</p> Name Type Description Default <code>role</code> <code>Role</code> <p>The role of the message sender (user or agent). Defaults to Role.user.</p> <code>user</code> <code>content</code> <code>str</code> <p>The text content of the message. Defaults to an empty string.</p> <code>''</code> <p>Returns:</p> Type Description <code>Message</code> <p>A <code>Message</code> object with a new UUID message_id.</p>"},{"location":"sdk/python/#server","title":"Server","text":"<p>Server-side components for implementing an A2A agent.</p>"},{"location":"sdk/python/#types","title":"Types","text":""},{"location":"sdk/python/#a2a.types.A2A","title":"<code>A2A</code>","text":"<p>               Bases: <code>RootModel[Any]</code></p>"},{"location":"sdk/python/#a2a.types.A2A.root","title":"<code>root</code>  <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.types.A2AError","title":"<code>A2AError</code>","text":"<p>               Bases: <code>RootModel[JSONParseError | InvalidRequestError | MethodNotFoundError | InvalidParamsError | InternalError | TaskNotFoundError | TaskNotCancelableError | PushNotificationNotSupportedError | UnsupportedOperationError | ContentTypeNotSupportedError | InvalidAgentResponseError]</code></p>"},{"location":"sdk/python/#a2a.types.A2AError.root","title":"<code>root</code>  <code>instance-attribute</code>","text":"<p>A discriminated union of all standard JSON-RPC and A2A-specific error types.</p>"},{"location":"sdk/python/#a2a.types.A2ARequest","title":"<code>A2ARequest</code>","text":"<p>               Bases: <code>RootModel[SendMessageRequest | SendStreamingMessageRequest | GetTaskRequest | CancelTaskRequest | SetTaskPushNotificationConfigRequest | GetTaskPushNotificationConfigRequest | TaskResubscriptionRequest | ListTaskPushNotificationConfigRequest | DeleteTaskPushNotificationConfigRequest]</code></p>"},{"location":"sdk/python/#a2a.types.A2ARequest.root","title":"<code>root</code>  <code>instance-attribute</code>","text":"<p>A discriminated union representing all possible JSON-RPC 2.0 requests supported by the A2A specification.</p>"},{"location":"sdk/python/#a2a.types.APIKeySecurityScheme","title":"<code>APIKeySecurityScheme</code>","text":"<p>               Bases: <code>A2ABaseModel</code></p> <p>Defines a security scheme using an API key.</p>"},{"location":"sdk/python/#a2a.types.APIKeySecurityScheme.description","title":"<code>description = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>An optional description for the security scheme.</p>"},{"location":"sdk/python/#a2a.types.APIKeySecurityScheme.in_","title":"<code>in_</code>  <code>instance-attribute</code>","text":"<p>The location of the API key.</p>"},{"location":"sdk/python/#a2a.types.APIKeySecurityScheme.model_config","title":"<code>model_config = ConfigDict(validate_by_name=True, validate_by_alias=True, serialize_by_alias=True, alias_generator=to_camel_custom)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.types.APIKeySecurityScheme.name","title":"<code>name</code>  <code>instance-attribute</code>","text":"<p>The name of the header, query, or cookie parameter to be used.</p>"},{"location":"sdk/python/#a2a.types.APIKeySecurityScheme.type","title":"<code>type = 'apiKey'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The type of the security scheme. Must be 'apiKey'.</p>"},{"location":"sdk/python/#a2a.types.AgentCapabilities","title":"<code>AgentCapabilities</code>","text":"<p>               Bases: <code>A2ABaseModel</code></p> <p>Defines optional capabilities supported by an agent.</p>"},{"location":"sdk/python/#a2a.types.AgentCapabilities.extensions","title":"<code>extensions = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A list of protocol extensions supported by the agent.</p>"},{"location":"sdk/python/#a2a.types.AgentCapabilities.model_config","title":"<code>model_config = ConfigDict(validate_by_name=True, validate_by_alias=True, serialize_by_alias=True, alias_generator=to_camel_custom)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.types.AgentCapabilities.push_notifications","title":"<code>push_notifications = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Indicates if the agent supports sending push notifications for asynchronous task updates.</p>"},{"location":"sdk/python/#a2a.types.AgentCapabilities.state_transition_history","title":"<code>state_transition_history = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Indicates if the agent provides a history of state transitions for a task.</p>"},{"location":"sdk/python/#a2a.types.AgentCapabilities.streaming","title":"<code>streaming = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Indicates if the agent supports Server-Sent Events (SSE) for streaming responses.</p>"},{"location":"sdk/python/#a2a.types.AgentCard","title":"<code>AgentCard</code>","text":"<p>               Bases: <code>A2ABaseModel</code></p> <p>The AgentCard is a self-describing manifest for an agent. It provides essential metadata including the agent's identity, capabilities, skills, supported communication methods, and security requirements.</p>"},{"location":"sdk/python/#a2a.types.AgentCard.additional_interfaces","title":"<code>additional_interfaces = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A list of additional supported interfaces (transport and URL combinations). A client can use any of these to communicate with the agent.</p>"},{"location":"sdk/python/#a2a.types.AgentCard.capabilities","title":"<code>capabilities</code>  <code>instance-attribute</code>","text":"<p>A declaration of optional capabilities supported by the agent.</p>"},{"location":"sdk/python/#a2a.types.AgentCard.default_input_modes","title":"<code>default_input_modes</code>  <code>instance-attribute</code>","text":"<p>Default set of supported input MIME types for all skills, which can be overridden on a per-skill basis.</p>"},{"location":"sdk/python/#a2a.types.AgentCard.default_output_modes","title":"<code>default_output_modes</code>  <code>instance-attribute</code>","text":"<p>Default set of supported output MIME types for all skills, which can be overridden on a per-skill basis.</p>"},{"location":"sdk/python/#a2a.types.AgentCard.description","title":"<code>description = Field(..., examples=['Agent that helps users with recipes and cooking.'])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A human-readable description of the agent, assisting users and other agents in understanding its purpose.</p>"},{"location":"sdk/python/#a2a.types.AgentCard.documentation_url","title":"<code>documentation_url = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>An optional URL to the agent's documentation.</p>"},{"location":"sdk/python/#a2a.types.AgentCard.icon_url","title":"<code>icon_url = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>An optional URL to an icon for the agent.</p>"},{"location":"sdk/python/#a2a.types.AgentCard.model_config","title":"<code>model_config = ConfigDict(validate_by_name=True, validate_by_alias=True, serialize_by_alias=True, alias_generator=to_camel_custom)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.types.AgentCard.name","title":"<code>name = Field(..., examples=['Recipe Agent'])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A human-readable name for the agent.</p>"},{"location":"sdk/python/#a2a.types.AgentCard.preferred_transport","title":"<code>preferred_transport = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The transport protocol for the preferred endpoint. Defaults to 'JSONRPC' if not specified.</p>"},{"location":"sdk/python/#a2a.types.AgentCard.protocol_version","title":"<code>protocol_version = '0.2.6'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The version of the A2A protocol this agent supports.</p>"},{"location":"sdk/python/#a2a.types.AgentCard.provider","title":"<code>provider = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Information about the agent's service provider.</p>"},{"location":"sdk/python/#a2a.types.AgentCard.security","title":"<code>security = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A list of security requirement objects that apply to all agent interactions. Each object lists security schemes that can be used. Follows the OpenAPI 3.0 Security Requirement Object.</p>"},{"location":"sdk/python/#a2a.types.AgentCard.security_schemes","title":"<code>security_schemes = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A declaration of the security schemes available to authorize requests. The key is the scheme name. Follows the OpenAPI 3.0 Security Scheme Object.</p>"},{"location":"sdk/python/#a2a.types.AgentCard.skills","title":"<code>skills</code>  <code>instance-attribute</code>","text":"<p>The set of skills, or distinct capabilities, that the agent can perform.</p>"},{"location":"sdk/python/#a2a.types.AgentCard.supports_authenticated_extended_card","title":"<code>supports_authenticated_extended_card = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>If true, the agent can provide an extended agent card with additional details to authenticated users. Defaults to false.</p>"},{"location":"sdk/python/#a2a.types.AgentCard.url","title":"<code>url</code>  <code>instance-attribute</code>","text":"<p>The preferred endpoint URL for interacting with the agent.</p>"},{"location":"sdk/python/#a2a.types.AgentCard.version","title":"<code>version = Field(..., examples=['1.0.0'])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The agent's own version number. The format is defined by the provider.</p>"},{"location":"sdk/python/#a2a.types.AgentExtension","title":"<code>AgentExtension</code>","text":"<p>               Bases: <code>A2ABaseModel</code></p> <p>A declaration of a protocol extension supported by an Agent.</p>"},{"location":"sdk/python/#a2a.types.AgentExtension.description","title":"<code>description = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A human-readable description of how this agent uses the extension.</p>"},{"location":"sdk/python/#a2a.types.AgentExtension.model_config","title":"<code>model_config = ConfigDict(validate_by_name=True, validate_by_alias=True, serialize_by_alias=True, alias_generator=to_camel_custom)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.types.AgentExtension.params","title":"<code>params = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Optional, extension-specific configuration parameters.</p>"},{"location":"sdk/python/#a2a.types.AgentExtension.required","title":"<code>required = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>If true, the client must understand and comply with the extension's requirements to interact with the agent.</p>"},{"location":"sdk/python/#a2a.types.AgentExtension.uri","title":"<code>uri</code>  <code>instance-attribute</code>","text":"<p>The unique URI identifying the extension.</p>"},{"location":"sdk/python/#a2a.types.AgentInterface","title":"<code>AgentInterface</code>","text":"<p>               Bases: <code>A2ABaseModel</code></p> <p>Declares a combination of a target URL and a transport protocol for interacting with the agent.</p>"},{"location":"sdk/python/#a2a.types.AgentInterface.model_config","title":"<code>model_config = ConfigDict(validate_by_name=True, validate_by_alias=True, serialize_by_alias=True, alias_generator=to_camel_custom)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.types.AgentInterface.transport","title":"<code>transport</code>  <code>instance-attribute</code>","text":"<p>The transport protocol supported at this URL. This is a string to allow for future extension. Core supported transports include 'JSONRPC', 'GRPC', and 'HTTP+JSON'.</p>"},{"location":"sdk/python/#a2a.types.AgentInterface.url","title":"<code>url</code>  <code>instance-attribute</code>","text":"<p>The URL where this interface is available.</p>"},{"location":"sdk/python/#a2a.types.AgentProvider","title":"<code>AgentProvider</code>","text":"<p>               Bases: <code>A2ABaseModel</code></p> <p>Represents the service provider of an agent.</p>"},{"location":"sdk/python/#a2a.types.AgentProvider.model_config","title":"<code>model_config = ConfigDict(validate_by_name=True, validate_by_alias=True, serialize_by_alias=True, alias_generator=to_camel_custom)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.types.AgentProvider.organization","title":"<code>organization</code>  <code>instance-attribute</code>","text":"<p>The name of the agent provider's organization.</p>"},{"location":"sdk/python/#a2a.types.AgentProvider.url","title":"<code>url</code>  <code>instance-attribute</code>","text":"<p>A URL for the agent provider's website or relevant documentation.</p>"},{"location":"sdk/python/#a2a.types.AgentSkill","title":"<code>AgentSkill</code>","text":"<p>               Bases: <code>A2ABaseModel</code></p> <p>Represents a distinct capability or function that an agent can perform.</p>"},{"location":"sdk/python/#a2a.types.AgentSkill.description","title":"<code>description</code>  <code>instance-attribute</code>","text":"<p>A detailed description of the skill, intended to help clients or users understand its purpose and functionality.</p>"},{"location":"sdk/python/#a2a.types.AgentSkill.examples","title":"<code>examples = Field(default=None, examples=[['I need a recipe for bread']])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Example prompts or scenarios that this skill can handle. Provides a hint to the client on how to use the skill.</p>"},{"location":"sdk/python/#a2a.types.AgentSkill.id","title":"<code>id</code>  <code>instance-attribute</code>","text":"<p>A unique identifier for the agent's skill.</p>"},{"location":"sdk/python/#a2a.types.AgentSkill.input_modes","title":"<code>input_modes = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The set of supported input MIME types for this skill, overriding the agent's defaults.</p>"},{"location":"sdk/python/#a2a.types.AgentSkill.model_config","title":"<code>model_config = ConfigDict(validate_by_name=True, validate_by_alias=True, serialize_by_alias=True, alias_generator=to_camel_custom)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.types.AgentSkill.name","title":"<code>name</code>  <code>instance-attribute</code>","text":"<p>A human-readable name for the skill.</p>"},{"location":"sdk/python/#a2a.types.AgentSkill.output_modes","title":"<code>output_modes = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The set of supported output MIME types for this skill, overriding the agent's defaults.</p>"},{"location":"sdk/python/#a2a.types.AgentSkill.tags","title":"<code>tags = Field(..., examples=[['cooking', 'customer support', 'billing']])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A set of keywords describing the skill's capabilities.</p>"},{"location":"sdk/python/#a2a.types.Artifact","title":"<code>Artifact</code>","text":"<p>               Bases: <code>A2ABaseModel</code></p> <p>Represents a file, data structure, or other resource generated by an agent during a task.</p>"},{"location":"sdk/python/#a2a.types.Artifact.artifact_id","title":"<code>artifact_id</code>  <code>instance-attribute</code>","text":"<p>A unique identifier for the artifact within the scope of the task.</p>"},{"location":"sdk/python/#a2a.types.Artifact.description","title":"<code>description = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>An optional, human-readable description of the artifact.</p>"},{"location":"sdk/python/#a2a.types.Artifact.extensions","title":"<code>extensions = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The URIs of extensions that are relevant to this artifact.</p>"},{"location":"sdk/python/#a2a.types.Artifact.metadata","title":"<code>metadata = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Optional metadata for extensions. The key is an extension-specific identifier.</p>"},{"location":"sdk/python/#a2a.types.Artifact.model_config","title":"<code>model_config = ConfigDict(validate_by_name=True, validate_by_alias=True, serialize_by_alias=True, alias_generator=to_camel_custom)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.types.Artifact.name","title":"<code>name = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>An optional, human-readable name for the artifact.</p>"},{"location":"sdk/python/#a2a.types.Artifact.parts","title":"<code>parts</code>  <code>instance-attribute</code>","text":"<p>An array of content parts that make up the artifact.</p>"},{"location":"sdk/python/#a2a.types.AuthorizationCodeOAuthFlow","title":"<code>AuthorizationCodeOAuthFlow</code>","text":"<p>               Bases: <code>A2ABaseModel</code></p> <p>Defines configuration details for the OAuth 2.0 Authorization Code flow.</p>"},{"location":"sdk/python/#a2a.types.AuthorizationCodeOAuthFlow.authorization_url","title":"<code>authorization_url</code>  <code>instance-attribute</code>","text":"<p>The authorization URL to be used for this flow. This MUST be a URL and use TLS.</p>"},{"location":"sdk/python/#a2a.types.AuthorizationCodeOAuthFlow.model_config","title":"<code>model_config = ConfigDict(validate_by_name=True, validate_by_alias=True, serialize_by_alias=True, alias_generator=to_camel_custom)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.types.AuthorizationCodeOAuthFlow.refresh_url","title":"<code>refresh_url = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The URL to be used for obtaining refresh tokens. This MUST be a URL and use TLS.</p>"},{"location":"sdk/python/#a2a.types.AuthorizationCodeOAuthFlow.scopes","title":"<code>scopes</code>  <code>instance-attribute</code>","text":"<p>The available scopes for the OAuth2 security scheme. A map between the scope name and a short description for it.</p>"},{"location":"sdk/python/#a2a.types.AuthorizationCodeOAuthFlow.token_url","title":"<code>token_url</code>  <code>instance-attribute</code>","text":"<p>The token URL to be used for this flow. This MUST be a URL and use TLS.</p>"},{"location":"sdk/python/#a2a.types.CancelTaskRequest","title":"<code>CancelTaskRequest</code>","text":"<p>               Bases: <code>A2ABaseModel</code></p> <p>Represents a JSON-RPC request for the <code>tasks/cancel</code> method.</p>"},{"location":"sdk/python/#a2a.types.CancelTaskRequest.id","title":"<code>id</code>  <code>instance-attribute</code>","text":"<p>The identifier for this request.</p>"},{"location":"sdk/python/#a2a.types.CancelTaskRequest.jsonrpc","title":"<code>jsonrpc = '2.0'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The version of the JSON-RPC protocol. MUST be exactly \"2.0\".</p>"},{"location":"sdk/python/#a2a.types.CancelTaskRequest.method","title":"<code>method = 'tasks/cancel'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The method name. Must be 'tasks/cancel'.</p>"},{"location":"sdk/python/#a2a.types.CancelTaskRequest.model_config","title":"<code>model_config = ConfigDict(validate_by_name=True, validate_by_alias=True, serialize_by_alias=True, alias_generator=to_camel_custom)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.types.CancelTaskRequest.params","title":"<code>params</code>  <code>instance-attribute</code>","text":"<p>The parameters identifying the task to cancel.</p>"},{"location":"sdk/python/#a2a.types.CancelTaskResponse","title":"<code>CancelTaskResponse</code>","text":"<p>               Bases: <code>RootModel[JSONRPCErrorResponse | CancelTaskSuccessResponse]</code></p>"},{"location":"sdk/python/#a2a.types.CancelTaskResponse.root","title":"<code>root</code>  <code>instance-attribute</code>","text":"<p>Represents a JSON-RPC response for the <code>tasks/cancel</code> method.</p>"},{"location":"sdk/python/#a2a.types.CancelTaskSuccessResponse","title":"<code>CancelTaskSuccessResponse</code>","text":"<p>               Bases: <code>A2ABaseModel</code></p> <p>Represents a successful JSON-RPC response for the <code>tasks/cancel</code> method.</p>"},{"location":"sdk/python/#a2a.types.CancelTaskSuccessResponse.id","title":"<code>id = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The identifier established by the client.</p>"},{"location":"sdk/python/#a2a.types.CancelTaskSuccessResponse.jsonrpc","title":"<code>jsonrpc = '2.0'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The version of the JSON-RPC protocol. MUST be exactly \"2.0\".</p>"},{"location":"sdk/python/#a2a.types.CancelTaskSuccessResponse.model_config","title":"<code>model_config = ConfigDict(validate_by_name=True, validate_by_alias=True, serialize_by_alias=True, alias_generator=to_camel_custom)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.types.CancelTaskSuccessResponse.result","title":"<code>result</code>  <code>instance-attribute</code>","text":"<p>The result, containing the final state of the canceled Task object.</p>"},{"location":"sdk/python/#a2a.types.ClientCredentialsOAuthFlow","title":"<code>ClientCredentialsOAuthFlow</code>","text":"<p>               Bases: <code>A2ABaseModel</code></p> <p>Defines configuration details for the OAuth 2.0 Client Credentials flow.</p>"},{"location":"sdk/python/#a2a.types.ClientCredentialsOAuthFlow.model_config","title":"<code>model_config = ConfigDict(validate_by_name=True, validate_by_alias=True, serialize_by_alias=True, alias_generator=to_camel_custom)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.types.ClientCredentialsOAuthFlow.refresh_url","title":"<code>refresh_url = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The URL to be used for obtaining refresh tokens. This MUST be a URL.</p>"},{"location":"sdk/python/#a2a.types.ClientCredentialsOAuthFlow.scopes","title":"<code>scopes</code>  <code>instance-attribute</code>","text":"<p>The available scopes for the OAuth2 security scheme. A map between the scope name and a short description for it.</p>"},{"location":"sdk/python/#a2a.types.ClientCredentialsOAuthFlow.token_url","title":"<code>token_url</code>  <code>instance-attribute</code>","text":"<p>The token URL to be used for this flow. This MUST be a URL.</p>"},{"location":"sdk/python/#a2a.types.ContentTypeNotSupportedError","title":"<code>ContentTypeNotSupportedError</code>","text":"<p>               Bases: <code>A2ABaseModel</code></p> <p>An A2A-specific error indicating an incompatibility between the requested content types and the agent's capabilities.</p>"},{"location":"sdk/python/#a2a.types.ContentTypeNotSupportedError.code","title":"<code>code = -32005</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The error code for an unsupported content type.</p>"},{"location":"sdk/python/#a2a.types.ContentTypeNotSupportedError.data","title":"<code>data = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A primitive or structured value containing additional information about the error. This may be omitted.</p>"},{"location":"sdk/python/#a2a.types.ContentTypeNotSupportedError.message","title":"<code>message = 'Incompatible content types'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The error message.</p>"},{"location":"sdk/python/#a2a.types.ContentTypeNotSupportedError.model_config","title":"<code>model_config = ConfigDict(validate_by_name=True, validate_by_alias=True, serialize_by_alias=True, alias_generator=to_camel_custom)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.types.DataPart","title":"<code>DataPart</code>","text":"<p>               Bases: <code>A2ABaseModel</code></p> <p>Represents a structured data segment (e.g., JSON) within a message or artifact.</p>"},{"location":"sdk/python/#a2a.types.DataPart.data","title":"<code>data</code>  <code>instance-attribute</code>","text":"<p>The structured data content.</p>"},{"location":"sdk/python/#a2a.types.DataPart.kind","title":"<code>kind = 'data'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The type of this part, used as a discriminator. Always 'data'.</p>"},{"location":"sdk/python/#a2a.types.DataPart.metadata","title":"<code>metadata = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Optional metadata associated with this part.</p>"},{"location":"sdk/python/#a2a.types.DataPart.model_config","title":"<code>model_config = ConfigDict(validate_by_name=True, validate_by_alias=True, serialize_by_alias=True, alias_generator=to_camel_custom)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.types.DeleteTaskPushNotificationConfigParams","title":"<code>DeleteTaskPushNotificationConfigParams</code>","text":"<p>               Bases: <code>A2ABaseModel</code></p> <p>Defines parameters for deleting a specific push notification configuration for a task.</p>"},{"location":"sdk/python/#a2a.types.DeleteTaskPushNotificationConfigParams.id","title":"<code>id</code>  <code>instance-attribute</code>","text":"<p>The unique identifier of the task.</p>"},{"location":"sdk/python/#a2a.types.DeleteTaskPushNotificationConfigParams.metadata","title":"<code>metadata = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Optional metadata associated with the request.</p>"},{"location":"sdk/python/#a2a.types.DeleteTaskPushNotificationConfigParams.model_config","title":"<code>model_config = ConfigDict(validate_by_name=True, validate_by_alias=True, serialize_by_alias=True, alias_generator=to_camel_custom)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.types.DeleteTaskPushNotificationConfigParams.push_notification_config_id","title":"<code>push_notification_config_id</code>  <code>instance-attribute</code>","text":"<p>The ID of the push notification configuration to delete.</p>"},{"location":"sdk/python/#a2a.types.DeleteTaskPushNotificationConfigRequest","title":"<code>DeleteTaskPushNotificationConfigRequest</code>","text":"<p>               Bases: <code>A2ABaseModel</code></p> <p>Represents a JSON-RPC request for the <code>tasks/pushNotificationConfig/delete</code> method.</p>"},{"location":"sdk/python/#a2a.types.DeleteTaskPushNotificationConfigRequest.id","title":"<code>id</code>  <code>instance-attribute</code>","text":"<p>The identifier for this request.</p>"},{"location":"sdk/python/#a2a.types.DeleteTaskPushNotificationConfigRequest.jsonrpc","title":"<code>jsonrpc = '2.0'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The version of the JSON-RPC protocol. MUST be exactly \"2.0\".</p>"},{"location":"sdk/python/#a2a.types.DeleteTaskPushNotificationConfigRequest.method","title":"<code>method = 'tasks/pushNotificationConfig/delete'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The method name. Must be 'tasks/pushNotificationConfig/delete'.</p>"},{"location":"sdk/python/#a2a.types.DeleteTaskPushNotificationConfigRequest.model_config","title":"<code>model_config = ConfigDict(validate_by_name=True, validate_by_alias=True, serialize_by_alias=True, alias_generator=to_camel_custom)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.types.DeleteTaskPushNotificationConfigRequest.params","title":"<code>params</code>  <code>instance-attribute</code>","text":"<p>The parameters identifying the push notification configuration to delete.</p>"},{"location":"sdk/python/#a2a.types.DeleteTaskPushNotificationConfigResponse","title":"<code>DeleteTaskPushNotificationConfigResponse</code>","text":"<p>               Bases: <code>RootModel[JSONRPCErrorResponse | DeleteTaskPushNotificationConfigSuccessResponse]</code></p>"},{"location":"sdk/python/#a2a.types.DeleteTaskPushNotificationConfigResponse.root","title":"<code>root</code>  <code>instance-attribute</code>","text":"<p>Represents a JSON-RPC response for the <code>tasks/pushNotificationConfig/delete</code> method.</p>"},{"location":"sdk/python/#a2a.types.DeleteTaskPushNotificationConfigSuccessResponse","title":"<code>DeleteTaskPushNotificationConfigSuccessResponse</code>","text":"<p>               Bases: <code>A2ABaseModel</code></p> <p>Represents a successful JSON-RPC response for the <code>tasks/pushNotificationConfig/delete</code> method.</p>"},{"location":"sdk/python/#a2a.types.DeleteTaskPushNotificationConfigSuccessResponse.id","title":"<code>id = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The identifier established by the client.</p>"},{"location":"sdk/python/#a2a.types.DeleteTaskPushNotificationConfigSuccessResponse.jsonrpc","title":"<code>jsonrpc = '2.0'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The version of the JSON-RPC protocol. MUST be exactly \"2.0\".</p>"},{"location":"sdk/python/#a2a.types.DeleteTaskPushNotificationConfigSuccessResponse.model_config","title":"<code>model_config = ConfigDict(validate_by_name=True, validate_by_alias=True, serialize_by_alias=True, alias_generator=to_camel_custom)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.types.DeleteTaskPushNotificationConfigSuccessResponse.result","title":"<code>result</code>  <code>instance-attribute</code>","text":"<p>The result is null on successful deletion.</p>"},{"location":"sdk/python/#a2a.types.FileBase","title":"<code>FileBase</code>","text":"<p>               Bases: <code>A2ABaseModel</code></p> <p>Defines base properties for a file.</p>"},{"location":"sdk/python/#a2a.types.FileBase.mime_type","title":"<code>mime_type = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The MIME type of the file (e.g., \"application/pdf\").</p>"},{"location":"sdk/python/#a2a.types.FileBase.model_config","title":"<code>model_config = ConfigDict(validate_by_name=True, validate_by_alias=True, serialize_by_alias=True, alias_generator=to_camel_custom)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.types.FileBase.name","title":"<code>name = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>An optional name for the file (e.g., \"document.pdf\").</p>"},{"location":"sdk/python/#a2a.types.FilePart","title":"<code>FilePart</code>","text":"<p>               Bases: <code>A2ABaseModel</code></p> <p>Represents a file segment within a message or artifact. The file content can be provided either directly as bytes or as a URI.</p>"},{"location":"sdk/python/#a2a.types.FilePart.file","title":"<code>file</code>  <code>instance-attribute</code>","text":"<p>The file content, represented as either a URI or as base64-encoded bytes.</p>"},{"location":"sdk/python/#a2a.types.FilePart.kind","title":"<code>kind = 'file'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The type of this part, used as a discriminator. Always 'file'.</p>"},{"location":"sdk/python/#a2a.types.FilePart.metadata","title":"<code>metadata = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Optional metadata associated with this part.</p>"},{"location":"sdk/python/#a2a.types.FilePart.model_config","title":"<code>model_config = ConfigDict(validate_by_name=True, validate_by_alias=True, serialize_by_alias=True, alias_generator=to_camel_custom)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.types.FileWithBytes","title":"<code>FileWithBytes</code>","text":"<p>               Bases: <code>A2ABaseModel</code></p> <p>Represents a file with its content provided directly as a base64-encoded string.</p>"},{"location":"sdk/python/#a2a.types.FileWithBytes.bytes","title":"<code>bytes</code>  <code>instance-attribute</code>","text":"<p>The base64-encoded content of the file.</p>"},{"location":"sdk/python/#a2a.types.FileWithBytes.mime_type","title":"<code>mime_type = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The MIME type of the file (e.g., \"application/pdf\").</p>"},{"location":"sdk/python/#a2a.types.FileWithBytes.model_config","title":"<code>model_config = ConfigDict(validate_by_name=True, validate_by_alias=True, serialize_by_alias=True, alias_generator=to_camel_custom)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.types.FileWithBytes.name","title":"<code>name = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>An optional name for the file (e.g., \"document.pdf\").</p>"},{"location":"sdk/python/#a2a.types.FileWithUri","title":"<code>FileWithUri</code>","text":"<p>               Bases: <code>A2ABaseModel</code></p> <p>Represents a file with its content located at a specific URI.</p>"},{"location":"sdk/python/#a2a.types.FileWithUri.mime_type","title":"<code>mime_type = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The MIME type of the file (e.g., \"application/pdf\").</p>"},{"location":"sdk/python/#a2a.types.FileWithUri.model_config","title":"<code>model_config = ConfigDict(validate_by_name=True, validate_by_alias=True, serialize_by_alias=True, alias_generator=to_camel_custom)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.types.FileWithUri.name","title":"<code>name = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>An optional name for the file (e.g., \"document.pdf\").</p>"},{"location":"sdk/python/#a2a.types.FileWithUri.uri","title":"<code>uri</code>  <code>instance-attribute</code>","text":"<p>A URL pointing to the file's content.</p>"},{"location":"sdk/python/#a2a.types.GetTaskPushNotificationConfigParams","title":"<code>GetTaskPushNotificationConfigParams</code>","text":"<p>               Bases: <code>A2ABaseModel</code></p> <p>Defines parameters for fetching a specific push notification configuration for a task.</p>"},{"location":"sdk/python/#a2a.types.GetTaskPushNotificationConfigParams.id","title":"<code>id</code>  <code>instance-attribute</code>","text":"<p>The unique identifier of the task.</p>"},{"location":"sdk/python/#a2a.types.GetTaskPushNotificationConfigParams.metadata","title":"<code>metadata = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Optional metadata associated with the request.</p>"},{"location":"sdk/python/#a2a.types.GetTaskPushNotificationConfigParams.model_config","title":"<code>model_config = ConfigDict(validate_by_name=True, validate_by_alias=True, serialize_by_alias=True, alias_generator=to_camel_custom)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.types.GetTaskPushNotificationConfigParams.push_notification_config_id","title":"<code>push_notification_config_id = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The ID of the push notification configuration to retrieve.</p>"},{"location":"sdk/python/#a2a.types.GetTaskPushNotificationConfigRequest","title":"<code>GetTaskPushNotificationConfigRequest</code>","text":"<p>               Bases: <code>A2ABaseModel</code></p> <p>Represents a JSON-RPC request for the <code>tasks/pushNotificationConfig/get</code> method.</p>"},{"location":"sdk/python/#a2a.types.GetTaskPushNotificationConfigRequest.id","title":"<code>id</code>  <code>instance-attribute</code>","text":"<p>The identifier for this request.</p>"},{"location":"sdk/python/#a2a.types.GetTaskPushNotificationConfigRequest.jsonrpc","title":"<code>jsonrpc = '2.0'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The version of the JSON-RPC protocol. MUST be exactly \"2.0\".</p>"},{"location":"sdk/python/#a2a.types.GetTaskPushNotificationConfigRequest.method","title":"<code>method = 'tasks/pushNotificationConfig/get'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The method name. Must be 'tasks/pushNotificationConfig/get'.</p>"},{"location":"sdk/python/#a2a.types.GetTaskPushNotificationConfigRequest.model_config","title":"<code>model_config = ConfigDict(validate_by_name=True, validate_by_alias=True, serialize_by_alias=True, alias_generator=to_camel_custom)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.types.GetTaskPushNotificationConfigRequest.params","title":"<code>params</code>  <code>instance-attribute</code>","text":"<p>The parameters for getting a push notification configuration.</p>"},{"location":"sdk/python/#a2a.types.GetTaskPushNotificationConfigResponse","title":"<code>GetTaskPushNotificationConfigResponse</code>","text":"<p>               Bases: <code>RootModel[JSONRPCErrorResponse | GetTaskPushNotificationConfigSuccessResponse]</code></p>"},{"location":"sdk/python/#a2a.types.GetTaskPushNotificationConfigResponse.root","title":"<code>root</code>  <code>instance-attribute</code>","text":"<p>Represents a JSON-RPC response for the <code>tasks/pushNotificationConfig/get</code> method.</p>"},{"location":"sdk/python/#a2a.types.GetTaskPushNotificationConfigSuccessResponse","title":"<code>GetTaskPushNotificationConfigSuccessResponse</code>","text":"<p>               Bases: <code>A2ABaseModel</code></p> <p>Represents a successful JSON-RPC response for the <code>tasks/pushNotificationConfig/get</code> method.</p>"},{"location":"sdk/python/#a2a.types.GetTaskPushNotificationConfigSuccessResponse.id","title":"<code>id = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The identifier established by the client.</p>"},{"location":"sdk/python/#a2a.types.GetTaskPushNotificationConfigSuccessResponse.jsonrpc","title":"<code>jsonrpc = '2.0'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The version of the JSON-RPC protocol. MUST be exactly \"2.0\".</p>"},{"location":"sdk/python/#a2a.types.GetTaskPushNotificationConfigSuccessResponse.model_config","title":"<code>model_config = ConfigDict(validate_by_name=True, validate_by_alias=True, serialize_by_alias=True, alias_generator=to_camel_custom)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.types.GetTaskPushNotificationConfigSuccessResponse.result","title":"<code>result</code>  <code>instance-attribute</code>","text":"<p>The result, containing the requested push notification configuration.</p>"},{"location":"sdk/python/#a2a.types.GetTaskRequest","title":"<code>GetTaskRequest</code>","text":"<p>               Bases: <code>A2ABaseModel</code></p> <p>Represents a JSON-RPC request for the <code>tasks/get</code> method.</p>"},{"location":"sdk/python/#a2a.types.GetTaskRequest.id","title":"<code>id</code>  <code>instance-attribute</code>","text":"<p>The identifier for this request.</p>"},{"location":"sdk/python/#a2a.types.GetTaskRequest.jsonrpc","title":"<code>jsonrpc = '2.0'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The version of the JSON-RPC protocol. MUST be exactly \"2.0\".</p>"},{"location":"sdk/python/#a2a.types.GetTaskRequest.method","title":"<code>method = 'tasks/get'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The method name. Must be 'tasks/get'.</p>"},{"location":"sdk/python/#a2a.types.GetTaskRequest.model_config","title":"<code>model_config = ConfigDict(validate_by_name=True, validate_by_alias=True, serialize_by_alias=True, alias_generator=to_camel_custom)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.types.GetTaskRequest.params","title":"<code>params</code>  <code>instance-attribute</code>","text":"<p>The parameters for querying a task.</p>"},{"location":"sdk/python/#a2a.types.GetTaskResponse","title":"<code>GetTaskResponse</code>","text":"<p>               Bases: <code>RootModel[JSONRPCErrorResponse | GetTaskSuccessResponse]</code></p>"},{"location":"sdk/python/#a2a.types.GetTaskResponse.root","title":"<code>root</code>  <code>instance-attribute</code>","text":"<p>Represents a JSON-RPC response for the <code>tasks/get</code> method.</p>"},{"location":"sdk/python/#a2a.types.GetTaskSuccessResponse","title":"<code>GetTaskSuccessResponse</code>","text":"<p>               Bases: <code>A2ABaseModel</code></p> <p>Represents a successful JSON-RPC response for the <code>tasks/get</code> method.</p>"},{"location":"sdk/python/#a2a.types.GetTaskSuccessResponse.id","title":"<code>id = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The identifier established by the client.</p>"},{"location":"sdk/python/#a2a.types.GetTaskSuccessResponse.jsonrpc","title":"<code>jsonrpc = '2.0'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The version of the JSON-RPC protocol. MUST be exactly \"2.0\".</p>"},{"location":"sdk/python/#a2a.types.GetTaskSuccessResponse.model_config","title":"<code>model_config = ConfigDict(validate_by_name=True, validate_by_alias=True, serialize_by_alias=True, alias_generator=to_camel_custom)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.types.GetTaskSuccessResponse.result","title":"<code>result</code>  <code>instance-attribute</code>","text":"<p>The result, containing the requested Task object.</p>"},{"location":"sdk/python/#a2a.types.HTTPAuthSecurityScheme","title":"<code>HTTPAuthSecurityScheme</code>","text":"<p>               Bases: <code>A2ABaseModel</code></p> <p>Defines a security scheme using HTTP authentication.</p>"},{"location":"sdk/python/#a2a.types.HTTPAuthSecurityScheme.bearer_format","title":"<code>bearer_format = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A hint to the client to identify how the bearer token is formatted (e.g., \"JWT\"). This is primarily for documentation purposes.</p>"},{"location":"sdk/python/#a2a.types.HTTPAuthSecurityScheme.description","title":"<code>description = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>An optional description for the security scheme.</p>"},{"location":"sdk/python/#a2a.types.HTTPAuthSecurityScheme.model_config","title":"<code>model_config = ConfigDict(validate_by_name=True, validate_by_alias=True, serialize_by_alias=True, alias_generator=to_camel_custom)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.types.HTTPAuthSecurityScheme.scheme","title":"<code>scheme</code>  <code>instance-attribute</code>","text":"<p>The name of the HTTP Authentication scheme to be used in the Authorization header, as defined in RFC7235 (e.g., \"Bearer\"). This value should be registered in the IANA Authentication Scheme registry.</p>"},{"location":"sdk/python/#a2a.types.HTTPAuthSecurityScheme.type","title":"<code>type = 'http'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The type of the security scheme. Must be 'http'.</p>"},{"location":"sdk/python/#a2a.types.ImplicitOAuthFlow","title":"<code>ImplicitOAuthFlow</code>","text":"<p>               Bases: <code>A2ABaseModel</code></p> <p>Defines configuration details for the OAuth 2.0 Implicit flow.</p>"},{"location":"sdk/python/#a2a.types.ImplicitOAuthFlow.authorization_url","title":"<code>authorization_url</code>  <code>instance-attribute</code>","text":"<p>The authorization URL to be used for this flow. This MUST be a URL.</p>"},{"location":"sdk/python/#a2a.types.ImplicitOAuthFlow.model_config","title":"<code>model_config = ConfigDict(validate_by_name=True, validate_by_alias=True, serialize_by_alias=True, alias_generator=to_camel_custom)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.types.ImplicitOAuthFlow.refresh_url","title":"<code>refresh_url = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The URL to be used for obtaining refresh tokens. This MUST be a URL.</p>"},{"location":"sdk/python/#a2a.types.ImplicitOAuthFlow.scopes","title":"<code>scopes</code>  <code>instance-attribute</code>","text":"<p>The available scopes for the OAuth2 security scheme. A map between the scope name and a short description for it.</p>"},{"location":"sdk/python/#a2a.types.In","title":"<code>In</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>The location of the API key.</p>"},{"location":"sdk/python/#a2a.types.In.cookie","title":"<code>cookie = 'cookie'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.types.In.header","title":"<code>header = 'header'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.types.In.query","title":"<code>query = 'query'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.types.InternalError","title":"<code>InternalError</code>","text":"<p>               Bases: <code>A2ABaseModel</code></p> <p>An error indicating an internal error on the server.</p>"},{"location":"sdk/python/#a2a.types.InternalError.code","title":"<code>code = -32603</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The error code for an internal server error.</p>"},{"location":"sdk/python/#a2a.types.InternalError.data","title":"<code>data = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A primitive or structured value containing additional information about the error. This may be omitted.</p>"},{"location":"sdk/python/#a2a.types.InternalError.message","title":"<code>message = 'Internal error'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The error message.</p>"},{"location":"sdk/python/#a2a.types.InternalError.model_config","title":"<code>model_config = ConfigDict(validate_by_name=True, validate_by_alias=True, serialize_by_alias=True, alias_generator=to_camel_custom)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.types.InvalidAgentResponseError","title":"<code>InvalidAgentResponseError</code>","text":"<p>               Bases: <code>A2ABaseModel</code></p> <p>An A2A-specific error indicating that the agent returned a response that does not conform to the specification for the current method.</p>"},{"location":"sdk/python/#a2a.types.InvalidAgentResponseError.code","title":"<code>code = -32006</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The error code for an invalid agent response.</p>"},{"location":"sdk/python/#a2a.types.InvalidAgentResponseError.data","title":"<code>data = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A primitive or structured value containing additional information about the error. This may be omitted.</p>"},{"location":"sdk/python/#a2a.types.InvalidAgentResponseError.message","title":"<code>message = 'Invalid agent response'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The error message.</p>"},{"location":"sdk/python/#a2a.types.InvalidAgentResponseError.model_config","title":"<code>model_config = ConfigDict(validate_by_name=True, validate_by_alias=True, serialize_by_alias=True, alias_generator=to_camel_custom)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.types.InvalidParamsError","title":"<code>InvalidParamsError</code>","text":"<p>               Bases: <code>A2ABaseModel</code></p> <p>An error indicating that the method parameters are invalid.</p>"},{"location":"sdk/python/#a2a.types.InvalidParamsError.code","title":"<code>code = -32602</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The error code for an invalid parameters error.</p>"},{"location":"sdk/python/#a2a.types.InvalidParamsError.data","title":"<code>data = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A primitive or structured value containing additional information about the error. This may be omitted.</p>"},{"location":"sdk/python/#a2a.types.InvalidParamsError.message","title":"<code>message = 'Invalid parameters'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The error message.</p>"},{"location":"sdk/python/#a2a.types.InvalidParamsError.model_config","title":"<code>model_config = ConfigDict(validate_by_name=True, validate_by_alias=True, serialize_by_alias=True, alias_generator=to_camel_custom)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.types.InvalidRequestError","title":"<code>InvalidRequestError</code>","text":"<p>               Bases: <code>A2ABaseModel</code></p> <p>An error indicating that the JSON sent is not a valid Request object.</p>"},{"location":"sdk/python/#a2a.types.InvalidRequestError.code","title":"<code>code = -32600</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The error code for an invalid request.</p>"},{"location":"sdk/python/#a2a.types.InvalidRequestError.data","title":"<code>data = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A primitive or structured value containing additional information about the error. This may be omitted.</p>"},{"location":"sdk/python/#a2a.types.InvalidRequestError.message","title":"<code>message = 'Request payload validation error'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The error message.</p>"},{"location":"sdk/python/#a2a.types.InvalidRequestError.model_config","title":"<code>model_config = ConfigDict(validate_by_name=True, validate_by_alias=True, serialize_by_alias=True, alias_generator=to_camel_custom)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.types.JSONParseError","title":"<code>JSONParseError</code>","text":"<p>               Bases: <code>A2ABaseModel</code></p> <p>An error indicating that the server received invalid JSON.</p>"},{"location":"sdk/python/#a2a.types.JSONParseError.code","title":"<code>code = -32700</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The error code for a JSON parse error.</p>"},{"location":"sdk/python/#a2a.types.JSONParseError.data","title":"<code>data = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A primitive or structured value containing additional information about the error. This may be omitted.</p>"},{"location":"sdk/python/#a2a.types.JSONParseError.message","title":"<code>message = 'Invalid JSON payload'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The error message.</p>"},{"location":"sdk/python/#a2a.types.JSONParseError.model_config","title":"<code>model_config = ConfigDict(validate_by_name=True, validate_by_alias=True, serialize_by_alias=True, alias_generator=to_camel_custom)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.types.JSONRPCError","title":"<code>JSONRPCError</code>","text":"<p>               Bases: <code>A2ABaseModel</code></p> <p>Represents a JSON-RPC 2.0 Error object, included in an error response.</p>"},{"location":"sdk/python/#a2a.types.JSONRPCError.code","title":"<code>code</code>  <code>instance-attribute</code>","text":"<p>A number that indicates the error type that occurred.</p>"},{"location":"sdk/python/#a2a.types.JSONRPCError.data","title":"<code>data = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A primitive or structured value containing additional information about the error. This may be omitted.</p>"},{"location":"sdk/python/#a2a.types.JSONRPCError.message","title":"<code>message</code>  <code>instance-attribute</code>","text":"<p>A string providing a short description of the error.</p>"},{"location":"sdk/python/#a2a.types.JSONRPCError.model_config","title":"<code>model_config = ConfigDict(validate_by_name=True, validate_by_alias=True, serialize_by_alias=True, alias_generator=to_camel_custom)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.types.JSONRPCErrorResponse","title":"<code>JSONRPCErrorResponse</code>","text":"<p>               Bases: <code>A2ABaseModel</code></p> <p>Represents a JSON-RPC 2.0 Error Response object.</p>"},{"location":"sdk/python/#a2a.types.JSONRPCErrorResponse.error","title":"<code>error</code>  <code>instance-attribute</code>","text":"<p>An object describing the error that occurred.</p>"},{"location":"sdk/python/#a2a.types.JSONRPCErrorResponse.id","title":"<code>id = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The identifier established by the client.</p>"},{"location":"sdk/python/#a2a.types.JSONRPCErrorResponse.jsonrpc","title":"<code>jsonrpc = '2.0'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The version of the JSON-RPC protocol. MUST be exactly \"2.0\".</p>"},{"location":"sdk/python/#a2a.types.JSONRPCErrorResponse.model_config","title":"<code>model_config = ConfigDict(validate_by_name=True, validate_by_alias=True, serialize_by_alias=True, alias_generator=to_camel_custom)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.types.JSONRPCMessage","title":"<code>JSONRPCMessage</code>","text":"<p>               Bases: <code>A2ABaseModel</code></p> <p>Defines the base structure for any JSON-RPC 2.0 request, response, or notification.</p>"},{"location":"sdk/python/#a2a.types.JSONRPCMessage.id","title":"<code>id = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A unique identifier established by the client. It must be a String, a Number, or null. The server must reply with the same value in the response. This property is omitted for notifications.</p>"},{"location":"sdk/python/#a2a.types.JSONRPCMessage.jsonrpc","title":"<code>jsonrpc = '2.0'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The version of the JSON-RPC protocol. MUST be exactly \"2.0\".</p>"},{"location":"sdk/python/#a2a.types.JSONRPCMessage.model_config","title":"<code>model_config = ConfigDict(validate_by_name=True, validate_by_alias=True, serialize_by_alias=True, alias_generator=to_camel_custom)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.types.JSONRPCRequest","title":"<code>JSONRPCRequest</code>","text":"<p>               Bases: <code>A2ABaseModel</code></p> <p>Represents a JSON-RPC 2.0 Request object.</p>"},{"location":"sdk/python/#a2a.types.JSONRPCRequest.id","title":"<code>id = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A unique identifier established by the client. It must be a String, a Number, or null. The server must reply with the same value in the response. This property is omitted for notifications.</p>"},{"location":"sdk/python/#a2a.types.JSONRPCRequest.jsonrpc","title":"<code>jsonrpc = '2.0'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The version of the JSON-RPC protocol. MUST be exactly \"2.0\".</p>"},{"location":"sdk/python/#a2a.types.JSONRPCRequest.method","title":"<code>method</code>  <code>instance-attribute</code>","text":"<p>A string containing the name of the method to be invoked.</p>"},{"location":"sdk/python/#a2a.types.JSONRPCRequest.model_config","title":"<code>model_config = ConfigDict(validate_by_name=True, validate_by_alias=True, serialize_by_alias=True, alias_generator=to_camel_custom)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.types.JSONRPCRequest.params","title":"<code>params = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A structured value holding the parameter values to be used during the method invocation.</p>"},{"location":"sdk/python/#a2a.types.JSONRPCResponse","title":"<code>JSONRPCResponse</code>","text":"<p>               Bases: <code>RootModel[JSONRPCErrorResponse | SendMessageSuccessResponse | SendStreamingMessageSuccessResponse | GetTaskSuccessResponse | CancelTaskSuccessResponse | SetTaskPushNotificationConfigSuccessResponse | GetTaskPushNotificationConfigSuccessResponse | ListTaskPushNotificationConfigSuccessResponse | DeleteTaskPushNotificationConfigSuccessResponse]</code></p>"},{"location":"sdk/python/#a2a.types.JSONRPCResponse.root","title":"<code>root</code>  <code>instance-attribute</code>","text":"<p>A discriminated union representing all possible JSON-RPC 2.0 responses for the A2A specification methods.</p>"},{"location":"sdk/python/#a2a.types.JSONRPCSuccessResponse","title":"<code>JSONRPCSuccessResponse</code>","text":"<p>               Bases: <code>A2ABaseModel</code></p> <p>Represents a successful JSON-RPC 2.0 Response object.</p>"},{"location":"sdk/python/#a2a.types.JSONRPCSuccessResponse.id","title":"<code>id = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The identifier established by the client.</p>"},{"location":"sdk/python/#a2a.types.JSONRPCSuccessResponse.jsonrpc","title":"<code>jsonrpc = '2.0'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The version of the JSON-RPC protocol. MUST be exactly \"2.0\".</p>"},{"location":"sdk/python/#a2a.types.JSONRPCSuccessResponse.model_config","title":"<code>model_config = ConfigDict(validate_by_name=True, validate_by_alias=True, serialize_by_alias=True, alias_generator=to_camel_custom)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.types.JSONRPCSuccessResponse.result","title":"<code>result</code>  <code>instance-attribute</code>","text":"<p>The value of this member is determined by the method invoked on the Server.</p>"},{"location":"sdk/python/#a2a.types.ListTaskPushNotificationConfigParams","title":"<code>ListTaskPushNotificationConfigParams</code>","text":"<p>               Bases: <code>A2ABaseModel</code></p> <p>Defines parameters for listing all push notification configurations associated with a task.</p>"},{"location":"sdk/python/#a2a.types.ListTaskPushNotificationConfigParams.id","title":"<code>id</code>  <code>instance-attribute</code>","text":"<p>The unique identifier of the task.</p>"},{"location":"sdk/python/#a2a.types.ListTaskPushNotificationConfigParams.metadata","title":"<code>metadata = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Optional metadata associated with the request.</p>"},{"location":"sdk/python/#a2a.types.ListTaskPushNotificationConfigParams.model_config","title":"<code>model_config = ConfigDict(validate_by_name=True, validate_by_alias=True, serialize_by_alias=True, alias_generator=to_camel_custom)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.types.ListTaskPushNotificationConfigRequest","title":"<code>ListTaskPushNotificationConfigRequest</code>","text":"<p>               Bases: <code>A2ABaseModel</code></p> <p>Represents a JSON-RPC request for the <code>tasks/pushNotificationConfig/list</code> method.</p>"},{"location":"sdk/python/#a2a.types.ListTaskPushNotificationConfigRequest.id","title":"<code>id</code>  <code>instance-attribute</code>","text":"<p>The identifier for this request.</p>"},{"location":"sdk/python/#a2a.types.ListTaskPushNotificationConfigRequest.jsonrpc","title":"<code>jsonrpc = '2.0'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The version of the JSON-RPC protocol. MUST be exactly \"2.0\".</p>"},{"location":"sdk/python/#a2a.types.ListTaskPushNotificationConfigRequest.method","title":"<code>method = 'tasks/pushNotificationConfig/list'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The method name. Must be 'tasks/pushNotificationConfig/list'.</p>"},{"location":"sdk/python/#a2a.types.ListTaskPushNotificationConfigRequest.model_config","title":"<code>model_config = ConfigDict(validate_by_name=True, validate_by_alias=True, serialize_by_alias=True, alias_generator=to_camel_custom)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.types.ListTaskPushNotificationConfigRequest.params","title":"<code>params</code>  <code>instance-attribute</code>","text":"<p>The parameters identifying the task whose configurations are to be listed.</p>"},{"location":"sdk/python/#a2a.types.ListTaskPushNotificationConfigResponse","title":"<code>ListTaskPushNotificationConfigResponse</code>","text":"<p>               Bases: <code>RootModel[JSONRPCErrorResponse | ListTaskPushNotificationConfigSuccessResponse]</code></p>"},{"location":"sdk/python/#a2a.types.ListTaskPushNotificationConfigResponse.root","title":"<code>root</code>  <code>instance-attribute</code>","text":"<p>Represents a JSON-RPC response for the <code>tasks/pushNotificationConfig/list</code> method.</p>"},{"location":"sdk/python/#a2a.types.ListTaskPushNotificationConfigSuccessResponse","title":"<code>ListTaskPushNotificationConfigSuccessResponse</code>","text":"<p>               Bases: <code>A2ABaseModel</code></p> <p>Represents a successful JSON-RPC response for the <code>tasks/pushNotificationConfig/list</code> method.</p>"},{"location":"sdk/python/#a2a.types.ListTaskPushNotificationConfigSuccessResponse.id","title":"<code>id = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The identifier established by the client.</p>"},{"location":"sdk/python/#a2a.types.ListTaskPushNotificationConfigSuccessResponse.jsonrpc","title":"<code>jsonrpc = '2.0'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The version of the JSON-RPC protocol. MUST be exactly \"2.0\".</p>"},{"location":"sdk/python/#a2a.types.ListTaskPushNotificationConfigSuccessResponse.model_config","title":"<code>model_config = ConfigDict(validate_by_name=True, validate_by_alias=True, serialize_by_alias=True, alias_generator=to_camel_custom)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.types.ListTaskPushNotificationConfigSuccessResponse.result","title":"<code>result</code>  <code>instance-attribute</code>","text":"<p>The result, containing an array of all push notification configurations for the task.</p>"},{"location":"sdk/python/#a2a.types.Message","title":"<code>Message</code>","text":"<p>               Bases: <code>A2ABaseModel</code></p> <p>Represents a single message in the conversation between a user and an agent.</p>"},{"location":"sdk/python/#a2a.types.Message.context_id","title":"<code>context_id = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The context identifier for this message, used to group related interactions.</p>"},{"location":"sdk/python/#a2a.types.Message.extensions","title":"<code>extensions = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The URIs of extensions that are relevant to this message.</p>"},{"location":"sdk/python/#a2a.types.Message.kind","title":"<code>kind = 'message'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The type of this object, used as a discriminator. Always 'message' for a Message.</p>"},{"location":"sdk/python/#a2a.types.Message.message_id","title":"<code>message_id</code>  <code>instance-attribute</code>","text":"<p>A unique identifier for the message, typically a UUID, generated by the sender.</p>"},{"location":"sdk/python/#a2a.types.Message.metadata","title":"<code>metadata = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Optional metadata for extensions. The key is an extension-specific identifier.</p>"},{"location":"sdk/python/#a2a.types.Message.model_config","title":"<code>model_config = ConfigDict(validate_by_name=True, validate_by_alias=True, serialize_by_alias=True, alias_generator=to_camel_custom)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.types.Message.parts","title":"<code>parts</code>  <code>instance-attribute</code>","text":"<p>An array of content parts that form the message body. A message can be composed of multiple parts of different types (e.g., text and files).</p>"},{"location":"sdk/python/#a2a.types.Message.reference_task_ids","title":"<code>reference_task_ids = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A list of other task IDs that this message references for additional context.</p>"},{"location":"sdk/python/#a2a.types.Message.role","title":"<code>role</code>  <code>instance-attribute</code>","text":"<p>Identifies the sender of the message. <code>user</code> for the client, <code>agent</code> for the service.</p>"},{"location":"sdk/python/#a2a.types.Message.task_id","title":"<code>task_id = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The identifier of the task this message is part of. Can be omitted for the first message of a new task.</p>"},{"location":"sdk/python/#a2a.types.MessageSendConfiguration","title":"<code>MessageSendConfiguration</code>","text":"<p>               Bases: <code>A2ABaseModel</code></p> <p>Defines configuration options for a <code>message/send</code> or <code>message/stream</code> request.</p>"},{"location":"sdk/python/#a2a.types.MessageSendConfiguration.accepted_output_modes","title":"<code>accepted_output_modes = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A list of output MIME types the client is prepared to accept in the response.</p>"},{"location":"sdk/python/#a2a.types.MessageSendConfiguration.blocking","title":"<code>blocking = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>If true, the client will wait for the task to complete. The server may reject this if the task is long-running.</p>"},{"location":"sdk/python/#a2a.types.MessageSendConfiguration.history_length","title":"<code>history_length = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The number of most recent messages from the task's history to retrieve in the response.</p>"},{"location":"sdk/python/#a2a.types.MessageSendConfiguration.model_config","title":"<code>model_config = ConfigDict(validate_by_name=True, validate_by_alias=True, serialize_by_alias=True, alias_generator=to_camel_custom)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.types.MessageSendConfiguration.push_notification_config","title":"<code>push_notification_config = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Configuration for the agent to send push notifications for updates after the initial response.</p>"},{"location":"sdk/python/#a2a.types.MessageSendParams","title":"<code>MessageSendParams</code>","text":"<p>               Bases: <code>A2ABaseModel</code></p> <p>Defines the parameters for a request to send a message to an agent. This can be used to create a new task, continue an existing one, or restart a task.</p>"},{"location":"sdk/python/#a2a.types.MessageSendParams.configuration","title":"<code>configuration = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Optional configuration for the send request.</p>"},{"location":"sdk/python/#a2a.types.MessageSendParams.message","title":"<code>message</code>  <code>instance-attribute</code>","text":"<p>The message object being sent to the agent.</p>"},{"location":"sdk/python/#a2a.types.MessageSendParams.metadata","title":"<code>metadata = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Optional metadata for extensions.</p>"},{"location":"sdk/python/#a2a.types.MessageSendParams.model_config","title":"<code>model_config = ConfigDict(validate_by_name=True, validate_by_alias=True, serialize_by_alias=True, alias_generator=to_camel_custom)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.types.MethodNotFoundError","title":"<code>MethodNotFoundError</code>","text":"<p>               Bases: <code>A2ABaseModel</code></p> <p>An error indicating that the requested method does not exist or is not available.</p>"},{"location":"sdk/python/#a2a.types.MethodNotFoundError.code","title":"<code>code = -32601</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The error code for a method not found error.</p>"},{"location":"sdk/python/#a2a.types.MethodNotFoundError.data","title":"<code>data = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A primitive or structured value containing additional information about the error. This may be omitted.</p>"},{"location":"sdk/python/#a2a.types.MethodNotFoundError.message","title":"<code>message = 'Method not found'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The error message.</p>"},{"location":"sdk/python/#a2a.types.MethodNotFoundError.model_config","title":"<code>model_config = ConfigDict(validate_by_name=True, validate_by_alias=True, serialize_by_alias=True, alias_generator=to_camel_custom)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.types.OAuth2SecurityScheme","title":"<code>OAuth2SecurityScheme</code>","text":"<p>               Bases: <code>A2ABaseModel</code></p> <p>Defines a security scheme using OAuth 2.0.</p>"},{"location":"sdk/python/#a2a.types.OAuth2SecurityScheme.description","title":"<code>description = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>An optional description for the security scheme.</p>"},{"location":"sdk/python/#a2a.types.OAuth2SecurityScheme.flows","title":"<code>flows</code>  <code>instance-attribute</code>","text":"<p>An object containing configuration information for the supported OAuth 2.0 flows.</p>"},{"location":"sdk/python/#a2a.types.OAuth2SecurityScheme.model_config","title":"<code>model_config = ConfigDict(validate_by_name=True, validate_by_alias=True, serialize_by_alias=True, alias_generator=to_camel_custom)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.types.OAuth2SecurityScheme.type","title":"<code>type = 'oauth2'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The type of the security scheme. Must be 'oauth2'.</p>"},{"location":"sdk/python/#a2a.types.OAuthFlows","title":"<code>OAuthFlows</code>","text":"<p>               Bases: <code>A2ABaseModel</code></p> <p>Defines the configuration for the supported OAuth 2.0 flows.</p>"},{"location":"sdk/python/#a2a.types.OAuthFlows.authorization_code","title":"<code>authorization_code = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Configuration for the OAuth Authorization Code flow. Previously called accessCode in OpenAPI 2.0.</p>"},{"location":"sdk/python/#a2a.types.OAuthFlows.client_credentials","title":"<code>client_credentials = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Configuration for the OAuth Client Credentials flow. Previously called application in OpenAPI 2.0.</p>"},{"location":"sdk/python/#a2a.types.OAuthFlows.implicit","title":"<code>implicit = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Configuration for the OAuth Implicit flow.</p>"},{"location":"sdk/python/#a2a.types.OAuthFlows.model_config","title":"<code>model_config = ConfigDict(validate_by_name=True, validate_by_alias=True, serialize_by_alias=True, alias_generator=to_camel_custom)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.types.OAuthFlows.password","title":"<code>password = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Configuration for the OAuth Resource Owner Password flow.</p>"},{"location":"sdk/python/#a2a.types.OpenIdConnectSecurityScheme","title":"<code>OpenIdConnectSecurityScheme</code>","text":"<p>               Bases: <code>A2ABaseModel</code></p> <p>Defines a security scheme using OpenID Connect.</p>"},{"location":"sdk/python/#a2a.types.OpenIdConnectSecurityScheme.description","title":"<code>description = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>An optional description for the security scheme.</p>"},{"location":"sdk/python/#a2a.types.OpenIdConnectSecurityScheme.model_config","title":"<code>model_config = ConfigDict(validate_by_name=True, validate_by_alias=True, serialize_by_alias=True, alias_generator=to_camel_custom)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.types.OpenIdConnectSecurityScheme.open_id_connect_url","title":"<code>open_id_connect_url</code>  <code>instance-attribute</code>","text":"<p>The OpenID Connect Discovery URL for the OIDC provider's metadata.</p>"},{"location":"sdk/python/#a2a.types.OpenIdConnectSecurityScheme.type","title":"<code>type = 'openIdConnect'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The type of the security scheme. Must be 'openIdConnect'.</p>"},{"location":"sdk/python/#a2a.types.Part","title":"<code>Part</code>","text":"<p>               Bases: <code>RootModel[TextPart | FilePart | DataPart]</code></p>"},{"location":"sdk/python/#a2a.types.Part.root","title":"<code>root</code>  <code>instance-attribute</code>","text":"<p>A discriminated union representing a part of a message or artifact, which can be text, a file, or structured data.</p>"},{"location":"sdk/python/#a2a.types.PartBase","title":"<code>PartBase</code>","text":"<p>               Bases: <code>A2ABaseModel</code></p> <p>Defines base properties common to all message or artifact parts.</p>"},{"location":"sdk/python/#a2a.types.PartBase.metadata","title":"<code>metadata = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Optional metadata associated with this part.</p>"},{"location":"sdk/python/#a2a.types.PartBase.model_config","title":"<code>model_config = ConfigDict(validate_by_name=True, validate_by_alias=True, serialize_by_alias=True, alias_generator=to_camel_custom)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.types.PasswordOAuthFlow","title":"<code>PasswordOAuthFlow</code>","text":"<p>               Bases: <code>A2ABaseModel</code></p> <p>Defines configuration details for the OAuth 2.0 Resource Owner Password flow.</p>"},{"location":"sdk/python/#a2a.types.PasswordOAuthFlow.model_config","title":"<code>model_config = ConfigDict(validate_by_name=True, validate_by_alias=True, serialize_by_alias=True, alias_generator=to_camel_custom)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.types.PasswordOAuthFlow.refresh_url","title":"<code>refresh_url = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The URL to be used for obtaining refresh tokens. This MUST be a URL.</p>"},{"location":"sdk/python/#a2a.types.PasswordOAuthFlow.scopes","title":"<code>scopes</code>  <code>instance-attribute</code>","text":"<p>The available scopes for the OAuth2 security scheme. A map between the scope name and a short description for it.</p>"},{"location":"sdk/python/#a2a.types.PasswordOAuthFlow.token_url","title":"<code>token_url</code>  <code>instance-attribute</code>","text":"<p>The token URL to be used for this flow. This MUST be a URL.</p>"},{"location":"sdk/python/#a2a.types.PushNotificationAuthenticationInfo","title":"<code>PushNotificationAuthenticationInfo</code>","text":"<p>               Bases: <code>A2ABaseModel</code></p> <p>Defines authentication details for a push notification endpoint.</p>"},{"location":"sdk/python/#a2a.types.PushNotificationAuthenticationInfo.credentials","title":"<code>credentials = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Optional credentials required by the push notification endpoint.</p>"},{"location":"sdk/python/#a2a.types.PushNotificationAuthenticationInfo.model_config","title":"<code>model_config = ConfigDict(validate_by_name=True, validate_by_alias=True, serialize_by_alias=True, alias_generator=to_camel_custom)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.types.PushNotificationAuthenticationInfo.schemes","title":"<code>schemes</code>  <code>instance-attribute</code>","text":"<p>A list of supported authentication schemes (e.g., 'Basic', 'Bearer').</p>"},{"location":"sdk/python/#a2a.types.PushNotificationConfig","title":"<code>PushNotificationConfig</code>","text":"<p>               Bases: <code>A2ABaseModel</code></p> <p>Defines the configuration for setting up push notifications for task updates.</p>"},{"location":"sdk/python/#a2a.types.PushNotificationConfig.authentication","title":"<code>authentication = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Optional authentication details for the agent to use when calling the notification URL.</p>"},{"location":"sdk/python/#a2a.types.PushNotificationConfig.id","title":"<code>id = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A unique ID for the push notification configuration, created by the server to support multiple notification callbacks.</p>"},{"location":"sdk/python/#a2a.types.PushNotificationConfig.model_config","title":"<code>model_config = ConfigDict(validate_by_name=True, validate_by_alias=True, serialize_by_alias=True, alias_generator=to_camel_custom)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.types.PushNotificationConfig.token","title":"<code>token = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A unique token for this task or session to validate incoming push notifications.</p>"},{"location":"sdk/python/#a2a.types.PushNotificationConfig.url","title":"<code>url</code>  <code>instance-attribute</code>","text":"<p>The callback URL where the agent should send push notifications.</p>"},{"location":"sdk/python/#a2a.types.PushNotificationNotSupportedError","title":"<code>PushNotificationNotSupportedError</code>","text":"<p>               Bases: <code>A2ABaseModel</code></p> <p>An A2A-specific error indicating that the agent does not support push notifications.</p>"},{"location":"sdk/python/#a2a.types.PushNotificationNotSupportedError.code","title":"<code>code = -32003</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The error code for when push notifications are not supported.</p>"},{"location":"sdk/python/#a2a.types.PushNotificationNotSupportedError.data","title":"<code>data = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A primitive or structured value containing additional information about the error. This may be omitted.</p>"},{"location":"sdk/python/#a2a.types.PushNotificationNotSupportedError.message","title":"<code>message = 'Push Notification is not supported'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The error message.</p>"},{"location":"sdk/python/#a2a.types.PushNotificationNotSupportedError.model_config","title":"<code>model_config = ConfigDict(validate_by_name=True, validate_by_alias=True, serialize_by_alias=True, alias_generator=to_camel_custom)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.types.Role","title":"<code>Role</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Identifies the sender of the message. <code>user</code> for the client, <code>agent</code> for the service.</p>"},{"location":"sdk/python/#a2a.types.Role.agent","title":"<code>agent = 'agent'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.types.Role.user","title":"<code>user = 'user'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.types.SecurityScheme","title":"<code>SecurityScheme</code>","text":"<p>               Bases: <code>RootModel[APIKeySecurityScheme | HTTPAuthSecurityScheme | OAuth2SecurityScheme | OpenIdConnectSecurityScheme]</code></p>"},{"location":"sdk/python/#a2a.types.SecurityScheme.root","title":"<code>root</code>  <code>instance-attribute</code>","text":"<p>Defines a security scheme that can be used to secure an agent's endpoints. This is a discriminated union type based on the OpenAPI 3.0 Security Scheme Object.</p>"},{"location":"sdk/python/#a2a.types.SecuritySchemeBase","title":"<code>SecuritySchemeBase</code>","text":"<p>               Bases: <code>A2ABaseModel</code></p> <p>Defines base properties shared by all security scheme objects.</p>"},{"location":"sdk/python/#a2a.types.SecuritySchemeBase.description","title":"<code>description = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>An optional description for the security scheme.</p>"},{"location":"sdk/python/#a2a.types.SecuritySchemeBase.model_config","title":"<code>model_config = ConfigDict(validate_by_name=True, validate_by_alias=True, serialize_by_alias=True, alias_generator=to_camel_custom)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.types.SendMessageRequest","title":"<code>SendMessageRequest</code>","text":"<p>               Bases: <code>A2ABaseModel</code></p> <p>Represents a JSON-RPC request for the <code>message/send</code> method.</p>"},{"location":"sdk/python/#a2a.types.SendMessageRequest.id","title":"<code>id</code>  <code>instance-attribute</code>","text":"<p>The identifier for this request.</p>"},{"location":"sdk/python/#a2a.types.SendMessageRequest.jsonrpc","title":"<code>jsonrpc = '2.0'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The version of the JSON-RPC protocol. MUST be exactly \"2.0\".</p>"},{"location":"sdk/python/#a2a.types.SendMessageRequest.method","title":"<code>method = 'message/send'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The method name. Must be 'message/send'.</p>"},{"location":"sdk/python/#a2a.types.SendMessageRequest.model_config","title":"<code>model_config = ConfigDict(validate_by_name=True, validate_by_alias=True, serialize_by_alias=True, alias_generator=to_camel_custom)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.types.SendMessageRequest.params","title":"<code>params</code>  <code>instance-attribute</code>","text":"<p>The parameters for sending a message.</p>"},{"location":"sdk/python/#a2a.types.SendMessageResponse","title":"<code>SendMessageResponse</code>","text":"<p>               Bases: <code>RootModel[JSONRPCErrorResponse | SendMessageSuccessResponse]</code></p>"},{"location":"sdk/python/#a2a.types.SendMessageResponse.root","title":"<code>root</code>  <code>instance-attribute</code>","text":"<p>Represents a JSON-RPC response for the <code>message/send</code> method.</p>"},{"location":"sdk/python/#a2a.types.SendMessageSuccessResponse","title":"<code>SendMessageSuccessResponse</code>","text":"<p>               Bases: <code>A2ABaseModel</code></p> <p>Represents a successful JSON-RPC response for the <code>message/send</code> method.</p>"},{"location":"sdk/python/#a2a.types.SendMessageSuccessResponse.id","title":"<code>id = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The identifier established by the client.</p>"},{"location":"sdk/python/#a2a.types.SendMessageSuccessResponse.jsonrpc","title":"<code>jsonrpc = '2.0'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The version of the JSON-RPC protocol. MUST be exactly \"2.0\".</p>"},{"location":"sdk/python/#a2a.types.SendMessageSuccessResponse.model_config","title":"<code>model_config = ConfigDict(validate_by_name=True, validate_by_alias=True, serialize_by_alias=True, alias_generator=to_camel_custom)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.types.SendMessageSuccessResponse.result","title":"<code>result</code>  <code>instance-attribute</code>","text":"<p>The result, which can be a direct reply Message or the initial Task object.</p>"},{"location":"sdk/python/#a2a.types.SendStreamingMessageRequest","title":"<code>SendStreamingMessageRequest</code>","text":"<p>               Bases: <code>A2ABaseModel</code></p> <p>Represents a JSON-RPC request for the <code>message/stream</code> method.</p>"},{"location":"sdk/python/#a2a.types.SendStreamingMessageRequest.id","title":"<code>id</code>  <code>instance-attribute</code>","text":"<p>The identifier for this request.</p>"},{"location":"sdk/python/#a2a.types.SendStreamingMessageRequest.jsonrpc","title":"<code>jsonrpc = '2.0'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The version of the JSON-RPC protocol. MUST be exactly \"2.0\".</p>"},{"location":"sdk/python/#a2a.types.SendStreamingMessageRequest.method","title":"<code>method = 'message/stream'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The method name. Must be 'message/stream'.</p>"},{"location":"sdk/python/#a2a.types.SendStreamingMessageRequest.model_config","title":"<code>model_config = ConfigDict(validate_by_name=True, validate_by_alias=True, serialize_by_alias=True, alias_generator=to_camel_custom)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.types.SendStreamingMessageRequest.params","title":"<code>params</code>  <code>instance-attribute</code>","text":"<p>The parameters for sending a message.</p>"},{"location":"sdk/python/#a2a.types.SendStreamingMessageResponse","title":"<code>SendStreamingMessageResponse</code>","text":"<p>               Bases: <code>RootModel[JSONRPCErrorResponse | SendStreamingMessageSuccessResponse]</code></p>"},{"location":"sdk/python/#a2a.types.SendStreamingMessageResponse.root","title":"<code>root</code>  <code>instance-attribute</code>","text":"<p>Represents a JSON-RPC response for the <code>message/stream</code> method.</p>"},{"location":"sdk/python/#a2a.types.SendStreamingMessageSuccessResponse","title":"<code>SendStreamingMessageSuccessResponse</code>","text":"<p>               Bases: <code>A2ABaseModel</code></p> <p>Represents a successful JSON-RPC response for the <code>message/stream</code> method. The server may send multiple response objects for a single request.</p>"},{"location":"sdk/python/#a2a.types.SendStreamingMessageSuccessResponse.id","title":"<code>id = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The identifier established by the client.</p>"},{"location":"sdk/python/#a2a.types.SendStreamingMessageSuccessResponse.jsonrpc","title":"<code>jsonrpc = '2.0'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The version of the JSON-RPC protocol. MUST be exactly \"2.0\".</p>"},{"location":"sdk/python/#a2a.types.SendStreamingMessageSuccessResponse.model_config","title":"<code>model_config = ConfigDict(validate_by_name=True, validate_by_alias=True, serialize_by_alias=True, alias_generator=to_camel_custom)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.types.SendStreamingMessageSuccessResponse.result","title":"<code>result</code>  <code>instance-attribute</code>","text":"<p>The result, which can be a Message, Task, or a streaming update event.</p>"},{"location":"sdk/python/#a2a.types.SetTaskPushNotificationConfigRequest","title":"<code>SetTaskPushNotificationConfigRequest</code>","text":"<p>               Bases: <code>A2ABaseModel</code></p> <p>Represents a JSON-RPC request for the <code>tasks/pushNotificationConfig/set</code> method.</p>"},{"location":"sdk/python/#a2a.types.SetTaskPushNotificationConfigRequest.id","title":"<code>id</code>  <code>instance-attribute</code>","text":"<p>The identifier for this request.</p>"},{"location":"sdk/python/#a2a.types.SetTaskPushNotificationConfigRequest.jsonrpc","title":"<code>jsonrpc = '2.0'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The version of the JSON-RPC protocol. MUST be exactly \"2.0\".</p>"},{"location":"sdk/python/#a2a.types.SetTaskPushNotificationConfigRequest.method","title":"<code>method = 'tasks/pushNotificationConfig/set'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The method name. Must be 'tasks/pushNotificationConfig/set'.</p>"},{"location":"sdk/python/#a2a.types.SetTaskPushNotificationConfigRequest.model_config","title":"<code>model_config = ConfigDict(validate_by_name=True, validate_by_alias=True, serialize_by_alias=True, alias_generator=to_camel_custom)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.types.SetTaskPushNotificationConfigRequest.params","title":"<code>params</code>  <code>instance-attribute</code>","text":"<p>The parameters for setting the push notification configuration.</p>"},{"location":"sdk/python/#a2a.types.SetTaskPushNotificationConfigResponse","title":"<code>SetTaskPushNotificationConfigResponse</code>","text":"<p>               Bases: <code>RootModel[JSONRPCErrorResponse | SetTaskPushNotificationConfigSuccessResponse]</code></p>"},{"location":"sdk/python/#a2a.types.SetTaskPushNotificationConfigResponse.root","title":"<code>root</code>  <code>instance-attribute</code>","text":"<p>Represents a JSON-RPC response for the <code>tasks/pushNotificationConfig/set</code> method.</p>"},{"location":"sdk/python/#a2a.types.SetTaskPushNotificationConfigSuccessResponse","title":"<code>SetTaskPushNotificationConfigSuccessResponse</code>","text":"<p>               Bases: <code>A2ABaseModel</code></p> <p>Represents a successful JSON-RPC response for the <code>tasks/pushNotificationConfig/set</code> method.</p>"},{"location":"sdk/python/#a2a.types.SetTaskPushNotificationConfigSuccessResponse.id","title":"<code>id = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The identifier established by the client.</p>"},{"location":"sdk/python/#a2a.types.SetTaskPushNotificationConfigSuccessResponse.jsonrpc","title":"<code>jsonrpc = '2.0'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The version of the JSON-RPC protocol. MUST be exactly \"2.0\".</p>"},{"location":"sdk/python/#a2a.types.SetTaskPushNotificationConfigSuccessResponse.model_config","title":"<code>model_config = ConfigDict(validate_by_name=True, validate_by_alias=True, serialize_by_alias=True, alias_generator=to_camel_custom)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.types.SetTaskPushNotificationConfigSuccessResponse.result","title":"<code>result</code>  <code>instance-attribute</code>","text":"<p>The result, containing the configured push notification settings.</p>"},{"location":"sdk/python/#a2a.types.Task","title":"<code>Task</code>","text":"<p>               Bases: <code>A2ABaseModel</code></p> <p>Represents a single, stateful operation or conversation between a client and an agent.</p>"},{"location":"sdk/python/#a2a.types.Task.artifacts","title":"<code>artifacts = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A collection of artifacts generated by the agent during the execution of the task.</p>"},{"location":"sdk/python/#a2a.types.Task.context_id","title":"<code>context_id</code>  <code>instance-attribute</code>","text":"<p>A server-generated identifier for maintaining context across multiple related tasks or interactions.</p>"},{"location":"sdk/python/#a2a.types.Task.history","title":"<code>history = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>An array of messages exchanged during the task, representing the conversation history.</p>"},{"location":"sdk/python/#a2a.types.Task.id","title":"<code>id</code>  <code>instance-attribute</code>","text":"<p>A unique identifier for the task, generated by the client for a new task or provided by the agent.</p>"},{"location":"sdk/python/#a2a.types.Task.kind","title":"<code>kind = 'task'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The type of this object, used as a discriminator. Always 'task' for a Task.</p>"},{"location":"sdk/python/#a2a.types.Task.metadata","title":"<code>metadata = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Optional metadata for extensions. The key is an extension-specific identifier.</p>"},{"location":"sdk/python/#a2a.types.Task.model_config","title":"<code>model_config = ConfigDict(validate_by_name=True, validate_by_alias=True, serialize_by_alias=True, alias_generator=to_camel_custom)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.types.Task.status","title":"<code>status</code>  <code>instance-attribute</code>","text":"<p>The current status of the task, including its state and a descriptive message.</p>"},{"location":"sdk/python/#a2a.types.TaskArtifactUpdateEvent","title":"<code>TaskArtifactUpdateEvent</code>","text":"<p>               Bases: <code>A2ABaseModel</code></p> <p>An event sent by the agent to notify the client that an artifact has been generated or updated. This is typically used in streaming models.</p>"},{"location":"sdk/python/#a2a.types.TaskArtifactUpdateEvent.append","title":"<code>append = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>If true, the content of this artifact should be appended to a previously sent artifact with the same ID.</p>"},{"location":"sdk/python/#a2a.types.TaskArtifactUpdateEvent.artifact","title":"<code>artifact</code>  <code>instance-attribute</code>","text":"<p>The artifact that was generated or updated.</p>"},{"location":"sdk/python/#a2a.types.TaskArtifactUpdateEvent.context_id","title":"<code>context_id</code>  <code>instance-attribute</code>","text":"<p>The context ID associated with the task.</p>"},{"location":"sdk/python/#a2a.types.TaskArtifactUpdateEvent.kind","title":"<code>kind = 'artifact-update'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The type of this event, used as a discriminator. Always 'artifact-update'.</p>"},{"location":"sdk/python/#a2a.types.TaskArtifactUpdateEvent.last_chunk","title":"<code>last_chunk = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>If true, this is the final chunk of the artifact.</p>"},{"location":"sdk/python/#a2a.types.TaskArtifactUpdateEvent.metadata","title":"<code>metadata = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Optional metadata for extensions.</p>"},{"location":"sdk/python/#a2a.types.TaskArtifactUpdateEvent.model_config","title":"<code>model_config = ConfigDict(validate_by_name=True, validate_by_alias=True, serialize_by_alias=True, alias_generator=to_camel_custom)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.types.TaskArtifactUpdateEvent.task_id","title":"<code>task_id</code>  <code>instance-attribute</code>","text":"<p>The ID of the task this artifact belongs to.</p>"},{"location":"sdk/python/#a2a.types.TaskIdParams","title":"<code>TaskIdParams</code>","text":"<p>               Bases: <code>A2ABaseModel</code></p> <p>Defines parameters containing a task ID, used for simple task operations.</p>"},{"location":"sdk/python/#a2a.types.TaskIdParams.id","title":"<code>id</code>  <code>instance-attribute</code>","text":"<p>The unique identifier of the task.</p>"},{"location":"sdk/python/#a2a.types.TaskIdParams.metadata","title":"<code>metadata = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Optional metadata associated with the request.</p>"},{"location":"sdk/python/#a2a.types.TaskIdParams.model_config","title":"<code>model_config = ConfigDict(validate_by_name=True, validate_by_alias=True, serialize_by_alias=True, alias_generator=to_camel_custom)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.types.TaskNotCancelableError","title":"<code>TaskNotCancelableError</code>","text":"<p>               Bases: <code>A2ABaseModel</code></p> <p>An A2A-specific error indicating that the task is in a state where it cannot be canceled.</p>"},{"location":"sdk/python/#a2a.types.TaskNotCancelableError.code","title":"<code>code = -32002</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The error code for a task that cannot be canceled.</p>"},{"location":"sdk/python/#a2a.types.TaskNotCancelableError.data","title":"<code>data = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A primitive or structured value containing additional information about the error. This may be omitted.</p>"},{"location":"sdk/python/#a2a.types.TaskNotCancelableError.message","title":"<code>message = 'Task cannot be canceled'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The error message.</p>"},{"location":"sdk/python/#a2a.types.TaskNotCancelableError.model_config","title":"<code>model_config = ConfigDict(validate_by_name=True, validate_by_alias=True, serialize_by_alias=True, alias_generator=to_camel_custom)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.types.TaskNotFoundError","title":"<code>TaskNotFoundError</code>","text":"<p>               Bases: <code>A2ABaseModel</code></p> <p>An A2A-specific error indicating that the requested task ID was not found.</p>"},{"location":"sdk/python/#a2a.types.TaskNotFoundError.code","title":"<code>code = -32001</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The error code for a task not found error.</p>"},{"location":"sdk/python/#a2a.types.TaskNotFoundError.data","title":"<code>data = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A primitive or structured value containing additional information about the error. This may be omitted.</p>"},{"location":"sdk/python/#a2a.types.TaskNotFoundError.message","title":"<code>message = 'Task not found'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The error message.</p>"},{"location":"sdk/python/#a2a.types.TaskNotFoundError.model_config","title":"<code>model_config = ConfigDict(validate_by_name=True, validate_by_alias=True, serialize_by_alias=True, alias_generator=to_camel_custom)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.types.TaskPushNotificationConfig","title":"<code>TaskPushNotificationConfig</code>","text":"<p>               Bases: <code>A2ABaseModel</code></p> <p>A container associating a push notification configuration with a specific task.</p>"},{"location":"sdk/python/#a2a.types.TaskPushNotificationConfig.model_config","title":"<code>model_config = ConfigDict(validate_by_name=True, validate_by_alias=True, serialize_by_alias=True, alias_generator=to_camel_custom)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.types.TaskPushNotificationConfig.push_notification_config","title":"<code>push_notification_config</code>  <code>instance-attribute</code>","text":"<p>The push notification configuration for this task.</p>"},{"location":"sdk/python/#a2a.types.TaskPushNotificationConfig.task_id","title":"<code>task_id</code>  <code>instance-attribute</code>","text":"<p>The ID of the task.</p>"},{"location":"sdk/python/#a2a.types.TaskQueryParams","title":"<code>TaskQueryParams</code>","text":"<p>               Bases: <code>A2ABaseModel</code></p> <p>Defines parameters for querying a task, with an option to limit history length.</p>"},{"location":"sdk/python/#a2a.types.TaskQueryParams.history_length","title":"<code>history_length = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The number of most recent messages from the task's history to retrieve.</p>"},{"location":"sdk/python/#a2a.types.TaskQueryParams.id","title":"<code>id</code>  <code>instance-attribute</code>","text":"<p>The unique identifier of the task.</p>"},{"location":"sdk/python/#a2a.types.TaskQueryParams.metadata","title":"<code>metadata = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Optional metadata associated with the request.</p>"},{"location":"sdk/python/#a2a.types.TaskQueryParams.model_config","title":"<code>model_config = ConfigDict(validate_by_name=True, validate_by_alias=True, serialize_by_alias=True, alias_generator=to_camel_custom)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.types.TaskResubscriptionRequest","title":"<code>TaskResubscriptionRequest</code>","text":"<p>               Bases: <code>A2ABaseModel</code></p> <p>Represents a JSON-RPC request for the <code>tasks/resubscribe</code> method, used to resume a streaming connection.</p>"},{"location":"sdk/python/#a2a.types.TaskResubscriptionRequest.id","title":"<code>id</code>  <code>instance-attribute</code>","text":"<p>The identifier for this request.</p>"},{"location":"sdk/python/#a2a.types.TaskResubscriptionRequest.jsonrpc","title":"<code>jsonrpc = '2.0'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The version of the JSON-RPC protocol. MUST be exactly \"2.0\".</p>"},{"location":"sdk/python/#a2a.types.TaskResubscriptionRequest.method","title":"<code>method = 'tasks/resubscribe'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The method name. Must be 'tasks/resubscribe'.</p>"},{"location":"sdk/python/#a2a.types.TaskResubscriptionRequest.model_config","title":"<code>model_config = ConfigDict(validate_by_name=True, validate_by_alias=True, serialize_by_alias=True, alias_generator=to_camel_custom)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.types.TaskResubscriptionRequest.params","title":"<code>params</code>  <code>instance-attribute</code>","text":"<p>The parameters identifying the task to resubscribe to.</p>"},{"location":"sdk/python/#a2a.types.TaskState","title":"<code>TaskState</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Defines the lifecycle states of a Task.</p>"},{"location":"sdk/python/#a2a.types.TaskState.auth_required","title":"<code>auth_required = 'auth-required'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.types.TaskState.canceled","title":"<code>canceled = 'canceled'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.types.TaskState.completed","title":"<code>completed = 'completed'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.types.TaskState.failed","title":"<code>failed = 'failed'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.types.TaskState.input_required","title":"<code>input_required = 'input-required'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.types.TaskState.rejected","title":"<code>rejected = 'rejected'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.types.TaskState.submitted","title":"<code>submitted = 'submitted'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.types.TaskState.unknown","title":"<code>unknown = 'unknown'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.types.TaskState.working","title":"<code>working = 'working'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.types.TaskStatus","title":"<code>TaskStatus</code>","text":"<p>               Bases: <code>A2ABaseModel</code></p> <p>Represents the status of a task at a specific point in time.</p>"},{"location":"sdk/python/#a2a.types.TaskStatus.message","title":"<code>message = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>An optional, human-readable message providing more details about the current status.</p>"},{"location":"sdk/python/#a2a.types.TaskStatus.model_config","title":"<code>model_config = ConfigDict(validate_by_name=True, validate_by_alias=True, serialize_by_alias=True, alias_generator=to_camel_custom)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.types.TaskStatus.state","title":"<code>state</code>  <code>instance-attribute</code>","text":"<p>The current state of the task's lifecycle.</p>"},{"location":"sdk/python/#a2a.types.TaskStatus.timestamp","title":"<code>timestamp = Field(default=None, examples=['2023-10-27T10:00:00Z'])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>An ISO 8601 datetime string indicating when this status was recorded.</p>"},{"location":"sdk/python/#a2a.types.TaskStatusUpdateEvent","title":"<code>TaskStatusUpdateEvent</code>","text":"<p>               Bases: <code>A2ABaseModel</code></p> <p>An event sent by the agent to notify the client of a change in a task's status. This is typically used in streaming or subscription models.</p>"},{"location":"sdk/python/#a2a.types.TaskStatusUpdateEvent.context_id","title":"<code>context_id</code>  <code>instance-attribute</code>","text":"<p>The context ID associated with the task.</p>"},{"location":"sdk/python/#a2a.types.TaskStatusUpdateEvent.final","title":"<code>final</code>  <code>instance-attribute</code>","text":"<p>If true, this is the final event in the stream for this interaction.</p>"},{"location":"sdk/python/#a2a.types.TaskStatusUpdateEvent.kind","title":"<code>kind = 'status-update'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The type of this event, used as a discriminator. Always 'status-update'.</p>"},{"location":"sdk/python/#a2a.types.TaskStatusUpdateEvent.metadata","title":"<code>metadata = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Optional metadata for extensions.</p>"},{"location":"sdk/python/#a2a.types.TaskStatusUpdateEvent.model_config","title":"<code>model_config = ConfigDict(validate_by_name=True, validate_by_alias=True, serialize_by_alias=True, alias_generator=to_camel_custom)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.types.TaskStatusUpdateEvent.status","title":"<code>status</code>  <code>instance-attribute</code>","text":"<p>The new status of the task.</p>"},{"location":"sdk/python/#a2a.types.TaskStatusUpdateEvent.task_id","title":"<code>task_id</code>  <code>instance-attribute</code>","text":"<p>The ID of the task that was updated.</p>"},{"location":"sdk/python/#a2a.types.TextPart","title":"<code>TextPart</code>","text":"<p>               Bases: <code>A2ABaseModel</code></p> <p>Represents a text segment within a message or artifact.</p>"},{"location":"sdk/python/#a2a.types.TextPart.kind","title":"<code>kind = 'text'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The type of this part, used as a discriminator. Always 'text'.</p>"},{"location":"sdk/python/#a2a.types.TextPart.metadata","title":"<code>metadata = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Optional metadata associated with this part.</p>"},{"location":"sdk/python/#a2a.types.TextPart.model_config","title":"<code>model_config = ConfigDict(validate_by_name=True, validate_by_alias=True, serialize_by_alias=True, alias_generator=to_camel_custom)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"sdk/python/#a2a.types.TextPart.text","title":"<code>text</code>  <code>instance-attribute</code>","text":"<p>The string content of the text part.</p>"},{"location":"sdk/python/#a2a.types.UnsupportedOperationError","title":"<code>UnsupportedOperationError</code>","text":"<p>               Bases: <code>A2ABaseModel</code></p> <p>An A2A-specific error indicating that the requested operation is not supported by the agent.</p>"},{"location":"sdk/python/#a2a.types.UnsupportedOperationError.code","title":"<code>code = -32004</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The error code for an unsupported operation.</p>"},{"location":"sdk/python/#a2a.types.UnsupportedOperationError.data","title":"<code>data = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A primitive or structured value containing additional information about the error. This may be omitted.</p>"},{"location":"sdk/python/#a2a.types.UnsupportedOperationError.message","title":"<code>message = 'This operation is not supported'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The error message.</p>"},{"location":"sdk/python/#a2a.types.UnsupportedOperationError.model_config","title":"<code>model_config = ConfigDict(validate_by_name=True, validate_by_alias=True, serialize_by_alias=True, alias_generator=to_camel_custom)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"topics/a2a-and-mcp/","title":"A2A and MCP: Complementary Protocols for Agentic Systems","text":""},{"location":"topics/a2a-and-mcp/#a2a-mcp","title":"A2A \u2764\ufe0f MCP","text":"<p>In the landscape of AI agent development, two key types of protocols are emerging to facilitate interoperability: those for connecting agents to tools and resources, and those for enabling agent-to-agent collaboration. The Agent2Agent (A2A) Protocol and the Model Context Protocol (MCP) address these distinct but related needs.</p> <p>TL;DR; Agentic applications need both A2A and MCP. We recommend MCP for tools and A2A for agents.</p>"},{"location":"topics/a2a-and-mcp/#why-different-protocols","title":"Why Different Protocols?","text":"<p>The distinction arises from the nature of what an agent interacts with:</p> <ul> <li> <p>Tools &amp; Resources:</p> <ul> <li>These are typically primitives with well-defined, structured inputs and outputs. They perform specific, often stateless, functions (e.g., a calculator, a database query API, a weather lookup service).</li> <li>Their behavior is generally predictable and transactional.</li> <li>Interaction is often a single request-response cycle.</li> </ul> </li> <li> <p>Agents:</p> <ul> <li>These are more autonomous systems. They can reason, plan, use multiple tools, maintain state over longer interactions, and engage in complex, often multi-turn dialogues to achieve novel or evolving tasks.</li> <li>Their behavior can be emergent and less predictable than a simple tool.</li> <li>Interaction often involves ongoing tasks, context sharing, and negotiation.</li> </ul> </li> </ul> <p>Agentic applications need to leverage both: agents use tools to gather information and perform actions, and agents collaborate with other agents to tackle broader, more complex goals.</p>"},{"location":"topics/a2a-and-mcp/#model-context-protocol-mcp","title":"Model Context Protocol (MCP)","text":"<ul> <li>Focus: MCP standardizes how AI models and agents connect to and interact with tools, APIs, data sources, and other external resources.</li> <li>Mechanism: It defines a structured way to describe tool capabilities (akin to function calling in Large Language Models), pass inputs to them, and receive structured outputs.</li> <li>Use Cases:<ul> <li>Enabling an LLM to call an external API (e.g., fetch current stock prices).</li> <li>Allowing an agent to query a database with specific parameters.</li> <li>Connecting an agent to a set of predefined functions or services.</li> </ul> </li> <li>Ecosystem: MCP aims to create an ecosystem where tool providers can easily expose their services to various AI models and agent frameworks, and agent developers can easily consume these tools in a standardized way.</li> </ul>"},{"location":"topics/a2a-and-mcp/#agent2agent-protocol-a2a","title":"Agent2Agent Protocol (A2A)","text":"<ul> <li>Focus: A2A standardizes how independent, often opaque, AI agents communicate and collaborate with each other as peers.</li> <li>Mechanism: It provides an application-level protocol for agents to:<ul> <li>Discover each other's high-level skills and capabilities (via Agent Cards).</li> <li>Negotiate interaction modalities (text, files, structured data).</li> <li>Manage shared, stateful, and potentially long-running tasks.</li> <li>Exchange conversational context, instructions, and complex, multi-part results.</li> </ul> </li> <li>Use Cases:<ul> <li>A customer service agent delegating a complex billing inquiry to a specialized billing agent, maintaining context of the customer interaction.</li> <li>A travel planning agent coordinating with separate flight, hotel, and activity booking agents, managing a multi-stage booking process.</li> <li>Agents exchanging information and status updates for a collaborative project that evolves over time.</li> </ul> </li> <li>Key Difference from Tool Interaction: A2A allows for more dynamic, stateful, and potentially multi-modal interactions than typically seen with simple tool calls. Agents using A2A communicate as agents (or on behalf of users) rather than just invoking a discrete function.</li> </ul>"},{"location":"topics/a2a-and-mcp/#how-a2a-and-mcp-complement-each-other","title":"How A2A and MCP Complement Each Other","text":"<p>A2A and MCP are not mutually exclusive; they are highly complementary and address different layers of an agentic system's interaction needs.</p> <p></p> <p>An agentic application might use A2A to communicate with other agents, while each agent internally uses MCP to interact with its specific tools and resources.</p>"},{"location":"topics/a2a-and-mcp/#example-scenario-the-auto-repair-shop","title":"Example Scenario: The Auto Repair Shop","text":"<p>Consider an auto repair shop staffed by autonomous AI agent \"mechanics\" who use special-purpose tools (such as vehicle jacks, multimeters, and socket wrenches) to diagnose and repair problems. The workers often have to diagnose and repair problems they have not seen before. The repair process can involve extensive conversations with a customer, research, and working with part suppliers.</p> <ol> <li> <p>Customer Interaction (User-to-Agent via A2A):</p> <ul> <li>A customer (or their primary assistant agent) uses A2A to communicate with the \"Shop Manager\" agent: \"My car is making a rattling noise.\"</li> <li>The Shop Manager agent uses A2A for a multi-turn diagnostic conversation: \"Can you send a video of the noise?\", \"I see some fluid leaking. How long has this been happening?\"</li> </ul> </li> <li> <p>Internal Tool Usage (Agent-to-Tool via MCP):</p> <ul> <li>The Mechanic agent, assigned the task by the Shop Manager, needs to diagnose the issue. It uses MCP to interact with its specialized tools:<ul> <li>MCP call to a \"Vehicle Diagnostic Scanner\" tool: <code>scan_vehicle_for_error_codes(vehicle_id='XYZ123')</code>.</li> <li>MCP call to a \"Repair Manual Database\" tool: <code>get_repair_procedure(error_code='P0300', vehicle_make='Toyota', vehicle_model='Camry')</code>.</li> <li>MCP call to a \"Platform Lift\" tool: <code>raise_platform(height_meters=2)</code>.</li> </ul> </li> </ul> </li> <li> <p>Supplier Interaction (Agent-to-Agent via A2A):</p> <ul> <li>The Mechanic agent determines a specific part is needed. It uses A2A to communicate with a \"Parts Supplier\" agent: \"Do you have part #12345 in stock for a Toyota Camry 2018?\"</li> <li>The Parts Supplier agent, also an A2A-compliant system, responds, potentially leading to an order.</li> </ul> </li> </ol> <p>In this example:</p> <ul> <li>A2A facilitates the higher-level, conversational, and task-oriented interactions between the customer and the shop, and between the shop's agents and external supplier agents.</li> <li>MCP enables the mechanic agent to use its specific, structured tools to perform its diagnostic and repair functions.</li> </ul>"},{"location":"topics/a2a-and-mcp/#representing-a2a-agents-as-mcp-resources","title":"Representing A2A Agents as MCP Resources","text":"<p>It's conceivable that an A2A Server (a remote agent) could also expose some of its skills as MCP-compatible resources, especially if those skills are well-defined and can be invoked in a more tool-like, stateless manner. In such a case, another agent might \"discover\" this A2A agent's specific skill via an MCP-style tool description (perhaps derived from its Agent Card).</p> <p>However, the primary strength of A2A lies in its support for more flexible, stateful, and collaborative interactions that go beyond typical tool invocation. A2A is about agents partnering on tasks, while MCP is more about agents using capabilities.</p> <p>By leveraging both A2A for inter-agent collaboration and MCP for tool integration, developers can build more powerful, flexible, and interoperable AI systems.</p>"},{"location":"topics/agent-discovery/","title":"Agent Discovery in A2A","text":"<p>For AI agents to collaborate using the Agent2Agent (A2A) protocol, they first need to find each other and understand what capabilities the other agents offer. A2A standardizes the format of an agent's self-description through the Agent Card. However, the methods for discovering these Agent Cards can vary depending on the environment and requirements.</p>"},{"location":"topics/agent-discovery/#the-role-of-the-agent-card","title":"The Role of the Agent Card","text":"<p>The Agent Card is a JSON document that serves as a digital \"business card\" for an A2A Server (the remote agent). It is crucial for discovery and initiating interaction. Key information typically included in an Agent Card:</p> <ul> <li>Identity: <code>name</code>, <code>description</code>, <code>provider</code> information.</li> <li>Service Endpoint: The <code>url</code> where the A2A service can be reached.</li> <li>A2A Capabilities: Supported protocol features like <code>streaming</code> or <code>pushNotifications</code>.</li> <li>Authentication: Required authentication <code>schemes</code> (e.g., \"Bearer\", \"OAuth2\") to interact with the agent.</li> <li>Skills: A list of specific tasks or functions the agent can perform (<code>AgentSkill</code> objects), including their <code>id</code>, <code>name</code>, <code>description</code>, <code>inputModes</code>, <code>outputModes</code>, and <code>examples</code>.</li> </ul> <p>Client agents parse the Agent Card to determine if a remote agent is suitable for a given task, how to structure requests for its skills, and how to communicate with it securely.</p>"},{"location":"topics/agent-discovery/#discovery-strategies","title":"Discovery Strategies","text":"<p>Here are common strategies for how a client agent might discover the Agent Card of a remote agent:</p>"},{"location":"topics/agent-discovery/#1-well-known-uri","title":"1. Well-Known URI","text":"<p>This is a recommended approach for public agents or agents intended for broad discoverability within a specific domain.</p> <ul> <li>Mechanism: A2A Servers host their Agent Card at a standardized, \"well-known\" path on their domain.</li> <li>Standard Path: <code>https://{agent-server-domain}/.well-known/agent-card.json</code> (following the principles of RFC 8615 for well-known URIs).</li> <li>Process:<ol> <li>A client agent knows or programmatically discovers the domain of a potential A2A Server (e.g., <code>smart-thermostat.example.com</code>).</li> <li>The client performs an HTTP <code>GET</code> request to <code>https://smart-thermostat.example.com/.well-known/agent-card.json</code>.</li> <li>If the Agent Card exists and is accessible, the server returns it as a JSON response.</li> </ol> </li> <li>Advantages: Simple, standardized, and enables automated discovery by crawlers or systems that can resolve domains. Effectively reduces the discovery problem to \"find the agent's domain.\"</li> <li>Considerations: Best suited for agents intended for open discovery or discovery within an organization that controls the domain. The endpoint serving the Agent Card may itself require authentication if the card contains sensitive information.</li> </ul>"},{"location":"topics/agent-discovery/#2-curated-registries-catalog-based-discovery","title":"2. Curated Registries (Catalog-Based Discovery)","text":"<p>For enterprise environments, marketplaces, or specialized ecosystems, Agent Cards can be published to and discovered via a central registry or catalog.</p> <ul> <li>Mechanism: An intermediary service (the registry) maintains a collection of Agent Cards. Clients query this registry to find agents based on various criteria (e.g., skills offered, tags, provider name, desired capabilities).</li> <li>Process:<ol> <li>A2A Servers (or their administrators) register their Agent Cards with the registry service. The mechanism for this registration is outside the scope of the A2A protocol itself.</li> <li>Client agents query the registry's API (e.g., \"find agents with 'image-generation' skill that support streaming\").</li> <li>The registry returns a list of matching Agent Cards or references to them.</li> </ol> </li> <li>Advantages:<ul> <li>Centralized management, curation, and governance of available agents.</li> <li>Facilitates discovery based on functional capabilities rather than just domain names.</li> <li>Can implement access controls, policies, and trust mechanisms at the registry level.</li> <li>Enables scenarios like company-specific or team-specific agent catalogs, or public marketplaces of A2A-compliant agents.</li> </ul> </li> <li>Considerations: Requires an additional registry service. The A2A protocol does not currently define a standard API for such registries, though this is an area of potential future exploration and community standardization.</li> </ul>"},{"location":"topics/agent-discovery/#3-direct-configuration-private-discovery","title":"3. Direct Configuration / Private Discovery","text":"<p>In many scenarios, especially within tightly coupled systems, for private agents, or during development and testing, clients might be directly configured with Agent Card information or a URL to fetch it.</p> <ul> <li>Mechanism: The client application has hardcoded Agent Card details, reads them from a local configuration file, receives them through an environment variable, or fetches them from a private, proprietary API endpoint known to the client.</li> <li>Process: This is highly specific to the application's deployment and configuration strategy.</li> <li>Advantages: Simple and effective for known, static relationships between agents or when dynamic discovery is not a requirement.</li> <li>Considerations: Less flexible for discovering new or updated agents dynamically. Changes to the remote agent's card might require re-configuration of the client. Proprietary API-based discovery is not standardized by A2A.</li> </ul>"},{"location":"topics/agent-discovery/#securing-agent-cards","title":"Securing Agent Cards","text":"<p>Agent Cards themselves can sometimes contain information that should be protected, such as:</p> <ul> <li>The <code>url</code> of an internal-only or restricted-access agent.</li> <li>Details in the <code>authentication.credentials</code> field if it's used for scheme-specific, non-secret information (e.g., an OAuth token URL). Storing actual plaintext secrets in an Agent Card is strongly discouraged.</li> <li>Descriptions of sensitive or internal skills.</li> </ul> <p>Protection Mechanisms:</p> <ul> <li>Access Control on the Endpoint: The HTTP endpoint serving the Agent Card (whether it's the <code>/.well-known/agent-card.json</code> path, a registry API, or a custom URL) should be secured using standard web practices if the card is not intended for public, unauthenticated access.<ul> <li>mTLS: Require mutual TLS for client authentication if appropriate for the trust model.</li> <li>Network Restrictions: Limit access to specific IP ranges, VPCs, or private networks.</li> <li>Authentication: Require standard HTTP authentication (e.g., OAuth 2.0 Bearer token, API Key) to access the Agent Card itself.</li> </ul> </li> <li>Selective Disclosure by Registries: Agent registries can implement logic to return different Agent Cards or varying levels of detail based on the authenticated client's identity and permissions. For example, a public query might return a limited card, while an authenticated partner query might receive a card with more details.</li> </ul> <p>It's crucial to remember that if an Agent Card were to contain sensitive data (again, not recommended for secrets), the card itself must never be available without strong authentication and authorization. The A2A protocol encourages authentication schemes where the client obtains dynamic credentials out-of-band, rather than relying on static secrets embedded in the Agent Card.</p>"},{"location":"topics/agent-discovery/#future-considerations","title":"Future Considerations","text":"<p>The A2A community may explore standardizing aspects of registry interactions or more advanced, semantic discovery protocols in the future. Feedback and contributions in this area are welcome to enhance the discoverability and interoperability of A2A agents.</p>"},{"location":"topics/enterprise-ready/","title":"Enterprise-Ready Features for A2A Agents","text":"<p>The Agent2Agent (A2A) protocol is designed with enterprise requirements at its core. Instead of inventing new, proprietary standards for security and operations, A2A aims to integrate seamlessly with existing enterprise infrastructure and widely adopted best practices. A2A treats remote agents as standard, HTTP-based enterprise applications. This approach allows organizations to leverage their existing investments and expertise in security, monitoring, governance, and identity management.</p> <p>A key principle of A2A is that agents are typically \"opaque\" \u2013 they do not share internal memory, tools, or direct resource access with each other. This opacity naturally aligns with standard client/server security paradigms.</p>"},{"location":"topics/enterprise-ready/#1-transport-level-security-tls","title":"1. Transport Level Security (TLS)","text":"<p>Ensuring the confidentiality and integrity of data in transit is fundamental.</p> <ul> <li>HTTPS Mandate: All A2A communication in production environments MUST occur over HTTPS.</li> <li>Modern TLS Standards: Implementations SHOULD use modern TLS versions (TLS 1.2 or higher is recommended) with strong, industry-standard cipher suites to protect data from eavesdropping and tampering.</li> <li>Server Identity Verification: A2A Clients SHOULD verify the A2A Server's identity by validating its TLS certificate against trusted certificate authorities (CAs) during the TLS handshake. This prevents man-in-the-middle attacks.</li> </ul>"},{"location":"topics/enterprise-ready/#2-authentication","title":"2. Authentication","text":"<p>A2A delegates authentication to standard web mechanisms, primarily relying on HTTP headers and established standards like OAuth2 and OpenID Connect. Authentication requirements are advertised by the A2A Server in its Agent Card.</p> <ul> <li>No In-Payload Identity: A2A protocol payloads (JSON-RPC messages) do not carry user or client identity information. Identity is established at the transport/HTTP layer.</li> <li>Agent Card Declaration: The A2A Server's <code>AgentCard</code> describes the authentication <code>schemes</code> it supports in its <code>security</code> field. Each named scheme in this field is an identifier specific to the card. The details for each named scheme, including the scheme type, can be provided in the <code>securitySchemes</code> field of the Agent Card. The supported names of the scheme types (\"apiKey\", \"http\", \"oauth2\", \"openIdConnect\") align with those defined in the OpenAPI Specification for authentication.</li> <li>Out-of-Band Credential Acquisition: The A2A Client is responsible for obtaining the necessary credential materials (e.g., OAuth 2.0 tokens, either in JWT format or some other format; API keys; or other) through processes external to the A2A protocol itself. This could involve OAuth flows (authorization code, client credentials), secure key distribution, etc.</li> <li>HTTP Header Transmission: Credentials MUST be transmitted in standard HTTP headers as per the requirements of the chosen authentication scheme (e.g., <code>Authorization: Bearer &lt;token&gt;</code>, <code>API-Key: &lt;key_value&gt;</code>).</li> <li>Server-Side Validation: The A2A Server MUST authenticate every incoming request based on the credentials provided in the HTTP headers and its declared requirements.<ul> <li>If authentication fails or is missing, the server SHOULD respond with standard HTTP status codes such as <code>401 Unauthorized</code> or <code>403 Forbidden</code>.</li> <li>A <code>401 Unauthorized</code> response SHOULD include a <code>WWW-Authenticate</code> header indicating the required scheme(s), guiding the client on how to authenticate correctly.</li> </ul> </li> <li>In-Task Authentication (Secondary Credentials): If an agent, during a task, requires additional credentials for a different system (e.g., to access a specific tool on behalf of the user), A2A recommends:<ol> <li>The A2A Server transitions the A2A task to the <code>input-required</code> state.</li> <li>The <code>TaskStatus.message</code> (often using a <code>DataPart</code>) should provide details about the required authentication for the secondary system, potentially using an <code>AuthenticationInfo</code>-like structure.</li> <li>The A2A Client then obtains these new credentials out-of-band for the secondary system. These credentials might be provided back to the A2A Server (if it's proxying the request) or used by the client to interact directly with the secondary system.</li> </ol> </li> </ul>"},{"location":"topics/enterprise-ready/#3-authorization","title":"3. Authorization","text":"<p>Once a client is authenticated, the A2A Server is responsible for authorizing the request. Authorization logic is specific to the agent's implementation, the data it handles, and applicable enterprise policies.</p> <ul> <li>Granular Control: Authorization SHOULD be applied based on the authenticated identity (which could represent an end user, a client application, or both).</li> <li>Skill-Based Authorization: Access can be controlled on a per-skill basis, as advertised in the Agent Card. For example, specific OAuth scopes might grant an authenticated client access to invoke certain skills but not others.</li> <li>Data and Action-Level Authorization: Agents that interact with backend systems, databases, or tools MUST enforce appropriate authorization before performing sensitive actions or accessing sensitive data through those underlying resources. The agent acts as a gatekeeper.</li> <li>Principle of Least Privilege: Grant only the necessary permissions required for a client or user to perform their intended operations via the A2A interface.</li> </ul>"},{"location":"topics/enterprise-ready/#4-data-privacy-and-confidentiality","title":"4. Data Privacy and Confidentiality","text":"<ul> <li>Sensitivity Awareness: Implementers must be acutely aware of the sensitivity of data exchanged in <code>Message</code> and <code>Artifact</code> parts of A2A interactions.</li> <li>Compliance: Ensure compliance with relevant data privacy regulations (e.g., GDPR, CCPA, HIPAA, depending on the domain and data).</li> <li>Data Minimization: Avoid including or requesting unnecessarily sensitive information in A2A exchanges.</li> <li>Secure Handling: Protect data both in transit (via TLS, as mandated) and at rest (if persisted by agents) according to enterprise data security policies and regulatory requirements.</li> </ul>"},{"location":"topics/enterprise-ready/#5-tracing-observability-and-monitoring","title":"5. Tracing, Observability, and Monitoring","text":"<p>A2A's reliance on HTTP allows for straightforward integration with standard enterprise tracing, logging, and monitoring tools.</p> <ul> <li>Distributed Tracing:<ul> <li>A2A Clients and Servers SHOULD participate in distributed tracing systems (e.g., OpenTelemetry, Jaeger, Zipkin).</li> <li>Trace context (trace IDs, span IDs) SHOULD be propagated via standard HTTP headers (e.g., W3C Trace Context headers like <code>traceparent</code> and <code>tracestate</code>).</li> <li>This enables end-to-end visibility of requests as they flow across multiple agents and underlying services, which is invaluable for debugging and performance analysis.</li> </ul> </li> <li>Comprehensive Logging: Implement detailed logging on both client and server sides. Logs should include relevant identifiers such as <code>taskId</code>, <code>sessionId</code>, correlation IDs, and trace context to facilitate troubleshooting and auditing.</li> <li>Metrics: A2A Servers should expose key operational metrics (e.g., request rates, error rates, task processing latency, resource utilization) to enable performance monitoring, alerting, and capacity planning. These can be integrated with systems like Prometheus or Google Cloud Monitoring.</li> <li>Auditing: Maintain audit trails for significant events, such as task creation, critical state changes, and actions performed by agents, especially those involving sensitive data access, modifications, or high-impact operations.</li> </ul>"},{"location":"topics/enterprise-ready/#6-api-management-and-governance","title":"6. API Management and Governance","text":"<p>For A2A Servers exposed externally, across organizational boundaries, or even within large enterprises, integration with API Management solutions is highly recommended. This can provide:</p> <ul> <li>Centralized Policy Enforcement: Consistent application of security policies (authentication, authorization), rate limiting, and quotas.</li> <li>Traffic Management: Load balancing, routing, and mediation.</li> <li>Analytics and Reporting: Insights into agent usage, performance, and trends.</li> <li>Developer Portals: Facilitate discovery of A2A-enabled agents, provide documentation (including Agent Cards), and streamline onboarding for client developers.</li> </ul> <p>By adhering to these enterprise-grade practices, A2A implementations can be deployed securely, reliably, and manageably within complex organizational environments, fostering trust and enabling scalable inter-agent collaboration.</p>"},{"location":"topics/extensions/","title":"Extensions","text":""},{"location":"topics/extensions/#abstract","title":"Abstract","text":"<p>Extensions are a means of extending the Agent2Agent (A2A) protocol with new data, requirements, methods, and state machines. Agents declare their support for extensions in their <code>AgentCard</code>, and clients can then opt-in to the behavior offered by the extension as part of requests they make to the agent. Extensions are identified by a URI and defined by their extension specification. Anyone is able to define, publish, and implement an extension.</p>"},{"location":"topics/extensions/#introduction","title":"Introduction","text":"<p>The core A2A protocol is a solid basis for enabling communication between agents. However, it's clear that some domains require additional structure than what is offered by the generic methods in the protocol. Extensions were added to the protocol to help support these cases: with extensions, agents and clients can negotiate additional, custom logic to be layered on top of the core protocol.</p>"},{"location":"topics/extensions/#scope-of-extensions","title":"Scope of Extensions","text":"<p>The exact set of possible ways to use extensions is intentionally not defined. This is to facilitate the ability to use extensions to expand A2A beyond currently known use cases. However, some use cases are clearly forseeable, such as:</p> <ul> <li> <p>Exposing new information in the <code>AgentCard</code>. An extension may not impact the request/response flow at all -- it can be simply used as a way to convey additional structured information to clients via the <code>AgentCard</code>. We refer to these as data-only extensions. For example, an extension could add structured data about an agent's GDPR compliance to its <code>AgentCard</code>.</p> </li> <li> <p>Overlaying additional structure and state change requirements on the core request/response messages. An extension could, for example, require that all messages use <code>DataPart</code>s that adhere to a specific schema. This type of extension effectively acts as a profile on the core A2A protocol, narrowing the space of allowed values. We refer to these as profile extensions. For example, a healthcare extension could mandate that all <code>Message</code> parts containing patient information must be encrypted and placed within a <code>DataPart</code> that conforms to a FHIR standard.</p> </li> <li> <p>Adding new RPC methods entirely. Extensions may define that the agent implements more than the core set of protocol methods. We refer to these as method extensions. For example, a 'task-history' extension might add a <code>tasks/search</code> RPC method to retrieve a list of previous tasks.</p> </li> </ul> <p>There are some changes to the protocol that extensions do not allow. These are:</p> <ul> <li>Changing the definition of core data structures. Adding new fields or removing required fields to protocol-defined data structures is not supported. Extensions are expected to place custom attributes in the <code>metadata</code> map that is present on core data structures.</li> <li>Adding new values to enum types. Instead, extensions should use existing enum values and annotate additional semantic meaning in the <code>metadata</code> field.</li> </ul> <p>These limitations exist to prevent extensions from breaking core type validations that clients and agents perform.</p>"},{"location":"topics/extensions/#architecture-overview","title":"Architecture Overview","text":"<p>TODO: A diagram outlining the components and their connections.</p>"},{"location":"topics/extensions/#extension-declaration","title":"Extension Declaration","text":"<p>Agents declare their support for extensions in their <code>AgentCard</code> by including <code>AgentExtension</code> objects in their <code>AgentCapabilities</code> object.</p> Field Name Type Required Description <code>uri</code> <code>string</code> Yes The URI of the extension. This is an arbitrary identifier that the extension specification defines. Implementations of an extension use this URI to identify when to activate, and clients use this to determine extension compatibility. extension. <code>required</code> <code>boolean</code> No Whether the agent requires clients to use this extension. <code>description</code> <code>string</code> No A description of how the agent uses the declared extension. Full details of a extension are intended to be in an extension specification. This field is useful to explain the connection between the agent and the extension. <code>params</code> <code>object</code> No Extension-specific configuration. The expected values to be placed in this field, if any, are defined by the extension specification. This field can be used for specifying parameters of the extension or declaring additional agent-specific data. <p>An example <code>AgentCard</code> showing extensions:</p> <pre><code>{\n    \"name\": \"Magic 8-ball\",\n    \"description\": \"An agent that can tell your future... maybe.\",\n    \"version\": \"0.1.0\",\n    \"url\": \"https://example.com/agents/eightball\",\n    \"capabilities\": {\n        \"streaming\": true,\n        \"extensions\": [\n            {\n                \"uri\": \"https://example.com/ext/konami-code/v1\",\n                \"description\": \"Provide cheat codes to unlock new fortunes\",\n                \"required\": false,\n                \"params\": {\n                    \"hints\": [\n                        \"When your sims need extra cash fast\",\n                        \"You might deny it, but we've seen the evidence of those cows.\"\n                    ]\n                }\n            }\n        ]\n    },\n    \"defaultInputModes\": [\"text/plain\"],\n    \"defaultOutputModes\": [\"text/plain\"],\n    \"skills\": [\n        {\n            \"id\": \"fortune\",\n            \"name\": \"Fortune teller\",\n            \"description\": \"Seek advice from the mystical magic 8-ball\",\n            \"tags\": [\"mystical\", \"untrustworthy\"]\n        }\n    ]\n}\n</code></pre>"},{"location":"topics/extensions/#required-extensions","title":"Required Extensions","text":"<p>While extensions are a means of enabling additional functionality, we anticipate that some agents will have stricter requirements than those expressible by the core A2A protocol. For example, an agent may require that all incoming messages are cryptographically signed by their author. Extensions that are declared <code>required</code> are intended to support this use case.</p> <p>When an <code>AgentCard</code> declares a required extension, this is a signal to clients that some aspect of the extension impacts how requests are structured. Agents should not mark data-only extensions as required, since there is no direct impact on how requests are made to the agent.</p> <p>If an <code>AgentCard</code> declares a required extension, and the client does not request activation of that required extension, Agents should return reject the incoming request and return an appropriate error code.</p> <p>If a client requests extension activation, but does not follow an extension-defined protocol, the Agent should reject the request and return an appropriate validation failure message.</p>"},{"location":"topics/extensions/#extension-specification","title":"Extension Specification","text":"<p>The details of an extension are defined by a specification. The exact format of this document is not specified, however it should contain at least:</p> <ul> <li> <p>The specific URI(s) that extension implementations should identify and respond to. Multiple URIs may identify the same extension to account for versioning or changes in location of the specification document. Extension authors are encouraged to use a permanent identifier service, such as w3id, to avoid a proliferation of URLs.</p> </li> <li> <p>The schema and meaning of objects specified in the <code>params</code> field of the <code>AgentExtension</code> object exposed in the <code>AgentCard</code>.</p> </li> <li> <p>The schemas of any additional data structures communicated between client and agent.</p> </li> <li> <p>Details of request/response flows, additional endpoints, or any other logic required to implement the extension.</p> </li> </ul>"},{"location":"topics/extensions/#extension-dependencies","title":"Extension Dependencies","text":"<p>Extensions may depend on other extensions. This dependency may be required, where the core functionality of the extension is unable to run without the presence of the dependent, or optional, where some additional functionality is enabled when another extension is present. Extension specifications should document the dependency and its type.</p> <p>Dependencies are declared within the extension's specification, not in the <code>AgentExtension</code> object. It is the responsibility of the client to activate an extension and all of its required dependencies as listed in the extension's specification.</p>"},{"location":"topics/extensions/#extension-activation","title":"Extension Activation","text":"<p>Extensions should default to being inactive. This provides a \"default to baseline\" experience, where extension-unaware clients are not burdened by the details and data provided by an extension. Instead, clients and agents perform negotiation to determine which extensions are active for a request. This negotiation is initiated by the client including the <code>X-A2A-Extensions</code> header in the HTTP request to the agent. The value of this header should be a list of extension URIs that the client is intending to activate.</p> <p>Clients may request activation of any extension. Agents are responsible for identifying supported extensions in the request and performing the activation. Any requested extensions that are not supported by the agent can be ignored.</p> <p>Not all extensions are activatable: data-only extensions exist solely to provide additional information via an AgentCard. Clients may still request activation of these extensions. Since the extension does not perform any additional logic upon activation, this should have no impact on the request.</p> <p>Some extensions may have additional pre-requisites for activation. For example, some sensitive extensions may have a corresponding access-control list dictating who is allowed to activate the extension. It is up to the agent to determine which of the requested extensions are activated.</p> <p>If a client requests activation of an extension with a required dependency, that client must also request activation of, and adhere to requirements of, that dependent extension. If the client does not request all required dependencies for a requested extension, the server may fail the request with an appropriate error.</p> <p>Once the agent has identified all activated extensions, the response should include the <code>X-A2A-Extensions</code> header identifying all extensions that were activated.</p> <p>An example request showing extension activation:</p> <pre><code>POST /agents/eightball HTTP/1.1\nHost: example.com\nContent-Type: application/json\nX-A2A-Extensions: https://example.com/ext/konami-code/v1\nContent-Length: 519\n\n{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"message/send\",\n  \"id\": \"1\",\n  \"params\": {\n    \"message\": {\n        \"kind\": \"message\",\n        \"messageId\": \"1\",\n        \"role\": \"user\",\n        \"parts\": [{\"kind\": \"text\", \"text\": \"Oh magic 8-ball, will it rain today?\"}]\n    },\n    \"metadata\": {\n        \"https://example.com/ext/konami-code/v1/code\": \"motherlode\",\n    }\n  }\n}\n</code></pre> <p>And corresponding response echoing the activated extensions:</p> <pre><code>HTTP/1.1 200 OK\nContent-Type: application/json\nX-A2A-Extensions: https://example.com/ext/konami-code/v1\nContent-Length: 338\n\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"1\",\n  \"result\": {\n    \"kind\": \"message\",\n    \"messageId\": \"2\",\n    \"role\": \"agent\",\n    \"parts\": [{\"kind\": \"text\", \"text\": \"That's a bingo!\"}],\n  }\n}\n</code></pre>"},{"location":"topics/extensions/#implementation-considerations","title":"Implementation Considerations","text":"<p>While the A2A protocol defines the \"what\" of extensions, this section provides guidance on the \"how\"\u2014best practices for authoring, versioning, and distributing extension implementations.</p>"},{"location":"topics/extensions/#versioning","title":"Versioning","text":"<p>Extension specifications will inevitably evolve. It is crucial to have a clear versioning strategy to ensure that clients and agents can negotiate compatible implementations.</p> <ul> <li>Recommendation: Use the extension's URI as the primary version identifier. We recommend including a version number directly in the URI path, such as <code>https://example.com/ext/my-extension/v1</code> or <code>https://example.com/ext/my-extension/v2</code>.</li> <li>Breaking Changes: A new URI MUST be used when introducing a breaking change to an extension's logic, data structures, or required parameters. This prevents ambiguity and ensures that an agent supporting <code>/v1</code> does not incorrectly process a <code>/v2</code> request.</li> <li>Handling Mismatches: If a client requests a version of an extension that the agent does not support (e.g., client requests <code>/v2</code> but the agent only supports <code>/v1</code>), the agent SHOULD ignore the activation request for that extension. The agent MUST NOT attempt to \"fall back\" to a different version, as the client's logic is explicitly tied to the requested version.</li> </ul>"},{"location":"topics/extensions/#discoverability-and-publication","title":"Discoverability and Publication","text":"<p>For an extension to be useful, other developers need to be able to find its specification and understand how to use it.</p> <ul> <li>Specification Hosting: The extension specification document SHOULD be hosted at the extension's URI. This allows developers to easily access the documentation by simply resolving the identifier.</li> <li>Permanent Identifiers: To prevent issues with broken links or changing domains, authors are encouraged to use a permanent identifier service, such as w3id.org, for their extension URIs.</li> <li>Community Registry (Future): In the future, the A2A community may establish a central registry for discovering and Browse available extensions.</li> </ul>"},{"location":"topics/extensions/#packaging-and-reusability","title":"Packaging and Reusability","text":"<p>To promote adoption, extension logic should be packaged into reusable libraries that can be easily integrated into existing A2A client and server applications.</p> <ul> <li> <p>Distribution: An extension implementation should be distributed as a standard package for its language ecosystem (e.g., a PyPI package for Python, an npm package for TypeScript/JavaScript).</p> </li> <li> <p>Simplified Integration: The goal should be a near \"plug-and-play\" experience for developers. A well-designed extension package should allow a developer to add it to their server with minimal code, for example:</p> <pre><code># Hypothetical Python Server Integration\nfrom konami_code_extension import CheatCodeHandler\nfrom a2a.server import A2AServer, DefaultRequestHandler\n\n# The extension hooks into the request handler to process its logic\nextension = CheatCodeHandler(description=\"\")\nextension.add_cheat(\n    code=\"motherlode\",\n    hint=\"When your sims need extra cash fast\",\n)\nextension.add_cheat(\n    code=\"thereisnocowlevel\",\n    hint=\"You might deny it, but we've seen the evidence of those cows.\",\n)\nrequest_handler = DefaultRequestHandler(\n    agent_executor=MyAgentExecutor(extension),\n    task_store=InMemoryTaskStore(),\n    extensions=[extension]\n)\n\nserver = A2AServer(agent_card, request_handler)\nserver.run()\n</code></pre> </li> </ul>"},{"location":"topics/extensions/#security","title":"Security","text":"<p>Extensions modify the core behavior of the A2A protocol and therefore introduce new security considerations.</p> <ul> <li>Input Validation: Any new data fields, parameters, or methods introduced by an extension MUST be rigorously validated by the implementation. Treat all extension-related data from an external party as untrusted input, unless there are protocol-defined means for establishing trust.</li> <li>Scope of <code>required</code> extensions: Be mindful when marking an extension as <code>required: true</code> in an <code>AgentCard</code>. This creates a hard dependency for all clients. Only use this for extensions that are fundamental to the agent's core function and security posture (e.g., a message signing extension).</li> <li>Authentication and Authorization: If an extension adds new methods, the implementation MUST ensure that these methods are subject to the same authentication and authorization checks as the core A2A methods. An extension MUST NOT provide a way to bypass the agent's primary security controls.</li> </ul>"},{"location":"topics/key-concepts/","title":"Key Concepts in A2A","text":"<p>The Agent2Agent (A2A) protocol is built around a set of core concepts that define how agents interact. Understanding these concepts is crucial for developing or integrating with A2A-compliant systems.</p> <p></p>"},{"location":"topics/key-concepts/#core-actors","title":"Core Actors","text":"<ul> <li>User: The end user (human or automated service) who initiates a request or goal that requires agent assistance.</li> <li>A2A Client (Client Agent): An application, service, or another AI agent that acts on behalf of the user to request actions or information from a remote agent. The client initiates communication using the A2A protocol.</li> <li>A2A Server (Remote Agent): An AI agent or agentic system that exposes an HTTP endpoint implementing the A2A protocol. It receives requests from clients, processes tasks, and returns results or status updates. The remote agent operates as an \"opaque\" system from the client's perspective, meaning the client doesn't need to know its internal workings, memory, or tools.</li> </ul>"},{"location":"topics/key-concepts/#fundamental-communication-elements","title":"Fundamental Communication Elements","text":"<ul> <li> <p>Agent Card:</p> <ul> <li>A JSON metadata document, typically discoverable at a well-known URL (e.g., <code>/.well-known/agent-card.json</code>), that describes an A2A Server.</li> <li>It details the agent's identity (name, description), service endpoint URL, version, supported A2A capabilities (like streaming or push notifications), specific skills it offers, default input/output modalities, and authentication requirements.</li> <li>Clients use the Agent Card to discover agents and understand how to interact with them securely and effectively.</li> <li>See details in the Protocol Specification: Agent Card.</li> </ul> </li> <li> <p>Task:</p> <ul> <li>When a client sends a message to an agent, the agent might determine that fulfilling the request requires a stateful task to be completed (e.g., \"generate a report,\" \"book a flight,\" \"answer a question\").</li> <li>Each task has a unique ID defined by the agent and progresses through a defined lifecycle (e.g., <code>submitted</code>, <code>working</code>, <code>input-required</code>, <code>completed</code>, <code>failed</code>).</li> <li>Tasks are stateful and can involve multiple exchanges (messages) between the client and the server.</li> <li>See details in the Life of a Task.</li> <li>Protocol specification: Task Object.</li> </ul> </li> <li> <p>Message:</p> <ul> <li>Represents a single turn or unit of communication between a client and an agent.</li> <li>Messages have a <code>role</code> (either <code>\"user\"</code> for client-sent messages or <code>\"agent\"</code> for server-sent messages) and contain one or more <code>Part</code> objects that carry the actual content. <code>messageId</code> part of the Message object is a unique identifier for each message set by the sender of the message.</li> <li>Used for conveying instructions, context, questions, answers, or status updates that are not necessarily formal <code>Artifacts</code> that are part of a <code>Task</code>.</li> <li>See details in the Protocol Specification: Message Object.</li> </ul> </li> <li> <p>Part:</p> <ul> <li>The fundamental unit of content within a <code>Message</code> or an <code>Artifact</code>. Each part has a specific <code>type</code> and can carry different kinds of data:<ul> <li><code>TextPart</code>: Contains plain textual content.</li> <li><code>FilePart</code>: Represents a file, which can be transmitted as inline base64-encoded bytes or referenced via a URI. Includes metadata like filename and Media Type.</li> <li><code>DataPart</code>: Carries structured JSON data, useful for forms, parameters, or any machine-readable information.</li> </ul> </li> <li>See details in the Protocol Specification: Part Union Type.</li> </ul> </li> <li> <p>Artifact:</p> <ul> <li>Represents a tangible output or result generated by the remote agent during the processing of a task.</li> <li>Examples include generated documents, images, spreadsheets, structured data results, or any other self-contained piece of information that is a direct result of the task.</li> <li>Tasks in completed state SHOULD use artifact objects for returning the generated output to the clients.</li> <li>Artifacts are composed of one or more <code>Part</code> objects and can be streamed incrementally.</li> <li>See details in the Protocol Specification: Artifact Object.</li> </ul> </li> </ul>"},{"location":"topics/key-concepts/#interaction-mechanisms","title":"Interaction Mechanisms","text":"<ul> <li> <p>Request/Response (Polling):</p> <ul> <li>The client sends a request (e.g., using the <code>message/send</code> RPC method) and receives a response from the server.</li> <li>If the interaction requires a stateful long-running task, the server might initially respond with a <code>working</code> status. The client would then periodically call <code>tasks/get</code> to poll for updates until the task reaches a terminal state (e.g., <code>completed</code>, <code>failed</code>).</li> </ul> </li> <li> <p>Streaming (Server-Sent Events - SSE):</p> <ul> <li>For tasks that produce results incrementally or provide real-time progress updates.</li> <li>The client initiates an interaction with the server using <code>message/stream</code>.</li> <li>The server responds with an HTTP connection that remains open, over which it sends a stream of Server-Sent Events (SSE).</li> <li>These events can be <code>Task</code>, <code>Message</code>, or <code>TaskStatusUpdateEvent</code> (for status changes) or <code>TaskArtifactUpdateEvent</code> (for new or updated artifact chunks).</li> <li>This requires the server to advertise the <code>streaming</code> capability in its Agent Card.</li> <li>Learn more about Streaming &amp; Asynchronous Operations.</li> </ul> </li> <li> <p>Push Notifications:</p> <ul> <li>For very long-running tasks or scenarios where maintaining a persistent connection (like SSE) is impractical.</li> <li>The client can provide a webhook URL when initiating a task (or by calling <code>tasks/pushNotificationConfig/set</code>).</li> <li>When the task status changes significantly (e.g., completes, fails, or requires input), the server can send an asynchronous notification (an HTTP POST request) to this client-provided webhook.</li> <li>This requires the server to advertise the <code>pushNotifications</code> capability in its Agent Card.</li> <li>Learn more about Streaming &amp; Asynchronous Operations.</li> </ul> </li> </ul>"},{"location":"topics/key-concepts/#agent-response-task-or-message","title":"Agent Response: Task or Message","text":"<p>See details in the Life of a Task.</p>"},{"location":"topics/key-concepts/#other-important-concepts","title":"Other Important Concepts","text":"<ul> <li>Context (<code>contextId</code>): A server-generated identifier that can be used to logically group multiple related <code>Task</code> objects, providing context across a series of interactions.</li> <li>Transport and Format: A2A communication occurs over HTTP(S). JSON-RPC 2.0 is used as the payload format for all requests and responses.</li> <li>Authentication &amp; Authorization: A2A relies on standard web security practices. Authentication requirements are declared in the Agent Card, and credentials (e.g., OAuth tokens, API keys) are typically passed via HTTP headers, separate from the A2A protocol messages themselves.<ul> <li>Learn more about Enterprise-Ready Features.</li> </ul> </li> <li>Agent Discovery: The process by which clients find Agent Cards to learn about available A2A Servers and their capabilities.<ul> <li>Learn more about Agent Discovery.</li> </ul> </li> <li>Extensions: A2A allows agents to declare custom protocol extensions as part of their AgentCard.<ul> <li>More documentation coming soon.</li> </ul> </li> </ul> <p>By understanding these core components and mechanisms, developers can effectively design, implement, and utilize A2A for building interoperable and collaborative AI agent systems.</p>"},{"location":"topics/life-of-a-task/","title":"Life of a Task","text":"<p>When a message is sent to an agent, it can choose to reply with either:</p> <ul> <li>A stateless <code>Message</code>.</li> <li>A stateful <code>Task</code> followed by zero or more <code>TaskStatusUpdateEvent</code> or <code>TaskArtifactUpdateEvent</code>.</li> </ul> <p>If the response is a <code>Message</code>, the interaction is completed. On the other hand, if the response is a <code>Task</code>, then the task will be processed by the agent, until it is in a interrupted state (<code>input-required</code> or <code>auth-required</code>) or a terminal state (<code>completed</code>, <code>cancelled</code>, <code>rejected</code> or <code>failed</code>).</p>"},{"location":"topics/life-of-a-task/#context","title":"Context","text":"<p>A <code>contextId</code> logically composes many <code>Task</code> objects and independent <code>Message</code> objects. If the A2A agent uses an LLM internally, it can utilize the <code>contextId</code> to manage the LLM context.</p> <p>For the first message, the agent responds with a server-generated <code>contextId</code>. If the agent creates a task, it will also include a server-generated <code>taskId</code>. Subsequent client messages can include the same <code>contextId</code> to continue the interaction, and optionally the <code>taskId</code> to continue a specific task.</p> <p><code>contextId</code> allows collaboration over a goal or share a single contextual session across multiple tasks.</p>"},{"location":"topics/life-of-a-task/#agent-message-or-a-task","title":"Agent: Message or a Task","text":"<p>Messages can be used for trivial interactions which do not require long-running processing or collaboration. An agent can use messages to negotiate the acceptance of a task. Once an agent maps the intent of an incoming message to a supported capability, it can reply back with a <code>Task</code>.</p> <p>So conceptually there can be three levels of agents:</p> <ol> <li>An agent which always responds with <code>Message</code> objects only. Doesn't do complex state management, no long running execution and uses contextID to tie messages together. Agent most probably directly wraps around an LLM invocation and simple tools.</li> <li>Generates a <code>Task</code>, does more substantial work that can be tracked and runs over extended life time.</li> <li>Generates both <code>Message</code> and <code>Task</code> objects. Uses messages to negotiate agent capability and scope of work for a task. Then sends <code>Task</code> object to track its execution and collaborate over task states like more input-needed, error handling, etc.</li> </ol> <p>An agent can choose to always reply back with <code>Task</code> objects and model simple responses as tasks in <code>completed</code> state.</p>"},{"location":"topics/life-of-a-task/#task-refinements-follow-ups","title":"Task Refinements &amp; Follow-ups","text":"<p>Clients may want to follow up with new asks based on the results of a task, and/or refine upon the task results. This can be modeled by starting another interaction using the same <code>contextId</code> as the original task. Clients can further hint the agent by providing the reference to the original task using <code>referenceTaskIds</code> in <code>Message</code> object. Agent would then respond with either a new <code>Task</code> or a <code>Message</code>.</p> <p>Once a task has reached a terminal state (<code>completed</code>, <code>cancelled</code>, <code>rejected</code> or <code>failed</code>), it can't be restarted. There are some benefits to this:</p> <ul> <li>Task Immutability: Clients can reliably reference tasks and their associated state, artifacts, and messages.<ul> <li>This provides a clean mapping of inputs to outputs.</li> <li>Useful for mapping client orchestrator to task execution.</li> </ul> </li> <li>Clear Unit of Work: Every new request, refinement, or a follow-up becomes a distinct task, simplifying bookkeeping and allowing for granular tracking of an agent's work.<ul> <li>Each artifact can be traced to a unit task.</li> <li>This unit of work can be referenced much more granularly by parent agents or other systems like agent optimizers. In case of restartable tasks, all the subsequent refinements are combined, and any reference to an interaction would need to resort to some kind of message index range.</li> </ul> </li> <li>Easier Implementation: No ambiguity for agent developers, whether to create a new task or restart an existing task. Once a task is in terminal state, any related subsequent interaction would need to be within a new task.</li> </ul>"},{"location":"topics/life-of-a-task/#parallel-follow-ups","title":"Parallel Follow-ups","text":"<p>Parallel work is supported by having agents create distinct, parallel tasks for each follow-up message sent within the same contextId. This allows clients to track individual tasks and create new dependent tasks as soon as a prerequisite task is complete.</p> <p>For example:</p> <pre><code>Task 1: Book a flight to Helsinki.\n(After Task 1 finishes)\nTask 2: Based on Task 1, book a hotel.\nTask 3: Based on Task 1, book a snowmobile activity.\n(After Task 2 finishes, while Task 3 is still in progress)\nTask 4: Based on Task 2, add a spa reservation to the hotel booking.\n</code></pre>"},{"location":"topics/life-of-a-task/#referencing-previous-artifacts","title":"Referencing Previous Artifacts","text":"<p>The serving agent is responsible for inferring the relevant artifact from the referenced task or from the <code>contextId</code>. The serving agent, as the domain expert, is best suited to resolve ambiguity or identify missing information because they are the ones who generated the artifacts.</p> <p>If there is ambiguity (e.g., multiple artifacts could fit the request), the agent will ask the client for clarification by returning an input-required state. The client can then specify the artifact in its response. Client can optionally populate artifact reference {artifactId, taskId} in part metadata. This allows for linkage between inputs for follow-up tasks and previously generated artifacts.</p> <p>This approach allows for the client implementation to be simple.</p>"},{"location":"topics/life-of-a-task/#tracking-artifact-mutation","title":"Tracking Artifact Mutation","text":"<p>A follow up or refinement can result in an older artifact being modified and newer artifacts being generated. It would be good to know this linkage and maybe track all mutations of the artifact to make sure only the latest copy is used for future context. Something like a linked list, with the head as the latest version of the task result.</p> <p>But the client is best suited, as well as is the real judge of what it considers as an acceptable result. And in fact can reject the mutation as well. Hence, the serving agent should not own this linkage and hence this linkage does not need to be part of A2A protocol spec. Clients can maintain the linkage on their end and show the latest version to the user.</p> <p>To help with the tracking, the serving agent should maintain the same artifact-name when generating a refinement on the original artifact.</p> <p>For follow-up or refinement tasks, the client is best suited to refer to the \"latest\" or what it considers to be the intended artifact to be refined upon. If the artifact reference is not explicitly specified, the serving agent can:</p> <ul> <li>Use context to figure out the latest artifact.</li> <li>Or in case of ambiguity or context not supported, agent can use <code>input-required</code> task state.</li> </ul>"},{"location":"topics/life-of-a-task/#example-follow-up","title":"Example Follow-up","text":""},{"location":"topics/life-of-a-task/#client-sends-message-to-agent","title":"Client sends message to agent","text":"<pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"req-001\",\n  \"method\": \"message/send\",\n  \"params\": {\n    \"message\": {\n      \"role\": \"user\",\n      \"parts\": [\n        {\n          \"kind\": \"text\",\n          \"text\": \"Generate an image of a sailboat on the ocean.\"\n        }\n      ],\n      \"messageId\": \"msg-user-001\"\n    }\n  }\n}\n</code></pre>"},{"location":"topics/life-of-a-task/#agent-responds-with-boat-image","title":"Agent responds with boat image","text":"<pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"req-001\",\n  \"result\": {\n    \"id\": \"task-boat-gen-123\",\n    \"contextId\": \"ctx-conversation-abc\",\n    \"status\": {\n      \"state\": \"completed\",\n    },\n    \"artifacts\": [\n      {\n        \"artifactId\": \"artifact-boat-v1-xyz\",\n        \"name\": \"sailboat_image.png\",\n        \"description\": \"A generated image of a sailboat on the ocean.\",\n        \"parts\": [\n          {\n            \"kind\": \"file\",\n            \"file\": {\n              \"name\": \"sailboat_image.png\",\n              \"mimeType\": \"image/png\",\n              \"bytes\": \"&lt;base64_encoded_png_data_of_a_sailboat&gt;\"\n            }\n          }\n        ]\n      }\n    ],\n    \"kind\": \"task\"\n  }\n}\n</code></pre>"},{"location":"topics/life-of-a-task/#client-asks-for-coloring-the-boat-red","title":"Client asks for coloring the boat red","text":"<p>Refers to previous taskID and uses same contextId.</p> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"req-002\",\n  \"method\": \"message/send\",\n  \"params\": {\n    \"message\": {\n      \"role\": \"user\",\n      \"messageId\": \"msg-user-002\",\n      \"contextId\": \"ctx-conversation-abc\", // Same contextId\n      \"referenceTaskIds\": [\"task-boat-gen-123\"] // Optional: Referencing the previous task\n      \"parts\": [\n        {\n          \"kind\": \"text\",\n          \"text\": \"That's great! Can you make the sailboat red?\"\n          // Optional: In case the agent asked for actual relevant artifact.\n          // Client could provide the artifact data in parts.\n          // Also it could add metadata to the part to\n          // reference the specific artifact.\n          // \"metadata\": {\n          //   \"referenceArtifacts: [\n          //      {\n          //        \"artifactId\": \"artifact-boat-v1-xyz\",\n          //        \"taskId\": \"task-boat-gen-123\"\n          //      }\n          //   ]\n          // }\n        }\n      ],\n    }\n  }\n}\n</code></pre>"},{"location":"topics/life-of-a-task/#agent-responds-with-new-image-artifact","title":"Agent responds with new image artifact","text":"<ul> <li>Creates new task in same contextId.</li> <li>Boat image artifact has same name. but a new artifactId.</li> </ul> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"req-002\",\n  \"result\": {\n    \"id\": \"task-boat-color-456\", // New task ID\n    \"contextId\": \"ctx-conversation-abc\", // Same contextId\n    \"status\": {\n      \"state\": \"completed\",\n    },\n    \"artifacts\": [\n      {\n        \"artifactId\": \"artifact-boat-v2-red-pqr\", // New artifactId\n        \"name\": \"sailboat_image.png\", // Same name as the original artifact\n        \"description\": \"A generated image of a red sailboat on the ocean.\",\n        \"parts\": [\n          {\n            \"kind\": \"file\",\n            \"file\": {\n              \"name\": \"sailboat_image.png\",\n              \"mimeType\": \"image/png\",\n              \"bytes\": \"&lt;base64_encoded_png_data_of_a_RED_sailboat&gt;\"\n            }\n          }\n        ]\n      }\n    ],\n    \"kind\": \"task\"\n  }\n}\n</code></pre>"},{"location":"topics/streaming-and-async/","title":"Streaming &amp; Asynchronous Operations in A2A","text":"<p>The Agent2Agent (A2A) protocol is designed to handle tasks that may not complete immediately. Many AI-driven operations can be long-running, involve multiple steps, produce incremental results, or require human intervention. A2A provides robust mechanisms for managing such asynchronous interactions, ensuring that clients can receive updates effectively, whether they remain continuously connected or operate in a more disconnected fashion.</p>"},{"location":"topics/streaming-and-async/#1-streaming-with-server-sent-events-sse","title":"1. Streaming with Server-Sent Events (SSE)","text":"<p>For tasks that produce incremental results (like generating a long document or streaming media) or provide ongoing status updates, A2A supports real-time communication using Server-Sent Events (SSE). This is ideal when the client can maintain an active HTTP connection with the A2A Server.</p> <p>Key Characteristics:</p> <ul> <li>Initiation: The client uses the <code>message/stream</code> RPC method to send an initial message (e.g., a prompt or command) and simultaneously subscribe to updates for that task.</li> <li>Server Capability: The A2A Server must indicate its support for streaming by setting <code>capabilities.streaming: true</code> in its Agent Card.</li> <li>Server Response (Connection): If the subscription is successful, the server responds with an HTTP <code>200 OK</code> status and a <code>Content-Type: text/event-stream</code>. This HTTP connection remains open for the server to push events.</li> <li>Event Structure: The server sends events over this stream. Each event's <code>data</code> field contains a JSON-RPC 2.0 Response object, specifically a <code>SendStreamingMessageResponse</code>. The <code>id</code> in this JSON-RPC response matches the <code>id</code> from the client's original <code>message/stream</code> request.</li> <li>Event Types (within <code>SendStreamingMessageResponse.result</code>):<ul> <li><code>Task</code>: Represents the stateful unit of work being processed by the A2A Server for an A2A Client.</li> <li><code>TaskStatusUpdateEvent</code>: Communicates changes in the task's lifecycle state (e.g., from <code>working</code> to <code>input-required</code> or <code>completed</code>). It can also provide intermediate messages from the agent (e.g., \"I'm currently analyzing the data...\").</li> <li><code>TaskArtifactUpdateEvent</code>: Delivers new or updated Artifacts generated by the task. This is used to stream large files or data structures in chunks. This object itself contains fields like <code>append</code>, and <code>lastChunk</code> to help the client reassemble the complete artifact.</li> </ul> </li> <li>Stream Termination: The server signals the end of updates for a particular interaction cycle (i.e., for the current <code>message/stream</code> request) by setting <code>final: true</code> in a <code>TaskStatusUpdateEvent</code>. This typically occurs when the task reaches a terminal state (<code>completed</code>, <code>failed</code>, <code>canceled</code>) or an <code>input-required</code> state (where the server expects further input from the client). After sending a <code>final: true</code> event, the server usually closes the SSE connection for that specific request.</li> <li>Resubscription: If a client's SSE connection breaks prematurely while a task is still active (and the server hasn't sent a <code>final: true</code> event for that phase), the client can attempt to reconnect to the stream using the <code>tasks/resubscribe</code> RPC method. The server's behavior regarding missed events during the disconnection period (e.g., whether it backfills or only sends new updates) is implementation-dependent.</li> </ul> <p>When to Use Streaming:</p> <ul> <li>Real-time progress monitoring of long-running tasks.</li> <li>Receiving large results (artifacts) incrementally, allowing processing to begin before the entire result is available.</li> <li>Interactive, conversational exchanges where immediate feedback or partial responses are beneficial.</li> <li>Applications requiring low-latency updates from the agent.</li> </ul> <p>Refer to the Protocol Specification for detailed structures:</p> <ul> <li><code>message/stream</code></li> <li><code>tasks/resubscribe</code></li> </ul>"},{"location":"topics/streaming-and-async/#2-push-notifications-for-disconnected-scenarios","title":"2. Push Notifications for Disconnected Scenarios","text":"<p>For very long-running tasks (e.g., lasting minutes, hours, or even days) or when clients cannot or prefer not to maintain persistent connections (like mobile clients or serverless functions), A2A supports asynchronous updates via push notifications. This mechanism allows the A2A Server to actively notify a client-provided webhook when a significant task update occurs.</p> <p>Key Characteristics:</p> <ul> <li>Server Capability: The A2A Server must indicate its support for this feature by setting <code>capabilities.pushNotifications: true</code> in its Agent Card.</li> <li> <p>Configuration: The client provides a <code>PushNotificationConfig</code> to the server.</p> <ul> <li> <p>This configuration can be supplied:</p> <ul> <li>Within the initial <code>message/send</code> or <code>message/stream</code> request (via the optional <code>pushNotification</code> parameter in <code>TaskSendParams</code>).</li> <li>Separately, using the <code>tasks/pushNotificationConfig/set</code> RPC method for an existing task.</li> </ul> </li> <li> <p>The <code>PushNotificationConfig</code> includes:</p> <ul> <li><code>url</code>: The absolute HTTPS webhook URL where the A2A Server should send (POST) task update notifications.</li> <li><code>token</code> (optional): A client-generated opaque string (e.g., a secret or task-specific identifier). The server SHOULD include this token in the notification request (e.g., in a custom header like <code>X-A2A-Notification-Token</code>) for validation by the client's webhook receiver.</li> <li><code>authentication</code> (optional): An <code>AuthenticationInfo</code> object specifying how the A2A Server should authenticate itself to the client's webhook URL. The client (receiver of the webhook) defines these authentication requirements.</li> </ul> </li> </ul> </li> <li> <p>Notification Trigger: The A2A Server decides when to send a push notification. Typically, this happens when a task reaches a significant state change, such as transitioning to a terminal state (<code>completed</code>, <code>failed</code>, <code>canceled</code>, <code>rejected</code>) or an <code>input-required</code> or <code>auth-required</code> state, particularly after its associated message and artifacts are fully generated and stable.</p> </li> <li>Notification Payload: The A2A protocol itself does not strictly define the HTTP body payload of the push notification sent by the server to the client's webhook. However, the notification SHOULD contain sufficient information for the client to identify the <code>Task ID</code> and understand the general nature of the update (e.g., the new <code>TaskState</code>). Servers might send a minimal payload (just <code>Task ID</code> and new state) or a more comprehensive one (e.g., a summary or even the full <code>Task</code> object).</li> <li>Client Action: Upon receiving a push notification (and successfully verifying its authenticity and relevance), the client typically uses the <code>tasks/get</code> RPC method with the <code>task ID</code> from the notification to retrieve the complete, updated <code>Task</code> object, including any new artifacts or detailed messages.</li> </ul> <p>The Push Notification Service (Client-Side Webhook Infrastructure):</p> <ul> <li>The target <code>url</code> specified in <code>PushNotificationConfig.url</code> points to a Push Notification Service. This service is a component on the client's side (or a service the client subscribes to) responsible for receiving the HTTP POST notification from the A2A Server.</li> <li>Its responsibilities include:<ul> <li>Authenticating the incoming notification (i.e., verifying it's from the legitimate A2A Server).</li> <li>Validating the notification's relevance (e.g., checking the <code>token</code>).</li> <li>Relaying the notification or its content to the appropriate client application logic or system.</li> </ul> </li> <li>In simple scenarios (e.g., local development), the client application itself might directly expose the webhook endpoint.</li> <li>In enterprise or production settings, this is often a robust, secure service that handles incoming webhooks, authenticates callers, and routes messages (e.g., to a message queue, an internal API, a mobile push notification gateway, or another event-driven system).</li> </ul>"},{"location":"topics/streaming-and-async/#security-considerations-for-push-notifications","title":"Security Considerations for Push Notifications","text":"<p>Security is paramount for push notifications due to their asynchronous and server-initiated outbound nature. Both the A2A Server (sending the notification) and the client's webhook receiver have responsibilities.</p>"},{"location":"topics/streaming-and-async/#a2a-server-security-when-sending-notifications-to-client-webhook","title":"A2A Server Security (When Sending Notifications to Client Webhook)","text":"<ol> <li> <p>Webhook URL Validation:</p> <ul> <li>Servers SHOULD NOT blindly trust and send POST requests to any <code>url</code> provided by a client in <code>PushNotificationConfig</code>. Malicious clients could provide URLs pointing to internal services or unrelated third-party systems to cause harm (Server-Side Request Forgery - SSRF attacks) or act as Distributed Denial of Service (DDoS) amplifiers.</li> <li>Mitigation Strategies:<ul> <li>Allowlisting: Maintain an allowlist of trusted domains or IP ranges for webhook URLs, if feasible.</li> <li>Ownership Verification / Challenge-Response: Before sending actual notifications, the server can (and SHOULD ideally) perform a verification step. For example, it could issue an HTTP <code>GET</code> or <code>OPTIONS</code> request to the proposed webhook URL with a unique <code>validationToken</code> (as a query parameter or header). The webhook service must respond appropriately (e.g., echo back the token or confirm readiness) to prove ownership and reachability. The A2A Python samples demonstrate a simple validation token check mechanism.</li> <li>Network Controls: Use egress firewalls or network policies to restrict where the A2A Server can send outbound HTTP requests.</li> </ul> </li> </ul> </li> <li> <p>Authenticating to the Client's Webhook:</p> <ul> <li>The A2A Server MUST authenticate itself to the client's webhook URL according to the scheme(s) specified in <code>PushNotificationConfig.authentication</code>.</li> <li>Common authentication schemes for server-to-server webhooks include:<ul> <li>Bearer Tokens (OAuth 2.0): The A2A Server obtains an access token (e.g., using the OAuth 2.0 client credentials grant flow if the webhook provider supports it) for an audience/scope representing the client's webhook, and includes it in the <code>Authorization: Bearer &lt;token&gt;</code> header of the notification POST request.</li> <li>API Keys: A pre-shared API key that the A2A Server includes in a specific HTTP header (e.g., <code>X-Api-Key</code>).</li> <li>HMAC Signatures: The A2A Server signs the request payload (or parts of the request) with a shared secret key using HMAC, and includes the signature in a header (e.g., <code>X-Hub-Signature</code>). The webhook receiver then verifies this signature.</li> <li>Mutual TLS (mTLS): If supported by the client's webhook infrastructure, the A2A Server can present a client TLS certificate.</li> </ul> </li> </ul> </li> </ol>"},{"location":"topics/streaming-and-async/#client-webhook-receiver-security-when-receiving-notifications-from-a2a-server","title":"Client Webhook Receiver Security (When Receiving Notifications from A2A Server)","text":"<ol> <li> <p>Authenticating the A2A Server:</p> <ul> <li>The webhook endpoint MUST rigorously verify the authenticity of incoming notification requests to ensure they originate from the legitimate A2A Server and not an imposter.</li> <li>Verify Signatures/Tokens:<ul> <li>If using JWTs (e.g., as Bearer tokens), validate the JWT's signature against the A2A Server's trusted public keys (e.g., fetched from a JWKS endpoint provided by the A2A Server, if applicable). Also, validate claims like <code>iss</code> (issuer), <code>aud</code> (audience - should identify your webhook), <code>iat</code> (issued at), and <code>exp</code> (expiration time).</li> <li>If using HMAC signatures, recalculate the signature on the received payload using the shared secret and compare it to the signature in the request header.</li> <li>If using API keys, ensure the key is valid and known.</li> </ul> </li> <li>Validate <code>PushNotificationConfig.token</code>: If the client provided an opaque <code>token</code> in its <code>PushNotificationConfig</code> when setting up notifications for the task, the webhook should check that the incoming notification includes this exact token (e.g., in a custom header like <code>X-A2A-Notification-Token</code>). This helps ensure the notification is intended for this specific client context and task, adding a layer of authorization.</li> </ul> </li> <li> <p>Preventing Replay Attacks:</p> <ul> <li>Timestamps: Notifications should ideally include a timestamp (e.g., <code>iat</code> - issued at - claim in a JWT, or a custom timestamp header). The webhook should reject notifications that are too old (e.g., older than a few minutes) to prevent attackers from replaying old, captured notifications. The timestamp should be part of the signed payload (if using signatures) to ensure its integrity.</li> <li>Nonces/Unique IDs: For critical notifications, consider using unique, single-use identifiers (nonces or event IDs) for each notification. The webhook should track received IDs (for a reasonable window) to prevent processing duplicate notifications. A JWT's <code>jti</code> (JWT ID) claim can serve this purpose.</li> </ul> </li> <li> <p>Secure Key Management and Rotation:</p> <ul> <li>If using cryptographic keys (symmetric secrets for HMAC, or asymmetric key pairs for JWT signing/mTLS), implement secure key management practices, including regular key rotation.</li> <li>For asymmetric keys where the A2A Server signs and the client webhook verifies, protocols like JWKS (JSON Web Key Set) allow the server to publish its public keys (including new ones during rotation) at a well-known endpoint. Client webhooks can then dynamically fetch the correct public key for signature verification, facilitating smoother key rotation.</li> </ul> </li> </ol>"},{"location":"topics/streaming-and-async/#example-asymmetric-key-flow-jwt-jwks","title":"Example Asymmetric Key Flow (JWT + JWKS)","text":"<ol> <li>Client sets <code>PushNotificationConfig</code> specifying <code>authentication.schemes: [\"Bearer\"]</code> and possibly an expected <code>issuer</code> or <code>audience</code> for the JWT.</li> <li>A2A Server, when sending a notification:<ul> <li>Generates a JWT, signing it with its private key. The JWT includes claims like <code>iss</code> (issuer), <code>aud</code> (audience - the webhook), <code>iat</code> (issued at), <code>exp</code> (expires), <code>jti</code> (JWT ID), and <code>taskId</code>.</li> <li>The JWT header (<code>alg</code> and <code>kid</code>) indicates the signing algorithm and key ID.</li> <li>The A2A Server makes its public keys available via a JWKS endpoint (URL for this endpoint might be known to the webhook provider or discovered).</li> </ul> </li> <li>Client Webhook, upon receiving the notification:<ul> <li>Extracts the JWT from the <code>Authorization</code> header.</li> <li>Inspects the <code>kid</code> in the JWT header.</li> <li>Fetches the corresponding public key from the A2A Server's JWKS endpoint (caching keys is recommended).</li> <li>Verifies the JWT signature using the public key.</li> <li>Validates claims (<code>iss</code>, <code>aud</code>, <code>iat</code>, <code>exp</code>, <code>jti</code>).</li> <li>Checks the <code>PushNotificationConfig.token</code> if provided.</li> </ul> </li> </ol> <p>This comprehensive, layered approach to security for push notifications ensures that messages are authentic, integral, and timely, protecting both the sending A2A Server and the receiving client webhook infrastructure.</p>"},{"location":"topics/what-is-a2a/","title":"What is A2A?","text":"<p>The Agent2Agent (A2A) Protocol is an open standard designed to solve a fundamental challenge in the rapidly evolving landscape of artificial intelligence: how do AI agents, built by different teams, using different technologies, and owned by different organizations, communicate and collaborate effectively?</p> <p>As AI agents become more specialized and capable, the need for them to work together on complex tasks increases. Imagine a user asking their primary AI assistant to plan an international trip. This single request might involve coordinating the capabilities of several specialized agents:</p> <ol> <li>An agent for flight bookings.</li> <li>Another agent for hotel reservations.</li> <li>A third for local tour recommendations and bookings.</li> <li>A fourth to handle currency conversion and travel advisories.</li> </ol> <p>Without a common communication protocol, integrating these diverse agents into a cohesive user experience is a significant engineering hurdle. Each integration would likely be a custom, point-to-point solution, making the system difficult to scale, maintain, and extend.</p>"},{"location":"topics/what-is-a2a/#the-a2a-solution","title":"The A2A Solution","text":"<p>A2A provides a standardized way for these independent, often \"opaque\" (black-box) agentic systems to interact. It defines:</p> <ul> <li>A common transport and format: JSON-RPC 2.0 over HTTP(S) for how messages are structured and transmitted.</li> <li>Discovery mechanisms (Agent Cards): How agents can advertise their capabilities and be found by other agents.</li> <li>Task management workflows: How collaborative tasks are initiated, progressed, and completed. This includes support for tasks that may be long-running or require multiple turns of interaction.</li> <li>Support for various data modalities: How agents exchange not just text, but also files, structured data (like forms), and potentially other rich media.</li> <li>Core principles for security and asynchronicity: Guidelines for secure communication and handling tasks that might take significant time or involve human-in-the-loop processes.</li> </ul>"},{"location":"topics/what-is-a2a/#key-design-principles-of-a2a","title":"Key Design Principles of A2A","text":"<p>The development of A2A is guided by several core principles:</p> <ul> <li>Simplicity: Leverage existing, well-understood standards like HTTP, JSON-RPC, and Server-Sent Events (SSE) where possible, rather than reinventing the wheel.</li> <li>Enterprise Readiness: Address critical enterprise needs such as authentication, authorization, security, privacy, tracing, and monitoring from the outset by aligning with standard web practices.</li> <li>Asynchronous First: Natively support long-running tasks and scenarios where agents or users might not be continuously connected, through mechanisms like streaming and push notifications.</li> <li>Modality Agnostic: Allow agents to communicate using a variety of content types, enabling rich and flexible interactions beyond plain text.</li> <li>Opaque Execution: Enable collaboration without requiring agents to expose their internal logic, memory, or proprietary tools. Agents interact based on declared capabilities and exchanged context, preserving intellectual property and enhancing security.</li> </ul>"},{"location":"topics/what-is-a2a/#benefits-of-using-a2a","title":"Benefits of Using A2A","text":"<p>Adopting A2A can lead to significant advantages:</p> <ul> <li>Increased Interoperability: Break down silos between different AI agent ecosystems, allowing agents from various vendors and frameworks to work together.</li> <li>Enhanced Agent Capabilities: Allow developers to create more sophisticated applications by composing the strengths of multiple specialized agents.</li> <li>Reduced Integration Complexity: Standardize the \"how\" of agent communication, allowing teams to focus on the \"what\" \u2013 the value their agents provide.</li> <li>Fostering Innovation: Encourage the development of a richer ecosystem of specialized agents that can readily plug into larger collaborative workflows.</li> <li>Future-Proofing: Provide a flexible framework that can adapt as agent technologies continue to evolve.</li> </ul> <p>By establishing common ground for agent-to-agent communication, A2A aims to accelerate the adoption and utility of AI agents across diverse industries and applications, paving the way for more powerful and collaborative AI systems.</p>"},{"location":"topics/what-is-a2a/#a2a-request-lifecycle","title":"A2A Request Lifecycle","text":"<pre><code>sequenceDiagram\n    participant Client\n    participant A2A Server\n    participant Auth Server\n\n    rect rgb(240, 240, 240)\n    Note over Client, A2A Server: 1. Agent Discovery\n    Client-&gt;&gt;A2A Server: GET agent card eg: (/.well-known/agent-card)\n    A2A Server--&gt;&gt;Client: Returns Agent Card\n    end\n\n    rect rgb(240, 240, 240)\n    Note over Client, Auth Server: 2. Authentication\n    Client-&gt;&gt;Client: Parse Agent Card for securitySchemes\n    alt securityScheme is openIdConnect\n        Client-&gt;&gt;Auth Server: Request token based on \"authorizationUrl\" and \"tokenUrl\"\n        Auth Server--&gt;&gt;Client: Returns JWT\n    end\n    end\n\n    rect rgb(240, 240, 240)\n    Note over Client, A2A Server: 3. sendMessage API\n    Client-&gt;&gt;Client: Parse Agent Card for \"url\" param to send API requests to.\n    Client-&gt;&gt;A2A Server: POST /sendMessage (with JWT)\n    A2A Server-&gt;&gt;A2A Server: Process message and create task\n    A2A Server--&gt;&gt;Client: Returns Task Response\n    end\n\n    rect rgb(240, 240, 240)\n    Note over Client, A2A Server: 4. sendMessageStream API\n    Client-&gt;&gt;A2A Server: POST /sendMessageStream (with JWT)\n    A2A Server--&gt;&gt;Client: Stream: Task (Submitted)\n    A2A Server--&gt;&gt;Client: Stream: TaskStatusUpdateEvent (Working)\n    A2A Server--&gt;&gt;Client: Stream: TaskArtifactUpdateEvent (artifact A)\n    A2A Server--&gt;&gt;Client: Stream: TaskArtifactUpdateEvent (artifact B)\n    A2A Server--&gt;&gt;Client: Stream: TaskStatusUpdateEvent (Completed)\n    end</code></pre> <p>Next, learn about the Key Concepts that form the foundation of the A2A protocol.</p>"},{"location":"tutorials/python/1-introduction/","title":"Python Quickstart Tutorial: Building an A2A Agent","text":"<p>Welcome to the Agent2Agent (A2A) Python Quickstart Tutorial!</p> <p>In this tutorial, you will explore a simple \"echo\" A2A server using the Python SDK. This will introduce you to the fundamental concepts and components of an A2A server. You will then look at a more advanced example that integrates a Large Language Model (LLM).</p> <p>This hands-on guide will help you understand:</p> <ul> <li>The basic concepts behind the A2A protocol.</li> <li>How to set up a Python environment for A2A development using the SDK.</li> <li>How Agent Skills and Agent Cards describe an agent.</li> <li>How an A2A server handles tasks.</li> <li>How to interact with an A2A server using a client.</li> <li>How streaming capabilities and multi-turn interactions work.</li> <li>How an LLM can be integrated into an A2A agent.</li> </ul> <p>By the end of this tutorial, you will have a functional understanding of A2A agents and a solid foundation for building or integrating A2A-compliant applications.</p>"},{"location":"tutorials/python/1-introduction/#tutorial-sections","title":"Tutorial Sections","text":"<p>The tutorial is broken down into the following steps:</p> <ol> <li>Introduction (This Page)</li> <li>Setup: Prepare your Python environment and the A2A SDK.</li> <li>Agent Skills &amp; Agent Card: Define what your agent can do and how it describes itself.</li> <li>The Agent Executor: Understand how the agent logic is implemented.</li> <li>Starting the Server: Run the Helloworld A2A server.</li> <li>Interacting with the Server: Send requests to your agent.</li> <li>Streaming &amp; Multi-Turn Interactions: Explore advanced capabilities with the LangGraph example.</li> <li>Next Steps: Explore further possibilities with A2A.</li> </ol> <p>Let's get started!</p>"},{"location":"tutorials/python/2-setup/","title":"2. Setup Your Environment","text":""},{"location":"tutorials/python/2-setup/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.10 or higher.</li> <li>Access to a terminal or command prompt.</li> <li>Git, for cloning the repository.</li> <li>A code editor (e.g., Visual Studio Code) is recommended.</li> </ul>"},{"location":"tutorials/python/2-setup/#clone-the-repository","title":"Clone the Repository","text":"<p>If you haven't already, clone the A2A Samples repository:</p> <pre><code>git clone https://github.com/a2aproject/a2a-samples.git -b main --depth 1\ncd a2a-samples\n</code></pre>"},{"location":"tutorials/python/2-setup/#python-environment-sdk-installation","title":"Python Environment &amp; SDK Installation","text":"<p>We recommend using a virtual environment for Python projects. The A2A Python SDK uses <code>uv</code> for dependency management, but you can use <code>pip</code> with <code>venv</code> as well.</p> <ol> <li> <p>Create and activate a virtual environment:</p> <p>Using <code>venv</code> (standard library):</p> Mac/LinuxWindows <pre><code>python -m venv .venv\nsource .venv/bin/activate\n</code></pre> <pre><code>python -m venv .venv\n.venv\\Scripts\\activate\n</code></pre> </li> <li> <p>Install needed Python dependencies along with the A2A SDK and its dependencies:</p> <pre><code>pip install -r samples/python/requirements.txt\n</code></pre> </li> </ol>"},{"location":"tutorials/python/2-setup/#verify-installation","title":"Verify Installation","text":"<p>After installation, you should be able to import the <code>a2a</code> package in a Python interpreter:</p> <pre><code>python -c \"import a2a; print('A2A SDK imported successfully')\"\n</code></pre> <p>If this command runs without error and prints the success message, your environment is set up correctly.</p>"},{"location":"tutorials/python/3-agent-skills-and-card/","title":"3. Agent Skills &amp; Agent Card","text":"<p>Before an A2A agent can do anything, it needs to define what it can do (its skills) and how other agents or clients can find out about these capabilities (its Agent Card).</p> <p>We'll use the <code>helloworld</code> example located in <code>a2a-samples/samples/python/agents/helloworld/</code>.</p>"},{"location":"tutorials/python/3-agent-skills-and-card/#agent-skills","title":"Agent Skills","text":"<p>An Agent Skill describes a specific capability or function the agent can perform. It's a building block that tells clients what kinds of tasks the agent is good for.</p> <p>Key attributes of an <code>AgentSkill</code> (defined in <code>a2a.types</code>):</p> <ul> <li><code>id</code>: A unique identifier for the skill.</li> <li><code>name</code>: A human-readable name.</li> <li><code>description</code>: A more detailed explanation of what the skill does.</li> <li><code>tags</code>: Keywords for categorization and discovery.</li> <li><code>examples</code>: Sample prompts or use cases.</li> <li><code>inputModes</code> / <code>outputModes</code>: Supported Media Types for input and output (e.g., \"text/plain\", \"application/json\").</li> </ul> <p>In <code>__main__.py</code>, you can see how a skill for the Helloworld agent is defined:</p> <pre><code>skill = AgentSkill(\n    id='hello_world',\n    name='Returns hello world',\n    description='just returns hello world',\n    tags=['hello world'],\n    examples=['hi', 'hello world'],\n)\n</code></pre> <p>This skill is very simple: it's named \"Returns hello world\" and primarily deals with text.</p>"},{"location":"tutorials/python/3-agent-skills-and-card/#agent-card","title":"Agent Card","text":"<p>The Agent Card is a JSON document that an A2A Server makes available, typically at a <code>.well-known/agent-card.json</code> endpoint. It's like a digital business card for the agent.</p> <p>Key attributes of an <code>AgentCard</code> (defined in <code>a2a.types</code>):</p> <ul> <li><code>name</code>, <code>description</code>, <code>version</code>: Basic identity information.</li> <li><code>url</code>: The endpoint where the A2A service can be reached.</li> <li><code>capabilities</code>: Specifies supported A2A features like <code>streaming</code> or <code>pushNotifications</code>.</li> <li><code>defaultInputModes</code> / <code>defaultOutputModes</code>: Default Media Types for the agent.</li> <li><code>skills</code>: A list of <code>AgentSkill</code> objects that the agent offers.</li> </ul> <p>The <code>helloworld</code> example defines its Agent Card like this:</p> <pre><code># This will be the public-facing agent card\npublic_agent_card = AgentCard(\n    name='Hello World Agent',\n    description='Just a hello world agent',\n    url='http://localhost:9999/',\n    version='1.0.0',\n    default_input_modes=['text'],\n    default_output_modes=['text'],\n    capabilities=AgentCapabilities(streaming=True),\n    skills=[skill],  # Only the basic skill for the public card\n    supports_authenticated_extended_card=True,\n)\n</code></pre> <p>This card tells us the agent is named \"Hello World Agent\", runs at <code>http://localhost:9999/</code>, supports text interactions, and has the <code>hello_world</code> skill. It also indicates public authentication, meaning no specific credentials are required.</p> <p>Understanding the Agent Card is crucial because it's how a client discovers an agent and learns how to interact with it.</p>"},{"location":"tutorials/python/4-agent-executor/","title":"4. The Agent Executor","text":"<p>The core logic of how an A2A agent processes requests and generates responses/events is handled by an Agent Executor. The A2A Python SDK provides an abstract base class <code>a2a.server.agent_execution.AgentExecutor</code> that you implement.</p>"},{"location":"tutorials/python/4-agent-executor/#agentexecutor-interface","title":"<code>AgentExecutor</code> Interface","text":"<p>The <code>AgentExecutor</code> class defines two primary methods:</p> <ul> <li><code>async def execute(self, context: RequestContext, event_queue: EventQueue)</code>: Handles incoming requests that expect a response or a stream of events. It processes the user's input (available via <code>context</code>) and uses the <code>event_queue</code> to send back <code>Message</code>, <code>Task</code>, <code>TaskStatusUpdateEvent</code>, or <code>TaskArtifactUpdateEvent</code> objects.</li> <li><code>async def cancel(self, context: RequestContext, event_queue: EventQueue)</code>: Handles requests to cancel an ongoing task.</li> </ul> <p>The <code>RequestContext</code> provides information about the incoming request, such as the user's message and any existing task details. The <code>EventQueue</code> is used by the executor to send events back to the client.</p>"},{"location":"tutorials/python/4-agent-executor/#helloworld-agent-executor","title":"Helloworld Agent Executor","text":"<p>Let's look at <code>agent_executor.py</code>. It defines <code>HelloWorldAgentExecutor</code>.</p> <ol> <li> <p>The Agent (<code>HelloWorldAgent</code>):     This is a simple helper class that encapsulates the actual \"business logic\".</p> <pre><code>class HelloWorldAgent:\n    \"\"\"Hello World Agent.\"\"\"\n\n    async def invoke(self) -&gt; str:\n        return 'Hello World'\n</code></pre> <p>It has a simple <code>invoke</code> method that returns the string \"Hello World\".</p> </li> <li> <p>The Executor (<code>HelloWorldAgentExecutor</code>):     This class implements the <code>AgentExecutor</code> interface.</p> <ul> <li> <p><code>__init__</code>:</p> <pre><code>class HelloWorldAgentExecutor(AgentExecutor):\n    \"\"\"Test AgentProxy Implementation.\"\"\"\n\n    def __init__(self):\n        self.agent = HelloWorldAgent()\n</code></pre> <p>It instantiates the <code>HelloWorldAgent</code>.</p> </li> <li> <p><code>execute</code>:</p> <pre><code>async def execute(\n    self,\n    context: RequestContext,\n    event_queue: EventQueue,\n) -&gt; None:\n    result = await self.agent.invoke()\n    await event_queue.enqueue_event(new_agent_text_message(result))\n</code></pre> <p>When a <code>message/send</code> or <code>message/stream</code> request comes in (both are handled by <code>execute</code> in this simplified executor):</p> <ol> <li>It calls <code>self.agent.invoke()</code> to get the \"Hello World\" string.</li> <li>It creates an A2A <code>Message</code> object using the <code>new_agent_text_message</code> utility function.</li> <li>It enqueues this message onto the <code>event_queue</code>. The underlying <code>DefaultRequestHandler</code> will then process this queue to send the response(s) to the client. For a single message like this, it will result in a single response for <code>message/send</code> or a single event for <code>message/stream</code> before the stream closes.</li> </ol> </li> <li> <p><code>cancel</code>:     The Helloworld example's <code>cancel</code> method simply raises an exception, indicating that cancellation is not supported for this basic agent.</p> <pre><code>async def cancel(\n    self, context: RequestContext, event_queue: EventQueue\n) -&gt; None:\n    raise Exception('cancel not supported')\n</code></pre> </li> </ul> </li> </ol> <p>The <code>AgentExecutor</code> acts as the bridge between the A2A protocol (managed by the request handler and server application) and your agent's specific logic. It receives context about the request and uses an event queue to communicate results or updates back.</p>"},{"location":"tutorials/python/5-start-server/","title":"5. Starting the Server","text":"<p>Now that we have an Agent Card and an Agent Executor, we can set up and start the A2A server.</p> <p>The A2A Python SDK provides an <code>A2AStarletteApplication</code> class that simplifies running an A2A-compliant HTTP server. It uses Starlette for the web framework and is typically run with an ASGI server like Uvicorn.</p>"},{"location":"tutorials/python/5-start-server/#server-setup-in-helloworld","title":"Server Setup in Helloworld","text":"<p>Let's look at <code>__main__.py</code> again to see how the server is initialized and started.</p> <pre><code>import uvicorn\n\nfrom a2a.server.apps import A2AStarletteApplication\nfrom a2a.server.request_handlers import DefaultRequestHandler\nfrom a2a.server.tasks import InMemoryTaskStore\nfrom a2a.types import (\n    AgentCapabilities,\n    AgentCard,\n    AgentSkill,\n)\nfrom agent_executor import (\n    HelloWorldAgentExecutor,  # type: ignore[import-untyped]\n)\n\n\nif __name__ == '__main__':\n    skill = AgentSkill(\n        id='hello_world',\n        name='Returns hello world',\n        description='just returns hello world',\n        tags=['hello world'],\n        examples=['hi', 'hello world'],\n    )\n\n    extended_skill = AgentSkill(\n        id='super_hello_world',\n        name='Returns a SUPER Hello World',\n        description='A more enthusiastic greeting, only for authenticated users.',\n        tags=['hello world', 'super', 'extended'],\n        examples=['super hi', 'give me a super hello'],\n    )\n\n    # This will be the public-facing agent card\n    public_agent_card = AgentCard(\n        name='Hello World Agent',\n        description='Just a hello world agent',\n        url='http://localhost:9999/',\n        version='1.0.0',\n        default_input_modes=['text'],\n        default_output_modes=['text'],\n        capabilities=AgentCapabilities(streaming=True),\n        skills=[skill],  # Only the basic skill for the public card\n        supports_authenticated_extended_card=True,\n    )\n\n    # This will be the authenticated extended agent card\n    # It includes the additional 'extended_skill'\n    specific_extended_agent_card = public_agent_card.model_copy(\n        update={\n            'name': 'Hello World Agent - Extended Edition',  # Different name for clarity\n            'description': 'The full-featured hello world agent for authenticated users.',\n            'version': '1.0.1',  # Could even be a different version\n            # Capabilities and other fields like url, default_input_modes, default_output_modes,\n            # supports_authenticated_extended_card are inherited from public_agent_card unless specified here.\n            'skills': [\n                skill,\n                extended_skill,\n            ],  # Both skills for the extended card\n        }\n    )\n\n    request_handler = DefaultRequestHandler(\n        agent_executor=HelloWorldAgentExecutor(),\n        task_store=InMemoryTaskStore(),\n    )\n\n    server = A2AStarletteApplication(\n        agent_card=public_agent_card,\n        http_handler=request_handler,\n        extended_agent_card=specific_extended_agent_card,\n    )\n\n    uvicorn.run(server.build(), host='0.0.0.0', port=9999)\n</code></pre> <p>Let's break this down:</p> <ol> <li> <p><code>DefaultRequestHandler</code>:</p> <ul> <li>The SDK provides <code>DefaultRequestHandler</code>. This handler takes your <code>AgentExecutor</code> implementation (here, <code>HelloWorldAgentExecutor</code>) and a <code>TaskStore</code> (here, <code>InMemoryTaskStore</code>).</li> <li>It routes incoming A2A RPC calls to the appropriate methods on your executor (like <code>execute</code> or <code>cancel</code>).</li> <li>The <code>TaskStore</code> is used by the <code>DefaultRequestHandler</code> to manage the lifecycle of tasks, especially for stateful interactions, streaming, and resubscription. Even if your agent executor is simple, the handler needs a task store.</li> </ul> </li> <li> <p><code>A2AStarletteApplication</code>:</p> <ul> <li>The <code>A2AStarletteApplication</code> class is instantiated with the <code>agent_card</code> and the <code>request_handler</code> (referred to as <code>http_handler</code> in its constructor).</li> <li>The <code>agent_card</code> is crucial because the server will expose it at the <code>/.well-known/agent-card.json</code> endpoint (by default).</li> <li>The <code>request_handler</code> is responsible for processing all incoming A2A method calls by interacting with your <code>AgentExecutor</code>.</li> </ul> </li> <li> <p><code>uvicorn.run(server_app_builder.build(), ...)</code>:</p> <ul> <li>The <code>A2AStarletteApplication</code> has a <code>build()</code> method that constructs the actual Starlette application.</li> <li>This application is then run using <code>uvicorn.run()</code>, making your agent accessible over HTTP.</li> <li><code>host='0.0.0.0'</code> makes the server accessible on all network interfaces on your machine.</li> <li><code>port=9999</code> specifies the port to listen on. This matches the <code>url</code> in the <code>AgentCard</code>.</li> </ul> </li> </ol>"},{"location":"tutorials/python/5-start-server/#running-the-helloworld-server","title":"Running the Helloworld Server","text":"<p>Navigate to the <code>a2a-samples</code> directory in your terminal (if you're not already there) and ensure your virtual environment is activated.</p> <p>To run the Helloworld server:</p> <pre><code># from the a2a-samples directory\npython samples/python/agents/helloworld/__main__.py\n</code></pre> <p>You should see output similar to this, indicating the server is running:</p> <pre><code>INFO:     Started server process [xxxxx]\nINFO:     Waiting for application startup.\nINFO:     Application startup complete.\nINFO:     Uvicorn running on http://0.0.0.0:9999 (Press CTRL+C to quit)\n</code></pre> <p>Your A2A Helloworld agent is now live and listening for requests! In the next step, we'll interact with it.</p>"},{"location":"tutorials/python/6-interact-with-server/","title":"6. Interacting with the Server","text":"<p>With the Helloworld A2A server running, let's send some requests to it. The SDK includes a client (<code>A2AClient</code>) that simplifies these interactions.</p>"},{"location":"tutorials/python/6-interact-with-server/#the-helloworld-test-client","title":"The Helloworld Test Client","text":"<p>The <code>test_client.py</code> script demonstrates how to:</p> <ol> <li>Fetch the Agent Card from the server.</li> <li>Create an <code>A2AClient</code> instance.</li> <li>Send both non-streaming (<code>message/send</code>) and streaming (<code>message/stream</code>) requests.</li> </ol> <p>Open a new terminal window, activate your virtual environment, and navigate to the <code>a2a-samples</code> directory.</p> <p>Activate virtual environment (Be sure to do this in the same directory where you created the virtual environment):</p> Mac/LinuxWindows <pre><code>source .venv/bin/activate\n</code></pre> <pre><code>.venv\\Scripts\\activate\n</code></pre> <p>Run the test client:</p> <pre><code># from the a2a-samples directory\npython samples/python/agents/helloworld/test_client.py\n</code></pre>"},{"location":"tutorials/python/6-interact-with-server/#understanding-the-client-code","title":"Understanding the Client Code","text":"<p>Let's look at key parts of <code>test_client.py</code>:</p> <ol> <li> <p>Fetching the Agent Card &amp; Initializing the Client:</p> <pre><code>base_url = 'http://localhost:9999'\n\nasync with httpx.AsyncClient() as httpx_client:\n    # Initialize A2ACardResolver\n    resolver = A2ACardResolver(\n        httpx_client=httpx_client,\n        base_url=base_url,\n        # agent_card_path uses default, extended_agent_card_path also uses default\n    )\n</code></pre> <p>The <code>A2ACardResolver</code> class is a convenience. It first fetches the <code>AgentCard</code> from the server's <code>/.well-known/agent-card.json</code> endpoint (based on the provided base URL) and then initializes the client with it.</p> </li> <li> <p>Sending a Non-Streaming Message (<code>send_message</code>):</p> <pre><code>client = A2AClient(\n    httpx_client=httpx_client, agent_card=final_agent_card_to_use\n)\nlogger.info('A2AClient initialized.')\n\nsend_message_payload: dict[str, Any] = {\n    'message': {\n        'role': 'user',\n        'parts': [\n            {'kind': 'text', 'text': 'how much is 10 USD in INR?'}\n        ],\n        'messageId': uuid4().hex,\n    },\n}\nrequest = SendMessageRequest(\n    id=str(uuid4()), params=MessageSendParams(**send_message_payload)\n)\n\nresponse = await client.send_message(request)\nprint(response.model_dump(mode='json', exclude_none=True))\n</code></pre> <ul> <li>The <code>send_message_payload</code> constructs the data for <code>MessageSendParams</code>.</li> <li>This is wrapped in a <code>SendMessageRequest</code>.</li> <li>It includes a <code>message</code> object with the <code>role</code> set to \"user\" and the content in <code>parts</code>.</li> <li>The Helloworld agent's <code>execute</code> method will enqueue a single \"Hello World\" message. The <code>DefaultRequestHandler</code> will retrieve this and send it as the response.</li> <li>The <code>response</code> will be a <code>SendMessageResponse</code> object, which contains either a <code>SendMessageSuccessResponse</code> (with the agent's <code>Message</code> as the result) or a <code>JSONRPCErrorResponse</code>.</li> </ul> </li> <li> <p>Handling Task IDs (Illustrative Note for Helloworld):</p> <p>The Helloworld client (<code>test_client.py</code>) doesn't attempt <code>get_task</code> or <code>cancel_task</code> directly because the simple Helloworld agent's <code>execute</code> method, when called via <code>message/send</code>, results in the <code>DefaultRequestHandler</code> returning a direct <code>Message</code> response rather than a <code>Task</code> object. More complex agents that explicitly manage tasks (like the LangGraph example) would return a <code>Task</code> object from <code>message/send</code>, and its <code>id</code> could then be used for <code>get_task</code> or <code>cancel_task</code>.</p> </li> <li> <p>Sending a Streaming Message (<code>send_message_streaming</code>):</p> <pre><code>streaming_request = SendStreamingMessageRequest(\n    id=str(uuid4()), params=MessageSendParams(**send_message_payload)\n)\n\nstream_response = client.send_message_streaming(streaming_request)\n\nasync for chunk in stream_response:\n    print(chunk.model_dump(mode='json', exclude_none=True))\n</code></pre> <ul> <li>This method calls the agent's <code>message/stream</code> endpoint. The <code>DefaultRequestHandler</code> will invoke the <code>HelloWorldAgentExecutor.execute</code> method.</li> <li>The <code>execute</code> method enqueues one \"Hello World\" message, and then the event queue is closed.</li> <li>The client will receive this single message as one <code>SendStreamingMessageResponse</code> event, and then the stream will terminate.</li> <li>The <code>stream_response</code> is an <code>AsyncGenerator</code>.</li> </ul> </li> </ol>"},{"location":"tutorials/python/6-interact-with-server/#expected-output","title":"Expected Output","text":"<p>When you run <code>test_client.py</code>, you'll see JSON outputs for:</p> <ul> <li>The non-streaming response (a single \"Hello World\" message).</li> <li>The streaming response (a single \"Hello World\" message as one chunk, after which the stream ends).</li> </ul> <p>The <code>id</code> fields in the output will vary with each run.</p> <pre><code>// Non-streaming response\n{\"jsonrpc\":\"2.0\",\"id\":\"xxxxxxxx\",\"result\":{\"type\":\"message\",\"role\":\"agent\",\"parts\":[{\"type\":\"text\",\"text\":\"Hello World\"}],\"messageId\":\"yyyyyyyy\"}}\n// Streaming response (one chunk)\n{\"jsonrpc\":\"2.0\",\"id\":\"zzzzzzzz\",\"result\":{\"type\":\"message\",\"role\":\"agent\",\"parts\":[{\"type\":\"text\",\"text\":\"Hello World\"}],\"messageId\":\"wwwwwwww\",\"final\":true}}\n</code></pre> <p>(Actual IDs like <code>xxxxxxxx</code>, <code>yyyyyyyy</code>, <code>zzzzzzzz</code>, <code>wwwwwwww</code> will be different UUIDs/request IDs)</p> <p>This confirms your server is correctly handling basic A2A interactions with the updated SDK structure!</p> <p>Now you can shut down the server by typing Ctrl+C in the terminal window where <code>__main__.py</code> is running.</p>"},{"location":"tutorials/python/7-streaming-and-multiturn/","title":"7. Streaming &amp; Multi-Turn Interactions (LangGraph Example)","text":"<p>The Helloworld example demonstrates the basic mechanics of A2A. For more advanced features like robust streaming, task state management, and multi-turn conversations powered by an LLM, we'll turn to the LangGraph example located in <code>a2a-samples/samples/python/agents/langgraph/</code>.</p> <p>This example features a \"Currency Agent\" that uses the Gemini model via LangChain and LangGraph to answer currency conversion questions.</p>"},{"location":"tutorials/python/7-streaming-and-multiturn/#setting-up-the-langgraph-example","title":"Setting up the LangGraph Example","text":"<ol> <li> <p>Create a Gemini API Key, if you don't already have one.</p> </li> <li> <p>Environment Variable:</p> <p>Create a <code>.env</code> file in the <code>a2a-samples/samples/python/agents/langgraph/</code> directory:</p> <pre><code>echo \"GOOGLE_API_KEY=YOUR_API_KEY_HERE\" &gt; .env\n</code></pre> <p>Replace <code>YOUR_API_KEY_HERE</code> with your actual Gemini API key.</p> </li> <li> <p>Install Dependencies (if not already covered):</p> <p>The <code>langgraph</code> example has its own <code>pyproject.toml</code> which includes dependencies like <code>langchain-google-genai</code> and <code>langgraph</code>. When you installed the SDK from the <code>a2a-samples</code> root using <code>pip install -e .[dev]</code>, this should have also installed the dependencies for the workspace examples, including <code>langgraph-example</code>. If you encounter import errors, ensure your primary SDK installation from the root directory was successful.</p> </li> </ol>"},{"location":"tutorials/python/7-streaming-and-multiturn/#running-the-langgraph-server","title":"Running the LangGraph Server","text":"<p>Navigate to the <code>a2a-samples/samples/python/agents/langgraph/app</code> directory in your terminal and ensure your virtual environment (from the SDK root) is activated.</p> <p>Start the LangGraph agent server:</p> <pre><code>python __main__.py\n</code></pre> <p>This will start the server, usually on <code>http://localhost:10000</code>.</p>"},{"location":"tutorials/python/7-streaming-and-multiturn/#interacting-with-the-langgraph-agent","title":"Interacting with the LangGraph Agent","text":"<p>Open a new terminal window, activate your virtual environment, and navigate to <code>a2a-samples/samples/python/agents/langgraph/app</code>.</p> <p>Run its test client:</p> <pre><code>python test_client.py\n</code></pre> <p>Now, you can shut down the server by typing Ctrl+C in the terminal window where <code>__main__.py</code> is running.</p>"},{"location":"tutorials/python/7-streaming-and-multiturn/#key-features-demonstrated","title":"Key Features Demonstrated","text":"<p>The <code>langgraph</code> example showcases several important A2A concepts:</p> <ol> <li> <p>LLM Integration:</p> <ul> <li><code>agent.py</code> defines <code>CurrencyAgent</code>. It uses <code>ChatGoogleGenerativeAI</code> and LangGraph's <code>create_react_agent</code> to process user queries.</li> <li>This demonstrates how a real LLM can power the agent's logic.</li> </ul> </li> <li> <p>Task State Management:</p> <ul> <li> <p><code>samples/langgraph/__main__.py</code> initializes a <code>DefaultRequestHandler</code> with an <code>InMemoryTaskStore</code>.</p> <pre><code>httpx_client = httpx.AsyncClient()\npush_config_store = InMemoryPushNotificationConfigStore()\npush_sender = BasePushNotificationSender(httpx_client=httpx_client,\n                config_store=push_config_store)\nrequest_handler = DefaultRequestHandler(\n    agent_executor=CurrencyAgentExecutor(),\n    task_store=InMemoryTaskStore(),\n    push_config_store=push_config_store,\n    push_sender= push_sender\n)\nserver = A2AStarletteApplication(\n    agent_card=agent_card, http_handler=request_handler\n)\n\nuvicorn.run(server.build(), host=host, port=port)\n</code></pre> </li> <li> <p>The <code>CurrencyAgentExecutor</code> (in <code>samples/langgraph/agent_executor.py</code>), when its <code>execute</code> method is called by the <code>DefaultRequestHandler</code>, interacts with the <code>RequestContext</code> which contains the current task (if any).</p> </li> <li>For <code>message/send</code>, the <code>DefaultRequestHandler</code> uses the <code>TaskStore</code> to persist and retrieve task state across interactions. The response to <code>message/send</code> will be a full <code>Task</code> object if the agent's execution flow involves multiple steps or results in a persistent task.</li> <li>The <code>test_client.py</code>'s <code>run_single_turn_test</code> demonstrates getting a <code>Task</code> object back and then querying it using <code>get_task</code>.</li> </ul> </li> <li> <p>Streaming with <code>TaskStatusUpdateEvent</code> and <code>TaskArtifactUpdateEvent</code>:</p> <ul> <li>The <code>execute</code> method in <code>CurrencyAgentExecutor</code> is responsible for handling both non-streaming and streaming requests, orchestrated by the <code>DefaultRequestHandler</code>.</li> <li>As the LangGraph agent processes the request (which might involve calling tools like <code>get_exchange_rate</code>), the <code>CurrencyAgentExecutor</code> enqueues different types of events onto the <code>EventQueue</code>:<ul> <li><code>TaskStatusUpdateEvent</code>: For intermediate updates (e.g., \"Looking up exchange rates...\", \"Processing the exchange rates..\"). The <code>final</code> flag on these events is <code>False</code>.</li> <li><code>TaskArtifactUpdateEvent</code>: When the final answer is ready, it's enqueued as an artifact. The <code>lastChunk</code> flag is <code>True</code>.</li> <li>A final <code>TaskStatusUpdateEvent</code> with <code>state=TaskState.completed</code> and <code>final=True</code> is sent to signify the end of the task for streaming.</li> </ul> </li> <li>The <code>test_client.py</code>'s <code>run_streaming_test</code> function will print these individual event chunks as they are received from the server.</li> </ul> </li> <li> <p>Multi-Turn Conversation (<code>TaskState.input_required</code>):</p> <ul> <li>The <code>CurrencyAgent</code> can ask for clarification if a query is ambiguous (e.g., user asks \"how much is 100 USD?\").</li> <li>When this happens, the <code>CurrencyAgentExecutor</code> will enqueue a <code>TaskStatusUpdateEvent</code> where <code>status.state</code> is <code>TaskState.input_required</code> and <code>status.message</code> contains the agent's question (e.g., \"To which currency would you like to convert?\"). This event will have <code>final=True</code> for the current interaction stream.</li> <li>The <code>test_client.py</code>'s <code>run_multi_turn_test</code> function demonstrates this:<ul> <li>It sends an initial ambiguous query.</li> <li>The agent responds (via the <code>DefaultRequestHandler</code> processing the enqueued events) with a <code>Task</code> whose status is <code>input_required</code>.</li> <li>The client then sends a second message, including the <code>taskId</code> and <code>contextId</code> from the first turn's <code>Task</code> response, to provide the missing information (\"in GBP\"). This continues the same task.</li> </ul> </li> </ul> </li> </ol>"},{"location":"tutorials/python/7-streaming-and-multiturn/#exploring-the-code","title":"Exploring the Code","text":"<p>Take some time to look through these files:</p> <ul> <li><code>__main__.py</code>: Server setup using <code>A2AStarletteApplication</code> and <code>DefaultRequestHandler</code>. Note the <code>AgentCard</code> definition includes <code>capabilities.streaming=True</code>.</li> <li><code>agent.py</code>: The <code>CurrencyAgent</code> with LangGraph, LLM model, and tool definitions.</li> <li><code>agent_executor.py</code>: The <code>CurrencyAgentExecutor</code> implementing the <code>execute</code> (and <code>cancel</code>) method. It uses the <code>RequestContext</code> to understand the ongoing task and the <code>EventQueue</code> to send back various events (<code>TaskStatusUpdateEvent</code>, <code>TaskArtifactUpdateEvent</code>, new <code>Task</code> object implicitly via the first event if no task exists).</li> <li><code>test_client.py</code>: Demonstrates various interaction patterns, including retrieving task IDs and using them for multi-turn conversations.</li> </ul> <p>This example provides a much richer illustration of how A2A facilitates complex, stateful, and asynchronous interactions between agents.</p>"},{"location":"tutorials/python/8-next-steps/","title":"Next Steps","text":"<p>Congratulations on completing the A2A Python SDK Tutorial! You've learned how to:</p> <ul> <li>Set up your environment for A2A development.</li> <li>Define Agent Skills and Agent Cards using the SDK's types.</li> <li>Implement a basic HelloWorld A2A server and client.</li> <li>Understand and implement streaming capabilities.</li> <li>Integrate a more complex agent using LangGraph, demonstrating task state management and tool use.</li> </ul> <p>You now have a solid foundation for building and integrating your own A2A-compliant agents.</p>"},{"location":"tutorials/python/8-next-steps/#where-to-go-from-here","title":"Where to Go From Here?","text":"<p>Here are some ideas and resources to continue your A2A journey:</p> <ul> <li>Explore Other Examples:<ul> <li>Check out the other examples in the <code>a2a-samples/samples/</code> directory in the A2A GitHub repository for more complex agent integrations and features.</li> <li>The main A2A repository also has samples for other languages and frameworks.</li> </ul> </li> <li>Deepen Your Protocol Understanding:<ul> <li>\ud83d\udcda Read the complete A2A Protocol Documentation site for a comprehensive overview.</li> <li>\ud83d\udcdd Review the detailed A2A Protocol Specification to understand the nuances of all data structures and RPC methods.</li> </ul> </li> <li>Review Key A2A Topics:<ul> <li>A2A and MCP: Understand how A2A complements the Model Context Protocol for tool usage.</li> <li>Enterprise-Ready Features: Learn about security, observability, and other enterprise considerations.</li> <li>Streaming &amp; Asynchronous Operations: Get more details on SSE and push notifications.</li> <li>Agent Discovery: Explore different ways agents can find each other.</li> </ul> </li> <li>Build Your Own Agent:<ul> <li>Try creating a new A2A agent using your favorite Python agent framework (like LangChain, CrewAI, AutoGen, Semantic Kernel, or a custom solution).</li> <li>Implement the <code>a2a.server.AgentExecutor</code> interface to bridge your agent's logic with the A2A protocol.</li> <li>Think about what unique skills your agent could offer and how its Agent Card would represent them.</li> </ul> </li> <li>Experiment with Advanced Features:<ul> <li>Implement robust task management with a persistent <code>TaskStore</code> if your agent handles long-running or multi-session tasks.</li> <li>Explore implementing push notifications if your agent's tasks are very long-lived.</li> <li>Consider more complex input and output modalities (e.g., handling file uploads/downloads, or structured data via <code>DataPart</code>).</li> </ul> </li> <li>Contribute to the A2A Community:<ul> <li>Join the discussions on the A2A GitHub Discussions page.</li> <li>Report issues or suggest improvements via GitHub Issues.</li> <li>Consider contributing code, examples, or documentation. See the CONTRIBUTING.md guide.</li> </ul> </li> </ul> <p>The A2A protocol aims to foster an ecosystem of interoperable AI agents. By building and sharing A2A-compliant agents, you can be a part of this exciting development!</p>"}]}